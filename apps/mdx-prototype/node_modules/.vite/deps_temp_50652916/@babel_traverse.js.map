{
  "version": 3,
  "sources": ["../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/lib/virtual-types.ts", "../../.pnpm/ms@2.1.3/node_modules/ms/index.js", "../../.pnpm/debug@4.4.1/node_modules/debug/src/common.js", "../../.pnpm/debug@4.4.1/node_modules/debug/src/browser.js", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/lib/virtual-types-validator.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/visitors.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/scope/lib/renamer.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/scope/binding.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/cache.ts", "../../.pnpm/@babel+helper-globals@7.28.0/node_modules/@babel/helper-globals/data/builtin-lower.json", "../../.pnpm/@babel+helper-globals@7.28.0/node_modules/@babel/helper-globals/data/builtin-upper.json", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/scope/index.ts", "../../.pnpm/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts", "../../.pnpm/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts", "../../.pnpm/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/src/strings.ts", "../../.pnpm/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts", "../../.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/src/resolve-uri.ts", "../../.pnpm/@jridgewell+trace-mapping@0.3.30/node_modules/@jridgewell/trace-mapping/dist/umd:@jridgewell/sourcemap-codec", "../../.pnpm/@jridgewell+trace-mapping@0.3.30/node_modules/@jridgewell/trace-mapping/dist/umd:@jridgewell/resolve-uri", "../../.pnpm/@jridgewell+trace-mapping@0.3.30/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts", "../../.pnpm/@jridgewell+trace-mapping@0.3.30/node_modules/@jridgewell/trace-mapping/src/resolve.ts", "../../.pnpm/@jridgewell+trace-mapping@0.3.30/node_modules/@jridgewell/trace-mapping/src/strip-filename.ts", "../../.pnpm/@jridgewell+trace-mapping@0.3.30/node_modules/@jridgewell/trace-mapping/src/sourcemap-segment.ts", "../../.pnpm/@jridgewell+trace-mapping@0.3.30/node_modules/@jridgewell/trace-mapping/src/sort.ts", "../../.pnpm/@jridgewell+trace-mapping@0.3.30/node_modules/@jridgewell/trace-mapping/src/binary-search.ts", "../../.pnpm/@jridgewell+trace-mapping@0.3.30/node_modules/@jridgewell/trace-mapping/src/by-source.ts", "../../.pnpm/@jridgewell+trace-mapping@0.3.30/node_modules/@jridgewell/trace-mapping/src/types.ts", "../../.pnpm/@jridgewell+trace-mapping@0.3.30/node_modules/@jridgewell/trace-mapping/src/flatten-map.ts", "../../.pnpm/@jridgewell+gen-mapping@0.3.13/node_modules/@jridgewell/gen-mapping/dist/umd:@jridgewell/sourcemap-codec", "../../.pnpm/@jridgewell+gen-mapping@0.3.13/node_modules/@jridgewell/gen-mapping/dist/umd:@jridgewell/trace-mapping", "../../.pnpm/@jridgewell+gen-mapping@0.3.13/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts", "../../.pnpm/@jridgewell+gen-mapping@0.3.13/node_modules/@jridgewell/gen-mapping/src/set-array.ts", "../../.pnpm/@jridgewell+gen-mapping@0.3.13/node_modules/@jridgewell/gen-mapping/src/sourcemap-segment.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/source-map.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/buffer.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/node/whitespace.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/node/parentheses.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/node/index.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/token-map.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/generators/template-literals.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/generators/expressions.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/generators/statements.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/generators/classes.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/generators/methods.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/generators/modules.ts", "../../.pnpm/jsesc@3.1.0/node_modules/jsesc/jsesc.js", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/generators/types.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/generators/flow.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/generators/base.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/generators/jsx.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/generators/typescript.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/generators/index.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/generators/deprecated.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/printer.ts", "../../.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/src/index.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/ancestry.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/inference/util.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/inference/inferer-reference.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/inference/inferers.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/inference/index.ts", "../../.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.browser.js", "../../.pnpm/js-tokens@4.0.0/node_modules/js-tokens/index.js", "../../.pnpm/@babel+code-frame@7.27.1/node_modules/@babel/code-frame/src/defs.ts", "../../.pnpm/@babel+code-frame@7.27.1/node_modules/@babel/code-frame/src/highlight.ts", "../../.pnpm/@babel+code-frame@7.27.1/node_modules/@babel/code-frame/src/index.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/lib/removal-hooks.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/removal.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/lib/hoister.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/modification.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/replacement.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/evaluation.ts", "../../.pnpm/@babel+template@7.27.2/node_modules/@babel/template/src/formatters.ts", "../../.pnpm/@babel+template@7.27.2/node_modules/@babel/template/src/options.ts", "../../.pnpm/@babel+template@7.27.2/node_modules/@babel/template/src/parse.ts", "../../.pnpm/@babel+template@7.27.2/node_modules/@babel/template/src/populate.ts", "../../.pnpm/@babel+template@7.27.2/node_modules/@babel/template/src/string.ts", "../../.pnpm/@babel+template@7.27.2/node_modules/@babel/template/src/literal.ts", "../../.pnpm/@babel+template@7.27.2/node_modules/@babel/template/src/builder.ts", "../../.pnpm/@babel+template@7.27.2/node_modules/@babel/template/src/index.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/conversion.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/introspection.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/family.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/comments.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/index.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/context.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/traverse-node.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/path/context.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/hub.ts", "../../.pnpm/@babel+traverse@7.28.3/node_modules/@babel/traverse/src/index.ts"],
  "sourcesContent": ["import type * as t from \"@babel/types\";\n\nexport interface VirtualTypeAliases {\n  BindingIdentifier: t.Identifier;\n  BlockScoped: t.Node;\n  ExistentialTypeParam: t.ExistsTypeAnnotation;\n  Expression: t.Expression;\n  Flow: t.Flow | t.ImportDeclaration | t.ExportDeclaration | t.ImportSpecifier;\n  ForAwaitStatement: t.ForOfStatement;\n  Generated: t.Node;\n  NumericLiteralTypeAnnotation: t.NumberLiteralTypeAnnotation;\n  Pure: t.Node;\n  Referenced: t.Node;\n  ReferencedIdentifier: t.Identifier | t.JSXIdentifier;\n  ReferencedMemberExpression: t.MemberExpression;\n  RestProperty: t.RestElement;\n  Scope: t.Scopable | t.Pattern;\n  SpreadProperty: t.RestElement;\n  Statement: t.Statement;\n  User: t.Node;\n  Var: t.VariableDeclaration;\n}\n\ntype VirtualTypeMapping = readonly (t.Node[\"type\"] | keyof t.Aliases)[] | null;\n\nexport const ReferencedIdentifier: VirtualTypeMapping = [\n  \"Identifier\",\n  \"JSXIdentifier\",\n] as const;\n\nexport const ReferencedMemberExpression: VirtualTypeMapping = [\n  \"MemberExpression\",\n] as const;\n\nexport const BindingIdentifier: VirtualTypeMapping = [\"Identifier\"] as const;\n\nexport const Statement: VirtualTypeMapping = [\"Statement\"] as const;\n\nexport const Expression: VirtualTypeMapping = [\"Expression\"] as const;\n\nexport const Scope: VirtualTypeMapping = [\"Scopable\", \"Pattern\"] as const;\n\nexport const Referenced: VirtualTypeMapping = null;\n\nexport const BlockScoped: VirtualTypeMapping = null;\n\nexport const Var: VirtualTypeMapping = [\"VariableDeclaration\"];\n\nexport const User: VirtualTypeMapping = null;\n\nexport const Generated: VirtualTypeMapping = null;\n\nexport const Pure: VirtualTypeMapping = null;\n\nexport const Flow: VirtualTypeMapping = [\n  \"Flow\",\n  \"ImportDeclaration\",\n  \"ExportDeclaration\",\n  \"ImportSpecifier\",\n] as const;\n\n// TODO: 7.0 Backwards Compat\nexport const RestProperty: VirtualTypeMapping = [\"RestElement\"] as const;\n\nexport const SpreadProperty: VirtualTypeMapping = [\"RestElement\"] as const;\n\nexport const ExistentialTypeParam: VirtualTypeMapping = [\n  \"ExistsTypeAnnotation\",\n] as const;\n\nexport const NumericLiteralTypeAnnotation: VirtualTypeMapping = [\n  \"NumberLiteralTypeAnnotation\",\n] as const;\n\nexport const ForAwaitStatement: VirtualTypeMapping = [\n  \"ForOfStatement\",\n] as const;\n", "/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n", "\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(/\\s+/g, ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n", "/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n", "import type NodePath from \"../index.ts\";\nimport {\n  isBinding,\n  isBlockScoped as nodeIsBlockScoped,\n  isExportDeclaration,\n  isExpression as nodeIsExpression,\n  isFlow as nodeIsFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isRestElement as nodeIsRestElement,\n  isReferenced as nodeIsReferenced,\n  isScope as nodeIsScope,\n  isStatement as nodeIsStatement,\n  isVar as nodeIsVar,\n  isVariableDeclaration,\n  react,\n  isForOfStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nconst { isCompatTag } = react;\nimport type { VirtualTypeAliases } from \"./virtual-types.ts\";\n\ntype Opts<Obj> = Partial<{\n  [Prop in keyof Obj]: Obj[Prop] extends t.Node\n    ? t.Node\n    : Obj[Prop] extends t.Node[]\n      ? t.Node[]\n      : Obj[Prop];\n}>;\n\nexport interface VirtualTypeNodePathValidators {\n  isBindingIdentifier(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"BindingIdentifier\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"BindingIdentifier\"]>;\n  isBlockScoped(opts?: Opts<VirtualTypeAliases[\"BlockScoped\"]>): boolean;\n  /**\n   * @deprecated\n   */\n  isExistentialTypeParam(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"ExistentialTypeParam\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"ExistentialTypeParam\"]>;\n  isExpression(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Expression\"]>,\n  ): this is NodePath<t.Expression>;\n  isFlow(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Flow\"]>,\n  ): this is NodePath<t.Flow>;\n  isForAwaitStatement(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"ForAwaitStatement\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"ForAwaitStatement\"]>;\n  isGenerated(opts?: VirtualTypeAliases[\"Generated\"]): boolean;\n  /**\n   * @deprecated\n   */\n  isNumericLiteralTypeAnnotation(\n    opts?: VirtualTypeAliases[\"NumericLiteralTypeAnnotation\"],\n  ): void;\n  isPure(opts?: VirtualTypeAliases[\"Pure\"]): boolean;\n  isReferenced(opts?: VirtualTypeAliases[\"Referenced\"]): boolean;\n  isReferencedIdentifier(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"ReferencedIdentifier\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"ReferencedIdentifier\"]>;\n  isReferencedMemberExpression(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"ReferencedMemberExpression\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"ReferencedMemberExpression\"]>;\n  isRestProperty(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"RestProperty\"]>,\n  ): this is NodePath<t.RestProperty>;\n  isScope(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Scope\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"Scope\"]>;\n  isSpreadProperty(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"SpreadProperty\"]>,\n  ): this is NodePath<t.SpreadProperty>;\n  isStatement(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Statement\"]>,\n  ): this is NodePath<t.Statement>;\n  isUser(opts?: VirtualTypeAliases[\"User\"]): boolean;\n  isVar(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Var\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"Var\"]>;\n}\n\nexport function isReferencedIdentifier(this: NodePath, opts?: any): boolean {\n  const { node, parent } = this;\n  if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n    if (isJSXIdentifier(node, opts)) {\n      if (isCompatTag(node.name)) return false;\n    } else {\n      // not a JSXIdentifier or an Identifier\n      return false;\n    }\n  }\n\n  // check if node is referenced\n  return nodeIsReferenced(node, parent, this.parentPath.parent);\n}\n\nexport function isReferencedMemberExpression(this: NodePath): boolean {\n  const { node, parent } = this;\n  return isMemberExpression(node) && nodeIsReferenced(node, parent);\n}\n\nexport function isBindingIdentifier(this: NodePath): boolean {\n  const { node, parent } = this;\n  const grandparent = this.parentPath.parent;\n  return isIdentifier(node) && isBinding(node, parent, grandparent);\n}\n\nexport function isStatement(this: NodePath): boolean {\n  const { node, parent } = this;\n  if (nodeIsStatement(node)) {\n    if (isVariableDeclaration(node)) {\n      if (isForXStatement(parent, { left: node })) return false;\n      if (isForStatement(parent, { init: node })) return false;\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function isExpression(this: NodePath): boolean {\n  if (this.isIdentifier()) {\n    return this.isReferencedIdentifier();\n  } else {\n    return nodeIsExpression(this.node);\n  }\n}\n\nexport function isScope(this: NodePath): boolean {\n  return nodeIsScope(this.node, this.parent);\n}\n\nexport function isReferenced(this: NodePath): boolean {\n  return nodeIsReferenced(this.node, this.parent);\n}\n\nexport function isBlockScoped(this: NodePath): boolean {\n  return nodeIsBlockScoped(this.node);\n}\n\nexport function isVar(this: NodePath): boolean {\n  return nodeIsVar(this.node);\n}\n\nexport function isUser(this: NodePath): boolean {\n  return this.node && !!this.node.loc;\n}\n\nexport function isGenerated(this: NodePath): boolean {\n  return !this.isUser();\n}\n\nexport function isPure(this: NodePath, constantsOnly?: boolean): boolean {\n  return this.scope.isPure(this.node, constantsOnly);\n}\n\nexport function isFlow(this: NodePath): boolean {\n  const { node } = this;\n  if (nodeIsFlow(node)) {\n    return true;\n  } else if (isImportDeclaration(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else if (isExportDeclaration(node)) {\n    return node.exportKind === \"type\";\n  } else if (isImportSpecifier(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else {\n    return false;\n  }\n}\n\n// TODO: 7.0 Backwards Compat\nexport function isRestProperty(this: NodePath): boolean {\n  return nodeIsRestElement(this.node) && this.parentPath?.isObjectPattern();\n}\n\nexport function isSpreadProperty(this: NodePath): boolean {\n  return nodeIsRestElement(this.node) && this.parentPath?.isObjectExpression();\n}\n\nexport function isForAwaitStatement(this: NodePath): boolean {\n  return isForOfStatement(this.node, { await: true });\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.isExistentialTypeParam = function isExistentialTypeParam(\n    this: NodePath,\n  ): void {\n    throw new Error(\n      \"`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.\",\n    );\n  };\n\n  // eslint-disable-next-line no-restricted-globals\n  exports.isNumericLiteralTypeAnnotation =\n    function isNumericLiteralTypeAnnotation(this: NodePath): void {\n      throw new Error(\n        \"`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.\",\n      );\n    };\n}\n", "import * as virtualTypes from \"./path/lib/virtual-types.ts\";\nimport * as virtualTypesValidators from \"./path/lib/virtual-types-validator.ts\";\nimport type { Node } from \"@babel/types\";\nimport {\n  DEPRECATED_KEYS,\n  DEPRECATED_ALIASES,\n  FLIPPED_ALIAS_KEYS,\n  TYPES,\n  __internal__deprecationWarning as deprecationWarning,\n} from \"@babel/types\";\nimport type { ExplodedVisitor, NodePath, Visitor } from \"./index.ts\";\nimport type { ExplVisitNode, VisitNodeFunction, VisitPhase } from \"./types.ts\";\nimport { requeueComputedKeyAndDecorators } from \"./path/context.ts\";\n\ntype VIRTUAL_TYPES = keyof typeof virtualTypes;\nfunction isVirtualType(type: string): type is VIRTUAL_TYPES {\n  return type in virtualTypes;\n}\nexport type VisitWrapper<S = any> = (\n  stateName: string | undefined,\n  visitorType: VisitPhase,\n  callback: VisitNodeFunction<S, Node>,\n) => VisitNodeFunction<S, Node>;\n\nexport function isExplodedVisitor(\n  visitor: Visitor,\n): visitor is ExplodedVisitor {\n  // @ts-expect-error _exploded is not defined on non-exploded Visitor\n  return visitor?._exploded;\n}\n\n// We need to name this function `explode$1` because otherwise rollup-plugin-dts\n// will generate a `namespace traverse { var explode: typeof explode; }` when\n// bundling @babel/traverse's index.d.ts.\n// TODO: Just call it `explode` once https://github.com/Swatinem/rollup-plugin-dts/issues/307\n// is fixed.\nexport { explode$1 as explode };\n/**\n * explode() will take a visitor object with all of the various shorthands\n * that we support, and validates & normalizes it into a common format, ready\n * to be used in traversal\n *\n * The various shorthands are:\n * * `Identifier() { ... }` -> `Identifier: { enter() { ... } }`\n * * `\"Identifier|NumericLiteral\": { ... }` -> `Identifier: { ... }, NumericLiteral: { ... }`\n * * Aliases in `@babel/types`: e.g. `Property: { ... }` -> `ObjectProperty: { ... }, ClassProperty: { ... }`\n * Other normalizations are:\n * * Visitors of virtual types are wrapped, so that they are only visited when\n *   their dynamic check passes\n * * `enter` and `exit` functions are wrapped in arrays, to ease merging of\n *   visitors\n */\nfunction explode$1<S>(visitor: Visitor<S>): ExplodedVisitor<S> {\n  if (isExplodedVisitor(visitor)) return visitor;\n  // @ts-expect-error `visitor` will be cast to ExplodedVisitor by this function\n  visitor._exploded = true;\n\n  // normalise pipes\n  for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    const parts: Array<string> = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      // @ts-expect-error part will be verified by `verify` later\n      visitor[part] = fns;\n    }\n  }\n\n  // verify data structure\n  verify$1(visitor);\n\n  // make sure there's no __esModule type since this is because we're using loose mode\n  // and it sets __esModule to be enumerable on all modules :(\n  // @ts-expect-error ESModule interop\n  delete visitor.__esModule;\n\n  // ensure visitors are objects\n  ensureEntranceObjects(visitor);\n\n  // ensure enter/exit callbacks are arrays\n  ensureCallbackArrays(visitor);\n\n  // add type wrappers\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (!isVirtualType(nodeType)) continue;\n\n    // wrap all the functions\n    const fns = visitor[nodeType];\n    for (const type of Object.keys(fns)) {\n      // @ts-expect-error normalised as VisitNodeObject\n      fns[type] = wrapCheck(nodeType, fns[type]);\n    }\n\n    // clear it from the visitor\n    delete visitor[nodeType];\n\n    const types = virtualTypes[nodeType];\n    if (types !== null) {\n      for (const type of types) {\n        // merge the visitor if necessary or just put it back in\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          // @ts-expect-error Expression produces too complex union\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  // add aliases\n  for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    let aliases = FLIPPED_ALIAS_KEYS[nodeType];\n\n    if (nodeType in DEPRECATED_KEYS) {\n      const deprecatedKey = DEPRECATED_KEYS[nodeType];\n      deprecationWarning(nodeType, deprecatedKey, \"Visitor \");\n      aliases = [deprecatedKey];\n    } else if (nodeType in DEPRECATED_ALIASES) {\n      const deprecatedAlias =\n        DEPRECATED_ALIASES[nodeType as keyof typeof DEPRECATED_ALIASES];\n      deprecationWarning(nodeType, deprecatedAlias, \"Visitor \");\n      aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];\n    }\n\n    if (!aliases) continue;\n\n    const fns = visitor[nodeType];\n    // clear it from the visitor\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = { ...fns };\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    ensureCallbackArrays(\n      // @ts-expect-error nodeType must present in visitor after previous validations\n      visitor[nodeType],\n    );\n  }\n\n  // @ts-expect-error explosion has been performed\n  return visitor as ExplodedVisitor;\n}\n\n// We need to name this function `verify$1` because otherwise rollup-plugin-dts\n// will generate a `namespace traverse { var verify: typeof verify; }` when\n// bundling @babel/traverse's index.d.ts.\n// TODO: Just call it `verify` once https://github.com/Swatinem/rollup-plugin-dts/issues/307\n// is fixed.\nexport { verify$1 as verify };\nfunction verify$1(visitor: Visitor) {\n  // @ts-expect-error _verified is not defined on non-verified Visitor.\n  // TODO: unify _verified and _exploded.\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\n      \"You passed `traverse()` a function when it expected a visitor object, \" +\n        \"are you sure you didn't mean `{ enter: Function }`?\",\n    );\n  }\n\n  for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (!TYPES.includes(nodeType)) {\n      throw new Error(\n        `You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${PACKAGE_JSON.version}`,\n      );\n    }\n\n    const visitors = visitor[nodeType];\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          // verify that it just contains functions\n          validateVisitorMethods(\n            `${nodeType}.${visitorKey}`,\n            visitors[visitorKey],\n          );\n        } else {\n          throw new Error(\n            \"You passed `traverse()` a visitor object with the property \" +\n              `${nodeType} that has the invalid property ${visitorKey}`,\n          );\n        }\n      }\n    }\n  }\n\n  // @ts-expect-error _verified is not defined on non-verified Visitor.\n  // TODO: unify _verified and _exploded.\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(\n  path: string,\n  val: any,\n): asserts val is Function | Function[] {\n  const fns = [].concat(val);\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(\n        `Non-function found defined in ${path} with type ${typeof fn}`,\n      );\n    }\n  }\n}\n\nexport function merge<State>(\n  visitors: Visitor<State>[],\n): ExplodedVisitor<State>;\nexport function merge(\n  visitors: Visitor<unknown>[],\n  states?: any[],\n  wrapper?: Function | null,\n): ExplodedVisitor<unknown>;\nexport function merge(\n  visitors: any[],\n  states: any[] = [],\n  wrapper?: VisitWrapper | null,\n): ExplodedVisitor {\n  const mergedVisitor: ExplodedVisitor = { _verified: true, _exploded: true };\n  if (!process.env.BABEL_8_BREAKING) {\n    // For compatibility with old Babel versions, we must hide _verified and _exploded.\n    // Otherwise, old versions of the validator will throw sayng that `true` is not\n    // a function, because it tries to validate it as a visitor.\n    Object.defineProperty(mergedVisitor, \"_exploded\", { enumerable: false });\n    Object.defineProperty(mergedVisitor, \"_verified\", { enumerable: false });\n  }\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = explode$1(visitors[i]);\n    const state = states[i];\n\n    let topVisitor: ExplVisitNode<unknown, Node> = visitor;\n    if (state || wrapper) {\n      topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);\n    }\n    mergePair(mergedVisitor, topVisitor);\n\n    for (const key of Object.keys(visitor) as (keyof ExplodedVisitor)[]) {\n      if (shouldIgnoreKey(key)) continue;\n\n      let typeVisitor = visitor[key];\n\n      // if we have state or wrapper then overload the callbacks to take it\n      if (state || wrapper) {\n        typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);\n      }\n\n      const nodeVisitor = (mergedVisitor[key] ||= {});\n      mergePair(nodeVisitor, typeVisitor);\n    }\n  }\n\n  return mergedVisitor;\n}\n\nfunction wrapWithStateOrWrapper<State>(\n  oldVisitor: ExplVisitNode<State, Node>,\n  state: State | null,\n  wrapper?: VisitWrapper<State> | null,\n): ExplVisitNode<State, Node> {\n  const newVisitor: ExplVisitNode<State, Node> = {};\n\n  for (const phase of [\"enter\", \"exit\"] as VisitPhase[]) {\n    let fns = oldVisitor[phase];\n\n    // not an enter/exit array of callbacks\n    if (!Array.isArray(fns)) continue;\n\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path: NodePath) {\n          fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        // @ts-expect-error Fixme: actually PluginPass.key (aka pluginAlias)?\n        newFn = wrapper(state?.key, phase, newFn);\n      }\n\n      // Override toString in case this function is printed, we want to print the wrapped function, same as we do in `wrapCheck`\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n\n    newVisitor[phase] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj: Visitor) {\n  for (const key of Object.keys(obj) as (keyof Visitor)[]) {\n    if (shouldIgnoreKey(key)) continue;\n\n    const fns = obj[key];\n    if (typeof fns === \"function\") {\n      // @ts-expect-error: Expression produces a union type that is too complex to represent.\n      obj[key] = { enter: fns };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj: Visitor) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(nodeType: VIRTUAL_TYPES, fn: Function) {\n  const fnKey = `is${nodeType}`;\n  // @ts-expect-error we know virtualTypesValidators will contain `fnKey`, but TS doesn't\n  const validator = virtualTypesValidators[fnKey];\n  const newFn = function (this: unknown, path: NodePath) {\n    if (validator.call(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n  newFn.toString = () => fn.toString();\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key: string): key is\n  | `_${string}` // ` // Comment to fix syntax highlighting in vscode\n  | \"enter\"\n  | \"exit\"\n  | \"shouldSkip\"\n  | \"denylist\"\n  | \"noScope\"\n  | \"skipKeys\"\n  | \"blacklist\" {\n  // internal/hidden key\n  if (key[0] === \"_\") return true;\n\n  // ignore function keys\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  // ignore other options\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\") {\n    return true;\n  }\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (key === \"blacklist\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/*\nfunction mergePair(\n  dest: ExplVisitNode<unknown, Node>,\n  src: ExplVisitNode<unknown, Node>,\n);\n*/\nfunction mergePair(dest: any, src: any) {\n  for (const phase of [\"enter\", \"exit\"] as VisitPhase[]) {\n    if (!src[phase]) continue;\n    dest[phase] = [].concat(dest[phase] || [], src[phase]);\n  }\n}\n\n// environmentVisitor should be used when traversing the whole class and not for specific class elements/methods.\n// For perf reasons, the environmentVisitor might be traversed with `{ noScope: true }`, which means `path.scope` is undefined.\n// Avoid using `path.scope` here\nconst _environmentVisitor: Visitor = {\n  FunctionParent(path) {\n    // arrows are not skipped because they inherit the context.\n    if (path.isArrowFunctionExpression()) return;\n\n    path.skip();\n    if (path.isMethod()) {\n      if (\n        !process.env.BABEL_8_BREAKING &&\n        !path.requeueComputedKeyAndDecorators\n      ) {\n        // See https://github.com/babel/babel/issues/16694\n        requeueComputedKeyAndDecorators.call(path);\n      } else {\n        path.requeueComputedKeyAndDecorators();\n      }\n    }\n  },\n  Property(path) {\n    if (path.isObjectProperty()) return;\n    path.skip();\n    if (\n      !process.env.BABEL_8_BREAKING &&\n      !path.requeueComputedKeyAndDecorators\n    ) {\n      // See https://github.com/babel/babel/issues/16694\n      requeueComputedKeyAndDecorators.call(path);\n    } else {\n      path.requeueComputedKeyAndDecorators();\n    }\n  },\n};\n\nexport function environmentVisitor<S>(visitor: Visitor<S>): Visitor<S> {\n  return merge([_environmentVisitor, visitor]);\n}\n", "import type Binding from \"../binding.ts\";\nimport * as t from \"@babel/types\";\nimport type { NodePath, Visitor } from \"../../index.ts\";\nimport { traverseNode } from \"../../traverse-node.ts\";\nimport { explode } from \"../../visitors.ts\";\nimport { getAssignmentIdentifiers, type Identifier } from \"@babel/types\";\nimport { requeueComputedKeyAndDecorators } from \"../../path/context.ts\";\n\nconst renameVisitor: Visitor<Renamer> = {\n  ReferencedIdentifier({ node }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (\n      !path.scope.bindingIdentifierEquals(\n        state.oldName,\n        state.binding.identifier,\n      )\n    ) {\n      path.skip();\n      if (path.isMethod()) {\n        if (\n          !process.env.BABEL_8_BREAKING &&\n          !path.requeueComputedKeyAndDecorators\n        ) {\n          // See https://github.com/babel/babel/issues/16694\n          requeueComputedKeyAndDecorators.call(path);\n        } else {\n          path.requeueComputedKeyAndDecorators();\n        }\n      }\n    }\n  },\n\n  ObjectProperty({ node, scope }, state) {\n    const { name } = node.key as Identifier;\n    if (\n      node.shorthand &&\n      // In destructuring the identifier is already renamed by the\n      // AssignmentExpression|Declaration|VariableDeclarator visitor,\n      // while in object literals it's renamed later by the\n      // ReferencedIdentifier visitor.\n      (name === state.oldName || name === state.newName) &&\n      // Ignore shadowed bindings\n      scope.getBindingIdentifier(name) === state.binding.identifier\n    ) {\n      node.shorthand = false;\n      if (!process.env.BABEL_8_BREAKING) {\n        if (node.extra?.shorthand) node.extra.shorthand = false;\n      }\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(\n    path: NodePath<\n      t.AssignmentExpression | t.Declaration | t.VariableDeclarator\n    >,\n    state,\n  ) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.isAssignmentExpression()\n      ? // See https://github.com/babel/babel/issues/16694\n        getAssignmentIdentifiers(path.node)\n      : path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  },\n};\n\nexport default class Renamer {\n  constructor(binding: Binding, oldName: string, newName: string) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  declare oldName: string;\n  declare newName: string;\n  declare binding: Binding;\n\n  maybeConvertFromExportDeclaration(parentDeclar: NodePath) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration()) {\n      const { declaration } = maybeExportDeclar.node;\n      if (t.isDeclaration(declaration) && !declaration.id) {\n        return;\n      }\n    }\n\n    if (maybeExportDeclar.isExportAllDeclaration()) {\n      return;\n    }\n\n    maybeExportDeclar.splitExportDeclaration();\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path: NodePath) {\n    return path; // TODO\n\n    // // retain the `name` of a class/function declaration\n\n    // if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    // if (this.binding.kind !== \"hoisted\") return;\n\n    // path.node.id = identifier(this.oldName);\n    // path.node._blockHoist = 3;\n\n    // path.replaceWith(\n    //   variableDeclaration(\"let\", [\n    //     variableDeclarator(identifier(this.newName), toExpression(path.node)),\n    //   ]),\n    // );\n  }\n\n  maybeConvertFromClassFunctionExpression(path: NodePath) {\n    return path; // TODO\n\n    // // retain the `name` of a class/function expression\n\n    // if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    // if (this.binding.kind !== \"local\") return;\n\n    // path.node.id = identifier(this.oldName);\n\n    // this.binding.scope.parent.push({\n    //   id: identifier(this.newName),\n    // });\n\n    // path.replaceWith(\n    //   assignmentExpression(\"=\", identifier(this.newName), path.node),\n    // );\n  }\n\n  rename(/* Babel 7 - block?: t.Pattern | t.Scopable */) {\n    const { binding, oldName, newName } = this;\n    const { scope, path } = binding;\n\n    const parentDeclar = path.find(\n      path =>\n        path.isDeclaration() ||\n        path.isFunctionExpression() ||\n        path.isClassExpression(),\n    );\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n      if (bindingIds[oldName] === binding.identifier) {\n        // When we are renaming an exported identifier, we need to ensure that\n        // the exported binding keeps the old name.\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = process.env.BABEL_8_BREAKING\n      ? scope.block\n      : (arguments[0] as t.Pattern | t.Scopable) || scope.block;\n\n    // When blockToTraverse is a SwitchStatement, the discriminant\n    // is not part of the current scope and thus should be skipped.\n\n    // const foo = {\n    //   get [x]() {\n    //     return x;\n    //   },\n    // };\n    const skipKeys: Record<string, true> = { discriminant: true };\n    if (t.isMethod(blockToTraverse)) {\n      if (blockToTraverse.computed) {\n        skipKeys.key = true;\n      }\n      if (!t.isObjectMethod(blockToTraverse)) {\n        skipKeys.decorators = true;\n      }\n    }\n\n    traverseNode(\n      blockToTraverse,\n      explode(renameVisitor),\n      scope,\n      this,\n      scope.path,\n      skipKeys,\n    );\n\n    if (process.env.BABEL_8_BREAKING) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    } else if (!arguments[0]) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(path);\n      this.maybeConvertFromClassFunctionExpression(path);\n    }\n  }\n}\n", "import type NodePath from \"../path/index.ts\";\nimport type * as t from \"@babel/types\";\nimport type Scope from \"./index.ts\";\n\nexport type BindingKind =\n  | \"var\" /* var declarator */\n  | \"let\" /* let declarator, class declaration id, catch clause parameters */\n  | \"const\" /* const/using/await using declarator */\n  | \"module\" /* import specifiers */\n  | \"hoisted\" /* function declaration id */\n  | \"param\" /* function declaration parameters */\n  | \"local\" /* function expression id, class expression id */\n  | \"unknown\"; /* export specifiers */\n/**\n * This class is responsible for a binding inside of a scope.\n *\n * It tracks the following:\n *\n *  * Node path.\n *  * Amount of times referenced by other nodes.\n *  * Paths to nodes that reassign or modify this binding.\n *  * The kind of binding. (Is it a parameter, declaration etc)\n */\n\nexport default class Binding {\n  identifier: t.Identifier;\n  scope: Scope;\n  path: NodePath;\n  kind: BindingKind;\n\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind,\n  }: {\n    identifier: t.Identifier;\n    scope: Scope;\n    path: NodePath;\n    kind: BindingKind;\n  }) {\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n\n    if ((kind === \"var\" || kind === \"hoisted\") && isInitInLoop(path)) {\n      this.reassign(path);\n    }\n\n    this.clearValue();\n  }\n\n  constantViolations: Array<NodePath> = [];\n  constant: boolean = true;\n\n  referencePaths: Array<NodePath> = [];\n  referenced: boolean = false;\n  references: number = 0;\n\n  declare hasDeoptedValue: boolean;\n  declare hasValue: boolean;\n  declare value: any;\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value: any) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  /**\n   * Register a constant violation with the provided `path`.\n   */\n\n  reassign(path: NodePath) {\n    this.constant = false;\n    if (this.constantViolations.includes(path)) {\n      return;\n    }\n    this.constantViolations.push(path);\n  }\n\n  /**\n   * Increment the amount of references to this binding.\n   */\n\n  reference(path: NodePath) {\n    if (this.referencePaths.includes(path)) {\n      return;\n    }\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  /**\n   * Decrement the amount of references to this binding.\n   */\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n}\n\nfunction isInitInLoop(path: NodePath) {\n  const isFunctionDeclarationOrHasInit =\n    !path.isVariableDeclarator() || path.node.init;\n  for (\n    let { parentPath, key } = path;\n    parentPath;\n    { parentPath, key } = parentPath\n  ) {\n    if (parentPath.isFunctionParent()) return false;\n    if (\n      (key === \"left\" && parentPath.isForXStatement()) ||\n      (isFunctionDeclarationOrHasInit && key === \"body\" && parentPath.isLoop())\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n", "import type { Node } from \"@babel/types\";\nimport type NodePath from \"./path/index.ts\";\nimport type Scope from \"./scope/index.ts\";\n\nlet pathsCache: WeakMap<Node, Map<Node, NodePath>> = new WeakMap();\nexport { pathsCache as path };\nexport let scope: WeakMap<Node, Scope> = new WeakMap();\n\nexport function clear() {\n  clearPath();\n  clearScope();\n}\n\nexport function clearPath() {\n  pathsCache = new WeakMap();\n}\n\nexport function clearScope() {\n  scope = new WeakMap();\n}\n\nexport function getCachedPaths(path: NodePath) {\n  const { parent, parentPath } = path;\n  return process.env.BABEL_8_BREAKING && parentPath\n    ? parentPath._store\n    : pathsCache.get(parent);\n}\n\nexport function getOrCreateCachedPaths(node: Node, parentPath?: NodePath) {\n  if (process.env.BABEL_8_BREAKING && parentPath) {\n    return (parentPath._store ||= new Map());\n  }\n\n  let paths = pathsCache.get(node);\n  if (!paths) pathsCache.set(node, (paths = new Map()));\n\n  return paths;\n}\n", "[\n  \"decodeURI\",\n  \"decodeURIComponent\",\n  \"encodeURI\",\n  \"encodeURIComponent\",\n  \"escape\",\n  \"eval\",\n  \"globalThis\",\n  \"isFinite\",\n  \"isNaN\",\n  \"parseFloat\",\n  \"parseInt\",\n  \"undefined\",\n  \"unescape\"\n]\n", "[\n  \"AggregateError\",\n  \"Array\",\n  \"ArrayBuffer\",\n  \"Atomics\",\n  \"BigInt\",\n  \"BigInt64Array\",\n  \"BigUint64Array\",\n  \"Boolean\",\n  \"DataView\",\n  \"Date\",\n  \"Error\",\n  \"EvalError\",\n  \"FinalizationRegistry\",\n  \"Float16Array\",\n  \"Float32Array\",\n  \"Float64Array\",\n  \"Function\",\n  \"Infinity\",\n  \"Int16Array\",\n  \"Int32Array\",\n  \"Int8Array\",\n  \"Intl\",\n  \"Iterator\",\n  \"JSON\",\n  \"Map\",\n  \"Math\",\n  \"NaN\",\n  \"Number\",\n  \"Object\",\n  \"Promise\",\n  \"Proxy\",\n  \"RangeError\",\n  \"ReferenceError\",\n  \"Reflect\",\n  \"RegExp\",\n  \"Set\",\n  \"SharedArrayBuffer\",\n  \"String\",\n  \"Symbol\",\n  \"SyntaxError\",\n  \"TypeError\",\n  \"Uint16Array\",\n  \"Uint32Array\",\n  \"Uint8Array\",\n  \"Uint8ClampedArray\",\n  \"URIError\",\n  \"WeakMap\",\n  \"WeakRef\",\n  \"WeakSet\"\n]\n", "import Renamer from \"./lib/renamer.ts\";\nimport type NodePath from \"../path/index.ts\";\nimport traverse from \"../index.ts\";\nimport Binding from \"./binding.ts\";\nimport type { BindingKind } from \"./binding.ts\";\nimport globalsBuiltinLower from \"@babel/helper-globals/data/builtin-lower.json\" with { type: \"json\" };\nimport globalsBuiltinUpper from \"@babel/helper-globals/data/builtin-upper.json\" with { type: \"json\" };\nimport {\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isCallExpression,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMemberExpression,\n  isMethod,\n  isModuleSpecifier,\n  isNullLiteral,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isRegExpLiteral,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  expressionStatement,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  variableDeclaration,\n  variableDeclarator,\n  isRecordExpression,\n  isTupleExpression,\n  isObjectProperty,\n  isTopicReference,\n  isMetaProperty,\n  isPrivateName,\n  isExportDeclaration,\n  buildUndefinedNode,\n  sequenceExpression,\n} from \"@babel/types\";\nimport * as t from \"@babel/types\";\nimport { scope as scopeCache } from \"../cache.ts\";\nimport type { ExplodedVisitor, Visitor } from \"../types.ts\";\n\ntype NodePart = string | number | bigint | boolean;\n// Recursively gathers the identifying names of a node.\nfunction gatherNodeParts(node: t.Node, parts: NodePart[]) {\n  switch (node?.type) {\n    default:\n      if (isImportDeclaration(node) || isExportDeclaration(node)) {\n        if (\n          (isExportAllDeclaration(node) ||\n            isExportNamedDeclaration(node) ||\n            isImportDeclaration(node)) &&\n          node.source\n        ) {\n          gatherNodeParts(node.source, parts);\n        } else if (\n          (isExportNamedDeclaration(node) || isImportDeclaration(node)) &&\n          node.specifiers?.length\n        ) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if (\n          (isExportDefaultDeclaration(node) ||\n            isExportNamedDeclaration(node)) &&\n          node.declaration\n        ) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        // todo(flow->ts): should condition instead be:\n        //    ```\n        //    t.isExportSpecifier(node) ||\n        //    t.isImportDefaultSpecifier(node) ||\n        //    t.isImportNamespaceSpecifier(node) ||\n        //    t.isImportSpecifier(node)\n        //    ```\n        //    allowing only nodes with `.local`?\n        // @ts-expect-error todo(flow->ts)\n        gatherNodeParts(node.local, parts);\n      } else if (\n        isLiteral(node) &&\n        !isNullLiteral(node) &&\n        !isRegExpLiteral(node) &&\n        !isTemplateLiteral(node)\n      ) {\n        parts.push(node.value);\n      }\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n    case \"ImportExpression\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      gatherNodeParts(node.name, parts);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nfunction resetScope(scope: Scope) {\n  if (!process.env.BABEL_8_BREAKING) {\n    // @ts-expect-error(Babel 7 vs Babel 8)\n    scope.references = Object.create(null);\n    // @ts-expect-error(Babel 7 vs Babel 8)\n    scope.uids = Object.create(null);\n  } else if (scope.path.type === \"Program\") {\n    scope.referencesSet = new Set();\n    scope.uidsSet = new Set();\n  }\n\n  scope.bindings = Object.create(null);\n  scope.globals = Object.create(null);\n}\n\ninterface CollectVisitorState {\n  assignments: NodePath<t.AssignmentExpression>[];\n  references: NodePath<t.Identifier | t.JSXIdentifier>[];\n  constantViolations: NodePath[];\n}\n\nif (!process.env.BABEL_8_BREAKING) {\n  // eslint-disable-next-line no-var\n  var NOT_LOCAL_BINDING = Symbol.for(\n    \"should not be considered a local binding\",\n  );\n}\n\nconst collectorVisitor: Visitor<CollectVisitorState> = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n    // delegate block scope handling to the `BlockScoped` method\n    if (declar.isVar()) {\n      const { scope } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    // delegate block scope handling to the `BlockScoped` method\n    if (path.isBlockScoped()) return;\n\n    // delegate import handing to the `ImportDeclaration` method\n    if (path.isImportDeclaration()) return;\n\n    // this will be hit again once we traverse into it after this iteration\n    if (path.isExportDeclaration()) return;\n\n    // we've ran into a declaration!\n    const parent =\n      path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    // import may only appear in the top level or inside a module/namespace (for TS/flow)\n    const parent = path.scope.getBlockParent();\n\n    parent.registerDeclaration(path);\n  },\n\n  TSImportEqualsDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    if (t.isTSQualifiedName(path.parent) && path.parent.right === path.node) {\n      return;\n    }\n    if (path.parentPath.isTSImportEqualsDeclaration()) return;\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n    // delegate block scope handling to the `BlockScoped` method\n    else if (left.isVar()) {\n      const { scope } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const { node, scope } = path;\n      // ExportAllDeclaration does not have `declaration`\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n\n        const binding = scope.getBinding(id.name);\n        binding?.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding?.reference(path);\n          }\n        }\n      }\n    },\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    // Register class identifier in class' scope if this is a class declaration.\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params: Array<NodePath> = path.get(\"params\");\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    // Register function expression id after params. When the id\n    // collides with a function param, the id effectively can't be\n    // referenced: here we registered it as a constantViolation\n    if (\n      path.isFunctionExpression() &&\n      path.node.id &&\n      (process.env.BABEL_8_BREAKING ||\n        // @ts-expect-error Fixme: document symbol ast properties\n        !path.node.id[NOT_LOCAL_BINDING])\n    ) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (\n      path.node.id &&\n      (process.env.BABEL_8_BREAKING ||\n        // @ts-expect-error Fixme: document symbol ast properties\n        !path.node.id[NOT_LOCAL_BINDING])\n    ) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  TSTypeAnnotation(path) {\n    path.skip();\n  },\n};\n\nlet scopeVisitor: ExplodedVisitor<CollectVisitorState>;\n\nlet uid = 0;\n\nexport type { Binding };\n\nexport { Scope as default };\nclass Scope {\n  uid;\n\n  path: NodePath;\n  block: t.Pattern | t.Scopable;\n\n  inited;\n\n  labels: Map<string, NodePath<t.LabeledStatement>>;\n  bindings: { [name: string]: Binding };\n  /** Only defined in the program scope */\n  referencesSet?: Set<string>;\n  globals: { [name: string]: t.Identifier | t.JSXIdentifier };\n  /** Only defined in the program scope */\n  uidsSet?: Set<string>;\n  data: { [key: string | symbol]: unknown };\n  crawling: boolean;\n\n  /**\n   * This searches the current \"scope\" and collects all references/bindings\n   * within.\n   */\n  constructor(path: NodePath<t.Pattern | t.Scopable>) {\n    const { node } = path;\n    const cached = scopeCache.get(node);\n    // Sometimes, a scopable path is placed higher in the AST tree.\n    // In these cases, have to create a new Scope.\n    if (cached?.path === path) {\n      return cached;\n    }\n    scopeCache.set(node, this);\n\n    this.uid = uid++;\n\n    this.block = node;\n    this.path = path;\n\n    this.labels = new Map();\n    this.inited = false;\n\n    if (!process.env.BABEL_8_BREAKING) {\n      // Shadow the Babel 8 removal getters\n      Object.defineProperties(this, {\n        references: {\n          enumerable: true,\n          configurable: true,\n          writable: true,\n          value: Object.create(null),\n        },\n        uids: {\n          enumerable: true,\n          configurable: true,\n          writable: true,\n          value: Object.create(null),\n        },\n      });\n    }\n  }\n\n  /**\n   * Globals.\n   */\n\n  static globals = [...globalsBuiltinLower, ...globalsBuiltinUpper];\n\n  /**\n   * Variables available in current context.\n   */\n\n  static contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];\n\n  get parent() {\n    let parent,\n      path = this.path;\n    do {\n      // Skip method scope if coming from inside computed key or decorator expression\n      const shouldSkip = path.key === \"key\" || path.listKey === \"decorators\";\n      path = path.parentPath;\n      if (shouldSkip && path.isMethod()) path = path.parentPath;\n      if (path?.isScope()) parent = path;\n    } while (path && !parent);\n\n    return parent?.scope;\n  }\n\n  get references() {\n    throw new Error(\n      \"Scope#references is not available in Babel 8. Use Scope#referencesSet instead.\",\n    );\n  }\n\n  get uids() {\n    throw new Error(\n      \"Scope#uids is not available in Babel 8. Use Scope#uidsSet instead.\",\n    );\n  }\n\n  /**\n   * Generate a unique identifier and add it to the current scope.\n   */\n\n  generateDeclaredUidIdentifier(name?: string) {\n    const id = this.generateUidIdentifier(name);\n    this.push({ id });\n    return cloneNode(id);\n  }\n\n  /**\n   * Generate a unique identifier.\n   */\n\n  generateUidIdentifier(name?: string) {\n    return identifier(this.generateUid(name));\n  }\n\n  /**\n   * Generate a unique `_id1` binding.\n   */\n\n  generateUid(name: string = \"temp\"): string {\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/\\d+$/g, \"\");\n\n    let uid;\n    let i = 0;\n    do {\n      uid = `_${name}`;\n\n      // Ideally we would just use (i - 1) as the suffix, but that generates\n      // unnecessary changes in every single file generated by Babel :)\n      //\n      // i:       0        1  2  3  4  5  6  7  8  9 10 11 12 13 14 ...\n      // suffix:  (empty)  2  3  4  5  6  7  8  9  0  1 10 11 12 13 ...\n      if (i >= 11) uid += i - 1;\n      else if (i >= 9) uid += i - 9;\n      else if (i >= 1) uid += i + 1;\n      i++;\n    } while (\n      this.hasLabel(uid) ||\n      this.hasBinding(uid) ||\n      this.hasGlobal(uid) ||\n      this.hasReference(uid)\n    );\n\n    const program = this.getProgramParent();\n    if (process.env.BABEL_8_BREAKING) {\n      program.referencesSet.add(uid);\n      program.uidsSet.add(uid);\n    } else {\n      // @ts-expect-error Babel 7\n      program.references[uid] = true;\n      // @ts-expect-error Babel 7\n      program.uids[uid] = true;\n    }\n\n    return uid;\n  }\n\n  generateUidBasedOnNode(node: t.Node, defaultName?: string) {\n    const parts: NodePart[] = [];\n    gatherNodeParts(node, parts);\n\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  /**\n   * Generate a unique identifier based on a node.\n   */\n\n  generateUidIdentifierBasedOnNode(node: t.Node, defaultName?: string) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  /**\n   * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.\n   * evaluating it won't result in potentially arbitrary code from being ran. The following are\n   * allowed and determined not to cause side effects:\n   *\n   *  - `this` expressions\n   *  - `super` expressions\n   *  - Bound identifiers\n   */\n\n  isStatic(node: t.Node): boolean {\n    if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Possibly generate a memoised identifier if it is not static and has consequences.\n   */\n\n  maybeGenerateMemoised(node: t.Node, dontPush?: boolean) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n      if (!dontPush) {\n        this.push({ id });\n        return cloneNode(id);\n      }\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(\n    local: Binding,\n    kind: BindingKind,\n    name: string,\n    id: any,\n  ) {\n    // ignore parameters\n    if (kind === \"param\") return;\n\n    // Ignore existing binding if it's the name of the current function or\n    // class expression\n    if (local.kind === \"local\") return;\n\n    const duplicate =\n      // don't allow duplicate bindings to exist alongside\n      kind === \"let\" ||\n      local.kind === \"let\" ||\n      local.kind === \"const\" ||\n      local.kind === \"module\" ||\n      // don't allow a local of param with a kind of let\n      (local.kind === \"param\" && kind === \"const\");\n\n    if (duplicate) {\n      throw this.path.hub.buildError(\n        id,\n        `Duplicate declaration \"${name}\"`,\n        TypeError,\n      );\n    }\n  }\n\n  rename(\n    oldName: string,\n    newName?: string,\n    // prettier-ignore\n    /* Babel 7 - block?: t.Pattern | t.Scopable */\n  ) {\n    const binding = this.getBinding(oldName);\n    if (binding) {\n      newName ||= this.generateUidIdentifier(oldName).name;\n      const renamer = new Renamer(binding, oldName, newName);\n      if (process.env.BABEL_8_BREAKING) {\n        renamer.rename();\n      } else {\n        // @ts-ignore(Babel 7 vs Babel 8) TODO: Delete this\n        renamer.rename(arguments[2]);\n      }\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope: Scope = this;\n    do {\n      console.log(\"#\", scope.block.type);\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind,\n        });\n      }\n    } while ((scope = scope.parent));\n    console.log(sep);\n  }\n\n  hasLabel(name: string) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name: string) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path: NodePath<t.LabeledStatement>) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path: NodePath) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n      const { kind } = path.node;\n      for (const declar of declarations) {\n        this.registerBinding(\n          kind === \"using\" || kind === \"await using\" ? \"const\" : kind,\n          declar,\n        );\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const isTypeDeclaration =\n        path.node.importKind === \"type\" || path.node.importKind === \"typeof\";\n      const specifiers = path.get(\"specifiers\");\n      for (const specifier of specifiers) {\n        const isTypeSpecifier =\n          isTypeDeclaration ||\n          (specifier.isImportSpecifier() &&\n            (specifier.node.importKind === \"type\" ||\n              specifier.node.importKind === \"typeof\"));\n\n        this.registerBinding(isTypeSpecifier ? \"unknown\" : \"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      // todo: improve babel-types\n      const declar = path.get(\"declaration\") as NodePath;\n      if (\n        declar.isClassDeclaration() ||\n        declar.isFunctionDeclaration() ||\n        declar.isVariableDeclaration()\n      ) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return buildUndefinedNode();\n  }\n\n  registerConstantViolation(path: NodePath) {\n    const ids = path.getAssignmentIdentifiers();\n    for (const name of Object.keys(ids)) {\n      this.getBinding(name)?.reassign(path);\n    }\n  }\n\n  registerBinding(\n    kind: Binding[\"kind\"],\n    path: NodePath,\n    bindingPath: NodePath = path,\n  ) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators: Array<NodePath> = path.get(\"declarations\");\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      if (process.env.BABEL_8_BREAKING) {\n        parent.referencesSet.add(name);\n      } else {\n        // @ts-expect-error Babel 7\n        parent.references[name] = true;\n      }\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          // same identifier so continue safely as we're likely trying to register it\n          // multiple times\n          if (local.identifier === id) continue;\n\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        // A redeclaration of an existing variable is a modification\n        if (local) {\n          local.reassign(bindingPath);\n        } else {\n          this.bindings[name] = new Binding({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind,\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node: t.Identifier | t.JSXIdentifier) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name: string): boolean {\n    if (process.env.BABEL_8_BREAKING) {\n      return this.getProgramParent().uidsSet.has(name);\n    } else {\n      let scope: Scope = this;\n\n      do {\n        // @ts-expect-error Babel 7\n        if (scope.uids[name]) return true;\n      } while ((scope = scope.parent));\n\n      return false;\n    }\n  }\n\n  hasGlobal(name: string): boolean {\n    let scope: Scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while ((scope = scope.parent));\n\n    return false;\n  }\n\n  hasReference(name: string): boolean {\n    if (process.env.BABEL_8_BREAKING) {\n      return this.getProgramParent().referencesSet.has(name);\n    } else {\n      // @ts-expect-error Babel 7\n      return !!this.getProgramParent().references[name];\n    }\n  }\n\n  isPure(node: t.Node, constantsOnly?: boolean): boolean {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (\n      isThisExpression(node) ||\n      isMetaProperty(node) ||\n      isTopicReference(node) ||\n      isPrivateName(node)\n    ) {\n      return true;\n    } else if (isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isBinary(node)) {\n      return (\n        this.isPure(node.left, constantsOnly) &&\n        this.isPure(node.right, constantsOnly)\n      );\n    } else if (isArrayExpression(node) || isTupleExpression(node)) {\n      for (const elem of node.elements) {\n        if (elem !== null && !this.isPure(elem, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isObjectExpression(node) || isRecordExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      return true;\n    } else if (isProperty(node)) {\n      // @ts-expect-error todo(flow->ts): computed in not present on private properties\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      if (isObjectProperty(node) || node.static) {\n        if (node.value !== null && !this.isPure(node.value, constantsOnly)) {\n          return false;\n        }\n      }\n      return true;\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isTaggedTemplateExpression(node)) {\n      return (\n        matchesPattern(node.tag, \"String.raw\") &&\n        !this.hasBinding(\"String\", { noGlobals: true }) &&\n        this.isPure(node.quasi, constantsOnly)\n      );\n    } else if (isMemberExpression(node)) {\n      return (\n        !node.computed &&\n        isIdentifier(node.object) &&\n        node.object.name === \"Symbol\" &&\n        isIdentifier(node.property) &&\n        node.property.name !== \"for\" &&\n        !this.hasBinding(\"Symbol\", { noGlobals: true })\n      );\n    } else if (isCallExpression(node)) {\n      return (\n        matchesPattern(node.callee, \"Symbol.for\") &&\n        !this.hasBinding(\"Symbol\", { noGlobals: true }) &&\n        node.arguments.length === 1 &&\n        t.isStringLiteral(node.arguments[0])\n      );\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  /**\n   * Set some arbitrary data on the current scope.\n   */\n\n  setData(key: string | symbol, val: any) {\n    return (this.data[key] = val);\n  }\n\n  /**\n   * Recursively walk up scope tree looking for the data `key`.\n   */\n\n  getData(key: string | symbol): any {\n    let scope: Scope = this;\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while ((scope = scope.parent));\n  }\n\n  /**\n   * Recursively walk up scope tree looking for the data `key` and if it exists,\n   * remove it.\n   */\n\n  removeData(key: string) {\n    let scope: Scope = this;\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while ((scope = scope.parent));\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n\n    resetScope(this);\n    this.data = Object.create(null);\n\n    let scope: Scope = this;\n    do {\n      if (scope.crawling) return;\n      if (scope.path.isProgram()) {\n        break;\n      }\n    } while ((scope = scope.parent));\n\n    const programParent = scope;\n\n    const state: CollectVisitorState = {\n      references: [],\n      constantViolations: [],\n      assignments: [],\n    };\n\n    this.crawling = true;\n    scopeVisitor ||= traverse.visitors.merge([\n      {\n        Scope(path) {\n          resetScope(path.scope);\n        },\n      },\n      collectorVisitor,\n    ]);\n    // traverse does not visit the root node, here we explicitly collect\n    // root node binding info when the root is not a Program.\n    if (path.type !== \"Program\") {\n      for (const visit of scopeVisitor.enter) {\n        visit.call(state, path, state);\n      }\n      const typeVisitors = scopeVisitor[path.type];\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit.call(state, path, state);\n        }\n      }\n    }\n    path.traverse(scopeVisitor, state);\n    this.crawling = false;\n\n    // register assignments\n    for (const path of state.assignments) {\n      // register undeclared bindings as globals\n      const ids = path.getAssignmentIdentifiers();\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      // register as constant violation\n      path.scope.registerConstantViolation(path);\n    }\n\n    // register references\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    // register constant violations\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts: {\n    id: t.ArrayPattern | t.Identifier | t.ObjectPattern;\n    init?: t.Expression;\n    unique?: boolean;\n    _blockHoist?: number | undefined;\n    kind?: \"var\" | \"let\" | \"const\";\n  }) {\n    let path = this.path;\n\n    if (path.isPattern()) {\n      path = this.getPatternParent().path;\n    } else if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    const { init, unique, kind = \"var\", id } = opts;\n\n    // When injecting a non-const non-initialized binding inside\n    // an IIFE, if the number of call arguments is less than or\n    // equal to the number of function parameters, we can safely\n    // inject the binding into the parameter list.\n    if (\n      !init &&\n      !unique &&\n      (kind === \"var\" || kind === \"let\") &&\n      path.isFunction() &&\n      // @ts-expect-error ArrowFunctionExpression never has a name\n      !path.node.name &&\n      isCallExpression(path.parent, { callee: path.node }) &&\n      path.parent.arguments.length <= path.node.params.length &&\n      isIdentifier(id)\n    ) {\n      path.pushContainer(\"params\", id);\n      path.scope.registerBinding(\n        \"param\",\n        path.get(\"params\")[path.node.params.length - 1],\n      );\n      return;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      // @ts-expect-error todo(flow->ts): avoid modifying nodes\n      declar._blockHoist = blockHoist;\n\n      [declarPath] = (path as NodePath<t.BlockStatement>).unshiftContainer(\n        \"body\",\n        [declar],\n      );\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(id, init);\n    const len = declarPath.node.declarations.push(declarator);\n    path.scope.registerBinding(kind, declarPath.get(\"declarations\")[len - 1]);\n  }\n\n  /**\n   * Walk up to the top of the scope tree and get the `Program`.\n   */\n\n  getProgramParent(): Scope & {\n    referencesSet: Set<string>;\n    uidsSet: Set<string>;\n  } {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isProgram()) {\n        return scope as Scope & {\n          referencesSet: Set<string>;\n          uidsSet: Set<string>;\n        };\n      }\n    } while ((scope = scope.parent));\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  /**\n   * Walk up the scope tree until we hit either a Function or return null.\n   */\n\n  getFunctionParent(): Scope | null {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while ((scope = scope.parent));\n    return null;\n  }\n\n  /**\n   * Walk up the scope tree until we hit either a BlockStatement/Loop/Program/Function/Switch or reach the\n   * very top and hit Program.\n   */\n\n  getBlockParent() {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while ((scope = scope.parent));\n    throw new Error(\n      \"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\",\n    );\n  }\n\n  /**\n   * Walk up from a pattern scope (function param initializer) until we hit a non-pattern scope,\n   * then returns its block parent\n   * @returns An ancestry scope whose path is a block parent\n   */\n  getPatternParent() {\n    let scope: Scope = this;\n    do {\n      if (!scope.path.isPattern()) {\n        return scope.getBlockParent();\n      }\n    } while ((scope = scope.parent.parent));\n    throw new Error(\n      \"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\",\n    );\n  }\n\n  /**\n   * Walks the scope tree and gathers **all** bindings.\n   */\n\n  getAllBindings(): Record<string, Binding> {\n    const ids = Object.create(null);\n\n    let scope: Scope = this;\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name: string, node: t.Node): boolean {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name: string): Binding | undefined {\n    let scope: Scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n      if (binding) {\n        // Check if a pattern is a part of parameter expressions.\n        // Note: for performance reason we skip checking previousPath.parentPath.isFunction()\n        // because `scope.path` is validated as scope in packages/babel-types/src/validators/isScope.js\n        // That is, if a scope path is pattern, its parent must be Function/CatchClause\n\n        // Spec 9.2.10.28: The closure created by this expression should not have visibility of\n        // declarations in the function body. If the binding is not a `param`-kind (as function parameters)\n        // or `local`-kind (as id in function expression),\n        // then it must be defined inside the function body, thus it should be skipped\n        if (\n          previousPath?.isPattern() &&\n          binding.kind !== \"param\" &&\n          binding.kind !== \"local\"\n        ) {\n          // do nothing\n        } else {\n          return binding;\n        }\n      } else if (\n        !binding &&\n        name === \"arguments\" &&\n        scope.path.isFunction() &&\n        !scope.path.isArrowFunctionExpression()\n      ) {\n        break;\n      }\n      previousPath = scope.path;\n    } while ((scope = scope.parent));\n  }\n\n  getOwnBinding(name: string): Binding | undefined {\n    return this.bindings[name];\n  }\n\n  // todo: return probably can be undefined…\n  getBindingIdentifier(name: string): t.Identifier {\n    return this.getBinding(name)?.identifier;\n  }\n\n  // todo: flow->ts return probably can be undefined\n  getOwnBindingIdentifier(name: string): t.Identifier {\n    const binding = this.bindings[name];\n    return binding?.identifier;\n  }\n\n  hasOwnBinding(name: string) {\n    return !!this.getOwnBinding(name);\n  }\n\n  // By default, we consider generated UIDs as bindings.\n  // This is because they are almost always used to declare variables,\n  // and since the scope isn't always up-to-date it's better to assume that\n  // there is a variable with that name. The `noUids` option can be used to\n  // turn off this behavior, for example if you know that the generate UID\n  // was used to declare a variable in a different scope.\n  hasBinding(\n    name: string,\n    opts?:\n      | boolean\n      | { noGlobals?: boolean; noUids?: boolean; upToScope?: Scope },\n  ) {\n    if (!name) return false;\n    // TODO: Only accept the object form.\n    let noGlobals;\n    let noUids;\n    let upToScope;\n    if (typeof opts === \"object\") {\n      noGlobals = opts.noGlobals;\n      noUids = opts.noUids;\n      upToScope = opts.upToScope;\n    } else if (typeof opts === \"boolean\") {\n      noGlobals = opts;\n    }\n    let scope: Scope = this;\n    do {\n      if (upToScope === scope) {\n        break;\n      }\n      if (scope.hasOwnBinding(name)) {\n        return true;\n      }\n    } while ((scope = scope.parent));\n\n    if (!noUids && this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(\n    name: string,\n    opts?: { noGlobals?: boolean; noUids?: boolean },\n  ) {\n    return this.parent?.hasBinding(name, opts);\n  }\n\n  /**\n   * Move a binding of `name` to another `scope`.\n   */\n\n  moveBindingTo(name: string, scope: Scope) {\n    const info = this.getBinding(name);\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name: string) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name: string) {\n    // clear literal binding\n    this.getBinding(name)?.scope.removeOwnBinding(name);\n\n    // clear uids with this name - https://github.com/babel/babel/issues/2101\n    if (process.env.BABEL_8_BREAKING) {\n      this.getProgramParent().uidsSet.delete(name);\n    } else {\n      let scope: Scope = this;\n      do {\n        // @ts-expect-error Babel 7\n        if (scope.uids[name]) {\n          // @ts-expect-error Babel 7\n          scope.uids[name] = false;\n        }\n      } while ((scope = scope.parent));\n    }\n  }\n\n  /**\n   * Hoist all the `var` variable to the beginning of the function/program\n   * scope where their binding will be actually defined. For exmaple,\n   *     { var x = 2 }\n   * will be transformed to\n   *     var x; { x = 2 }\n   *\n   * @param emit A custom function to emit `var` declarations, for example to\n   *   emit them in a different scope.\n   */\n  hoistVariables(\n    emit: (id: t.Identifier, hasInit: boolean) => void = id =>\n      this.push({ id }),\n  ) {\n    this.crawl();\n\n    const seen = new Set();\n    for (const name of Object.keys(this.bindings)) {\n      const binding = this.bindings[name];\n      if (!binding) continue;\n      const { path } = binding;\n      if (!path.isVariableDeclarator()) continue;\n      const { parent, parentPath } = path;\n\n      if (parent.kind !== \"var\" || seen.has(parent)) continue;\n      seen.add(path.parent);\n\n      let firstId;\n      const init = [];\n      for (const decl of parent.declarations) {\n        firstId ??= decl.id;\n        if (decl.init) {\n          init.push(\n            assignmentExpression(\n              \"=\",\n              // var declarator must not be a void pattern\n              decl.id as Exclude<t.VariableDeclarator[\"id\"], t.VoidPattern>,\n              decl.init,\n            ),\n          );\n        }\n\n        const ids = Object.keys(getBindingIdentifiers(decl, false, true, true));\n        for (const name of ids) {\n          emit(identifier(name), decl.init != null);\n        }\n      }\n\n      // for (var i in test)\n      if (parentPath.parentPath.isFor({ left: parent })) {\n        parentPath.replaceWith(firstId);\n      } else if (init.length === 0) {\n        parentPath.remove();\n      } else {\n        const expr = init.length === 1 ? init[0] : sequenceExpression(init);\n        if (parentPath.parentPath.isForStatement({ init: parent })) {\n          parentPath.replaceWith(expr);\n        } else {\n          parentPath.replaceWith(expressionStatement(expr));\n        }\n      }\n    }\n  }\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /** @deprecated Not used in our codebase */\n  // @ts-expect-error Babel 7 compatibility\n  Scope.prototype._renameFromMap = function _renameFromMap(\n    map: Record<string | symbol, unknown>,\n    oldName: string | symbol,\n    newName: string | symbol,\n    value: unknown,\n  ) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  };\n\n  /**\n   * Traverse node with current scope and path.\n   *\n   * !!! WARNING !!!\n   * This method assumes that `this.path` is the NodePath representing `node`.\n   * After running the traversal, the `.parentPath` of the NodePaths\n   * corresponding to `node`'s children will be set to `this.path`.\n   *\n   * There is no good reason to use this method, since the only safe way to use\n   * it is equivalent to `scope.path.traverse(opts, state)`.\n   */\n  // @ts-expect-error Babel 7 compatibility\n  Scope.prototype.traverse = function <S>(\n    this: Scope,\n    node: any,\n    opts: any,\n    state?: S,\n  ) {\n    traverse(node, opts, this, state, this.path);\n  };\n\n  /**\n   * Generate an `_id1`.\n   */\n  // @ts-expect-error Babel 7 compatibility\n  Scope.prototype._generateUid = function _generateUid(\n    name: string,\n    i: number,\n  ) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  };\n\n  // TODO: (Babel 8) Split i in two parameters, and use an object of flags\n  // @ts-expect-error Babel 7 compatibility\n  Scope.prototype.toArray = function toArray(\n    this: Scope,\n    node: t.Node,\n    i?: number | boolean,\n    arrayLikeIsIterable?: boolean | void,\n  ) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (binding?.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, { name: \"arguments\" })) {\n      return callExpression(\n        memberExpression(\n          memberExpression(\n            memberExpression(identifier(\"Array\"), identifier(\"prototype\")),\n            identifier(\"slice\"),\n          ),\n          identifier(\"call\"),\n        ),\n        [node],\n      );\n    }\n\n    let helperName;\n    const args = [node];\n    if (i === true) {\n      // Used in array-spread to create an array.\n      helperName = \"toConsumableArray\";\n    } else if (typeof i === \"number\") {\n      args.push(numericLiteral(i));\n\n      // Used in array-rest to create an array from a subset of an iterable.\n      helperName = \"slicedToArray\";\n      // TODO if (this.hub.isLoose(\"es6.forOf\")) helperName += \"-loose\";\n    } else {\n      // Used in array-rest to create an array\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.path.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    // @ts-expect-error todo(flow->ts): t.Node is not valid to use in args, function argument typeneeds to be clarified\n    return callExpression(this.path.hub.addHelper(helperName), args);\n  };\n\n  /**\n   * Walks the scope tree and gathers all declarations of `kind`.\n   */\n  // @ts-expect-error Babel 7 compatibility\n  Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind(\n    ...kinds: string[]\n  ): Record<string, Binding> {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope: Scope = this;\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  };\n\n  Object.defineProperties(Scope.prototype, {\n    parentBlock: {\n      configurable: true,\n      enumerable: true,\n      get(this: Scope) {\n        return this.path.parent;\n      },\n    },\n    hub: {\n      configurable: true,\n      enumerable: true,\n      get(this: Scope) {\n        return this.path.hub;\n      },\n    },\n  });\n}\n\ntype _Binding = Binding;\n// eslint-disable-next-line @typescript-eslint/no-namespace\nnamespace Scope {\n  export type Binding = _Binding;\n}\n", "import { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\nimport { StringWriter, StringReader } from './strings';\n\nexport {\n  decodeOriginalScopes,\n  encodeOriginalScopes,\n  decodeGeneratedRanges,\n  encodeGeneratedRanges,\n} from './scopes';\nexport type { OriginalScope, GeneratedRange, CallSite, BindingExpressionRange } from './scopes';\n\nexport type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nexport function decode(mappings: string): SourceMapMappings {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded: SourceMapMappings = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n\n    while (reader.pos < semi) {\n      let seg: SourceMapSegment;\n\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n\n      line.push(seg);\n      reader.pos++;\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n\n  return decoded;\n}\n\nfunction sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}\n\nexport function encode(decoded: SourceMapMappings): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n\n    let genColumn = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n\n  return writer.flush();\n}\n", "import type { StringReader, StringWriter } from './strings';\n\nexport const comma = ','.charCodeAt(0);\nexport const semicolon = ';'.charCodeAt(0);\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\n\nexport function decodeInteger(reader: StringReader, relative: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  return relative + value;\n}\n\nexport function encodeInteger(builder: StringWriter, num: number, relative: number): number {\n  let delta = num - relative;\n\n  delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\n  do {\n    let clamped = delta & 0b011111;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 0b100000;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n\n  return num;\n}\n\nexport function hasMoreVlq(reader: StringReader, max: number) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n", "const bufLength = 1024 * 16;\n\n// Provide a fallback for older environments.\nconst td =\n  typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n      ? {\n          decode(buf: Uint8Array): string {\n            const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n            return out.toString();\n          },\n        }\n      : {\n          decode(buf: Uint8Array): string {\n            let out = '';\n            for (let i = 0; i < buf.length; i++) {\n              out += String.fromCharCode(buf[i]);\n            }\n            return out;\n          },\n        };\n\nexport class StringWriter {\n  pos = 0;\n  private out = '';\n  private buffer = new Uint8Array(bufLength);\n\n  write(v: number): void {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n\n  flush(): string {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n}\n\nexport class StringReader {\n  pos = 0;\n  declare private buffer: string;\n\n  constructor(buffer: string) {\n    this.buffer = buffer;\n  }\n\n  next(): number {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n\n  peek(): number {\n    return this.buffer.charCodeAt(this.pos);\n  }\n\n  indexOf(char: string): number {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n}\n", "import { StringReader, StringWriter } from './strings';\nimport { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\n\nconst EMPTY: any[] = [];\n\ntype Line = number;\ntype Column = number;\ntype Kind = number;\ntype Name = number;\ntype Var = number;\ntype SourcesIndex = number;\ntype ScopesIndex = number;\n\ntype Mix<A, B, O> = (A & O) | (B & O);\n\nexport type OriginalScope = Mix<\n  [Line, Column, Line, Column, Kind],\n  [Line, Column, Line, Column, Kind, Name],\n  { vars: Var[] }\n>;\n\nexport type GeneratedRange = Mix<\n  [Line, Column, Line, Column],\n  [Line, Column, Line, Column, SourcesIndex, ScopesIndex],\n  {\n    callsite: CallSite | null;\n    bindings: Binding[];\n    isScope: boolean;\n  }\n>;\nexport type CallSite = [SourcesIndex, Line, Column];\ntype Binding = BindingExpressionRange[];\nexport type BindingExpressionRange = [Name] | [Name, Line, Column];\n\nexport function decodeOriginalScopes(input: string): OriginalScope[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes: OriginalScope[] = [];\n  const stack: OriginalScope[] = [];\n  let line = 0;\n\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop()!;\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 0b0001;\n\n    const scope: OriginalScope = (\n      hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]\n    ) as OriginalScope;\n\n    let vars: Var[] = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n\n    scopes.push(scope);\n    stack.push(scope);\n  }\n\n  return scopes;\n}\n\nexport function encodeOriginalScopes(scopes: OriginalScope[]): string {\n  const writer = new StringWriter();\n\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeOriginalScopes(\n  scopes: OriginalScope[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenColumn\n  ],\n): number {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n\n  if (index > 0) writer.write(comma);\n\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n\n  const fields = scope.length === 6 ? 0b0001 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n\n  return index;\n}\n\nexport function decodeGeneratedRanges(input: string): GeneratedRange[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges: GeneratedRange[] = [];\n  const stack: GeneratedRange[] = [];\n\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    let genColumn = 0;\n\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop()!;\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 0b0001;\n      const hasCallsite = fields & 0b0010;\n      const hasScope = fields & 0b0100;\n\n      let callsite: CallSite | null = null;\n      let bindings: Binding[] = EMPTY;\n      let range: GeneratedRange;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0,\n        );\n\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex] as GeneratedRange;\n      } else {\n        range = [genLine, genColumn, 0, 0] as GeneratedRange;\n      }\n\n      range.isScope = !!hasScope;\n\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0,\n        );\n\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges: BindingExpressionRange[];\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n\n      ranges.push(range);\n      stack.push(range);\n    }\n\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n\n  return ranges;\n}\n\nexport function encodeGeneratedRanges(ranges: GeneratedRange[]): string {\n  if (ranges.length === 0) return '';\n\n  const writer = new StringWriter();\n\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeGeneratedRanges(\n  ranges: GeneratedRange[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenLine\n    number, // GenColumn\n    number, // DefSourcesIndex\n    number, // DefScopesIndex\n    number, // CallSourcesIndex\n    number, // CallLine\n    number, // CallColumn\n  ],\n): number {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings,\n  } = range;\n\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n\n  state[1] = encodeInteger(writer, range[1], state[1]);\n\n  const fields =\n    (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\n  encodeInteger(writer, fields, 0);\n\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite!;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1]!, bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2]!, bindingStartColumn);\n        encodeInteger(writer, expRange[0]!, 0);\n      }\n    }\n  }\n\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n\n  return index;\n}\n\nfunction catchupLine(writer: StringWriter, lastLine: number, line: number) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}\n", "// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  query: string;\n  hash: string;\n  type: UrlType;\n};\n\nconst enum UrlType {\n  Empty = 1,\n  Hash = 2,\n  Query = 3,\n  RelativePath = 4,\n  AbsolutePath = 5,\n  SchemeRelative = 6,\n  Absolute = 7,\n}\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input: string): boolean {\n  return input.startsWith('file:');\n}\n\nfunction isRelative(input: string): boolean {\n  return /^[.?#]/.test(input);\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return makeUrl(\n    match[1],\n    match[2] || '',\n    match[3],\n    match[4] || '',\n    match[5] || '/',\n    match[6] || '',\n    match[7] || '',\n  );\n}\n\nfunction parseFileUrl(input: string): Url {\n  const match = fileRegex.exec(input)!;\n  const path = match[2];\n  return makeUrl(\n    'file:',\n    '',\n    match[1] || '',\n    '',\n    isAbsolutePath(path) ? path : '/' + path,\n    match[3] || '',\n    match[4] || '',\n  );\n}\n\nfunction makeUrl(\n  scheme: string,\n  user: string,\n  host: string,\n  port: string,\n  path: string,\n  query: string,\n  hash: string,\n): Url {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input\n    ? input.startsWith('?')\n      ? UrlType.Query\n      : input.startsWith('#')\n      ? UrlType.Hash\n      : UrlType.RelativePath\n    : UrlType.Empty;\n  return url;\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  normalizePath(base, base.type);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url, type: UrlType) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n  let inputType = url.type;\n\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n\n  normalizePath(url, inputType);\n\n  const queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n\n    case UrlType.RelativePath: {\n      // The first char is always a \"/\", and we need it to be relative.\n      const path = url.path.slice(1);\n\n      if (!path) return queryHash || '.';\n\n      if (isRelative(base || input) && !isRelative(path)) {\n        // If base started with a leading \".\", or there is no base and input started with a \".\",\n        // then we need to ensure that the relative path starts with a \".\". We don't know if\n        // relative starts with a \"..\", though, so check before prepending.\n        return './' + path + queryHash;\n      }\n\n      return path + queryHash;\n    }\n\n    case UrlType.AbsolutePath:\n      return url.path + queryHash;\n\n    default:\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n  }\n}\n", null, null, "import { encode, decode } from '@jridgewell/sourcemap-codec';\n\nimport resolver from './resolve';\nimport maybeSort from './sort';\nimport buildBySources from './by-source';\nimport {\n  memoizedState,\n  memoizedBinarySearch,\n  upperBound,\n  lowerBound,\n  found as bsFound,\n} from './binary-search';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n  REV_GENERATED_LINE,\n  REV_GENERATED_COLUMN,\n} from './sourcemap-segment';\nimport { parse } from './types';\n\nimport type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport type {\n  SourceMapV3,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  InvalidOriginalMapping,\n  OriginalMapping,\n  InvalidGeneratedMapping,\n  GeneratedMapping,\n  SourceMapInput,\n  Needle,\n  SourceNeedle,\n  SourceMap,\n  EachMapping,\n  Bias,\n  XInput,\n  SectionedSourceMap,\n  Ro,\n} from './types';\nimport type { Source } from './by-source';\nimport type { MemoState } from './binary-search';\n\nexport type { SourceMapSegment } from './sourcemap-segment';\nexport type {\n  SourceMap,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  Section,\n  SectionedSourceMap,\n  SourceMapV3,\n  Bias,\n  EachMapping,\n  GeneratedMapping,\n  InvalidGeneratedMapping,\n  InvalidOriginalMapping,\n  Needle,\n  OriginalMapping,\n  OriginalMapping as Mapping,\n  SectionedSourceMapInput,\n  SourceMapInput,\n  SourceNeedle,\n  XInput,\n  EncodedSourceMapXInput,\n  DecodedSourceMapXInput,\n  SectionedSourceMapXInput,\n  SectionXInput,\n} from './types';\n\ninterface PublicMap {\n  _encoded: TraceMap['_encoded'];\n  _decoded: TraceMap['_decoded'];\n  _decodedMemo: TraceMap['_decodedMemo'];\n  _bySources: TraceMap['_bySources'];\n  _bySourceMemos: TraceMap['_bySourceMemos'];\n}\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n\nexport const LEAST_UPPER_BOUND = -1;\nexport const GREATEST_LOWER_BOUND = 1;\n\nexport { FlattenMap, FlattenMap as AnyMap } from './flatten-map';\n\nexport class TraceMap implements SourceMap {\n  declare version: SourceMapV3['version'];\n  declare file: SourceMapV3['file'];\n  declare names: SourceMapV3['names'];\n  declare sourceRoot: SourceMapV3['sourceRoot'];\n  declare sources: SourceMapV3['sources'];\n  declare sourcesContent: SourceMapV3['sourcesContent'];\n  declare ignoreList: SourceMapV3['ignoreList'];\n\n  declare resolvedSources: string[];\n  declare private _encoded: string | undefined;\n\n  declare private _decoded: SourceMapSegment[][] | undefined;\n  declare private _decodedMemo: MemoState;\n\n  declare private _bySources: Source[] | undefined;\n  declare private _bySourceMemos: MemoState[] | undefined;\n\n  constructor(map: Ro<SourceMapInput>, mapUrl?: string | null) {\n    const isString = typeof map === 'string';\n    if (!isString && (map as unknown as { _decodedMemo: any })._decodedMemo) return map as TraceMap;\n\n    const parsed = parse(map as Exclude<SourceMapInput, TraceMap>);\n\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names || [];\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    this.ignoreList = parsed.ignoreList || (parsed as XInput).x_google_ignoreList || undefined;\n\n    const resolve = resolver(mapUrl, sourceRoot);\n    this.resolvedSources = sources.map(resolve);\n\n    const { mappings } = parsed;\n    if (typeof mappings === 'string') {\n      this._encoded = mappings;\n      this._decoded = undefined;\n    } else if (Array.isArray(mappings)) {\n      this._encoded = undefined;\n      this._decoded = maybeSort(mappings, isString);\n    } else if ((parsed as unknown as SectionedSourceMap).sections) {\n      throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);\n    } else {\n      throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);\n    }\n\n    this._decodedMemo = memoizedState();\n    this._bySources = undefined;\n    this._bySourceMemos = undefined;\n  }\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map: unknown): PublicMap {\n  return map as any;\n}\n\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nexport function encodedMappings(map: TraceMap): EncodedSourceMap['mappings'] {\n  return (cast(map)._encoded ??= encode(cast(map)._decoded!));\n}\n\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nexport function decodedMappings(map: TraceMap): Readonly<DecodedSourceMap['mappings']> {\n  return (cast(map)._decoded ||= decode(cast(map)._encoded!));\n}\n\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nexport function traceSegment(\n  map: TraceMap,\n  line: number,\n  column: number,\n): Readonly<SourceMapSegment> | null {\n  const decoded = decodedMappings(map);\n\n  // It's common for parent source maps to have pointers to lines that have no\n  // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n  if (line >= decoded.length) return null;\n\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    GREATEST_LOWER_BOUND,\n  );\n\n  return index === -1 ? null : segments[index];\n}\n\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nexport function originalPositionFor(\n  map: TraceMap,\n  needle: Needle,\n): OriginalMapping | InvalidOriginalMapping {\n  let { line, column, bias } = needle;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n  const decoded = decodedMappings(map);\n\n  // It's common for parent source maps to have pointers to lines that have no\n  // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n  if (line >= decoded.length) return OMapping(null, null, null, null);\n\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    bias || GREATEST_LOWER_BOUND,\n  );\n\n  if (index === -1) return OMapping(null, null, null, null);\n\n  const segment = segments[index];\n  if (segment.length === 1) return OMapping(null, null, null, null);\n\n  const { names, resolvedSources } = map;\n  return OMapping(\n    resolvedSources[segment[SOURCES_INDEX]],\n    segment[SOURCE_LINE] + 1,\n    segment[SOURCE_COLUMN],\n    segment.length === 5 ? names[segment[NAMES_INDEX]] : null,\n  );\n}\n\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nexport function generatedPositionFor(\n  map: TraceMap,\n  needle: SourceNeedle,\n): GeneratedMapping | InvalidGeneratedMapping {\n  const { source, line, column, bias } = needle;\n  return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n}\n\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nexport function allGeneratedPositionsFor(map: TraceMap, needle: SourceNeedle): GeneratedMapping[] {\n  const { source, line, column, bias } = needle;\n  // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n  return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n}\n\n/**\n * Iterates each mapping in generated position order.\n */\nexport function eachMapping(map: TraceMap, cb: (mapping: EachMapping) => void): void {\n  const decoded = decodedMappings(map);\n  const { names, resolvedSources } = map;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n\n      const generatedLine = i + 1;\n      const generatedColumn = seg[0];\n      let source = null;\n      let originalLine = null;\n      let originalColumn = null;\n      let name = null;\n      if (seg.length !== 1) {\n        source = resolvedSources[seg[1]];\n        originalLine = seg[2] + 1;\n        originalColumn = seg[3];\n      }\n      if (seg.length === 5) name = names[seg[4]];\n\n      cb({\n        generatedLine,\n        generatedColumn,\n        source,\n        originalLine,\n        originalColumn,\n        name,\n      } as EachMapping);\n    }\n  }\n}\n\nfunction sourceIndex(map: TraceMap, source: string): number {\n  const { sources, resolvedSources } = map;\n  let index = sources.indexOf(source);\n  if (index === -1) index = resolvedSources.indexOf(source);\n  return index;\n}\n\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nexport function sourceContentFor(map: TraceMap, source: string): string | null {\n  const { sourcesContent } = map;\n  if (sourcesContent == null) return null;\n  const index = sourceIndex(map, source);\n  return index === -1 ? null : sourcesContent[index];\n}\n\n/**\n * Determines if the source is marked to ignore by the source map.\n */\nexport function isIgnored(map: TraceMap, source: string): boolean {\n  const { ignoreList } = map;\n  if (ignoreList == null) return false;\n  const index = sourceIndex(map, source);\n  return index === -1 ? false : ignoreList.includes(index);\n}\n\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nexport function presortedDecodedMap(map: DecodedSourceMap, mapUrl?: string): TraceMap {\n  const tracer = new TraceMap(clone(map, []), mapUrl);\n  cast(tracer)._decoded = map.mappings;\n  return tracer;\n}\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function decodedMap(\n  map: TraceMap,\n): Omit<DecodedSourceMap, 'mappings'> & { mappings: readonly SourceMapSegment[][] } {\n  return clone(map, decodedMappings(map));\n}\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function encodedMap(map: TraceMap): EncodedSourceMap {\n  return clone(map, encodedMappings(map));\n}\n\nfunction clone<T extends string | readonly SourceMapSegment[][]>(\n  map: TraceMap | DecodedSourceMap,\n  mappings: T,\n): T extends string ? EncodedSourceMap : DecodedSourceMap {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n    ignoreList: map.ignoreList || (map as XInput).x_google_ignoreList,\n  } as any;\n}\n\nfunction OMapping(source: null, line: null, column: null, name: null): InvalidOriginalMapping;\nfunction OMapping(\n  source: string,\n  line: number,\n  column: number,\n  name: string | null,\n): OriginalMapping;\nfunction OMapping(\n  source: string | null,\n  line: number | null,\n  column: number | null,\n  name: string | null,\n): OriginalMapping | InvalidOriginalMapping {\n  return { source, line, column, name } as any;\n}\n\nfunction GMapping(line: null, column: null): InvalidGeneratedMapping;\nfunction GMapping(line: number, column: number): GeneratedMapping;\nfunction GMapping(\n  line: number | null,\n  column: number | null,\n): GeneratedMapping | InvalidGeneratedMapping {\n  return { line, column } as any;\n}\n\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[] | ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (bsFound) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\n\nfunction sliceGeneratedPositions(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): GeneratedMapping[] {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n\n  // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n  // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n  // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n  // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n  // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n  // match LEAST_UPPER_BOUND.\n  if (!bsFound && bias === LEAST_UPPER_BOUND) min++;\n\n  if (min === -1 || min === segments.length) return [];\n\n  // We may have found the segment that started at an earlier column. If this is the case, then we\n  // need to slice all generated segments that match _that_ column, because all such segments span\n  // to our desired column.\n  const matchedColumn = bsFound ? column : segments[min][COLUMN];\n\n  // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n  if (!bsFound) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\n\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: false,\n): GeneratedMapping | InvalidGeneratedMapping;\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: true,\n): GeneratedMapping[];\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: boolean,\n): GeneratedMapping | InvalidGeneratedMapping | GeneratedMapping[] {\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n  const { sources, resolvedSources } = map;\n  let sourceIndex = sources.indexOf(source);\n  if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n  if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n\n  const generated = (cast(map)._bySources ||= buildBySources(\n    decodedMappings(map),\n    (cast(map)._bySourceMemos = sources.map(memoizedState)),\n  ));\n\n  const segments = generated[sourceIndex][line];\n  if (segments == null) return all ? [] : GMapping(null, null);\n\n  const memo = cast(map)._bySourceMemos![sourceIndex];\n\n  if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n\n  const index = traceSegmentInternal(segments, memo, line, column, bias);\n  if (index === -1) return GMapping(null, null);\n\n  const segment = segments[index];\n  return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n}\n", "import resolveUri from '@jridgewell/resolve-uri';\nimport stripFilename from './strip-filename';\n\ntype Resolve = (source: string | null) => string;\nexport default function resolver(\n  mapUrl: string | null | undefined,\n  sourceRoot: string | undefined,\n): Resolve {\n  const from = stripFilename(mapUrl);\n  // The sourceRoot is always treated as a directory, if it's not empty.\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n  const prefix = sourceRoot ? sourceRoot + '/' : '';\n\n  return (source) => resolveUri(prefix + (source || ''), from);\n}\n", "/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nexport default function stripFilename(path: string | undefined | null): string {\n  if (!path) return '';\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n", "type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\ntype GeneratedLine = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n\nexport const REV_GENERATED_LINE = 1;\nexport const REV_GENERATED_COLUMN = 2;\n", "import { COLUMN } from './sourcemap-segment';\n\nimport type { SourceMapSegment } from './sourcemap-segment';\n\nexport default function maybeSort(\n  mappings: SourceMapSegment[][],\n  owned: boolean,\n): SourceMapSegment[][] {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n  // not, we do not want to modify the consumer's input array.\n  if (!owned) mappings = mappings.slice();\n\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\n\nfunction nextUnsortedSegmentLine(mappings: SourceMapSegment[][], start: number): number {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\n\nfunction isSorted(line: SourceMapSegment[]): boolean {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction sortSegments(line: SourceMapSegment[], owned: boolean): SourceMapSegment[] {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[COLUMN] - b[COLUMN];\n}\n", "import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport { COLUMN } from './sourcemap-segment';\n\nexport type MemoState = {\n  lastKey: number;\n  lastNeedle: number;\n  lastIndex: number;\n};\n\nexport let found = false;\n\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nexport function binarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  low: number,\n  high: number,\n): number {\n  while (low <= high) {\n    const mid = low + ((high - low) >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  found = false;\n  return low - 1;\n}\n\nexport function upperBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function lowerBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function memoizedState(): MemoState {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1,\n  };\n}\n\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nexport function memoizedBinarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  state: MemoState,\n  key: number,\n): number {\n  const { lastKey, lastNeedle, lastIndex } = state;\n\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n\n    if (needle >= lastNeedle) {\n      // lastIndex may be -1 if the previous needle was not found.\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n\n  return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n", "import { COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN } from './sourcemap-segment';\nimport { memoizedBinarySearch, upperBound } from './binary-search';\n\nimport type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';\nimport type { MemoState } from './binary-search';\n\nexport type Source = {\n  __proto__: null;\n  [line: number]: Exclude<ReverseSegment, [number]>[];\n};\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nexport default function buildBySources(\n  decoded: readonly SourceMapSegment[][],\n  memos: MemoState[],\n): Source[] {\n  const sources: Source[] = memos.map(buildNullArray);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n\n      const sourceIndex = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const originalSource = sources[sourceIndex];\n      const originalLine = (originalSource[sourceLine] ||= []);\n      const memo = memos[sourceIndex];\n\n      // The binary search either found a match, or it found the left-index just before where the\n      // segment should go. Either way, we want to insert after that. And there may be multiple\n      // generated segments associated with an original location, so there may need to move several\n      // indexes before we find where we need to insert.\n      let index = upperBound(\n        originalLine,\n        sourceColumn,\n        memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine),\n      );\n\n      memo.lastIndex = ++index;\n      insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n\n  return sources;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray<T extends { __proto__: null }>(): T {\n  return { __proto__: null } as T;\n}\n", "import type { SourceMapSegment } from './sourcemap-segment';\nimport type { GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap } from './trace-mapping';\n\nexport interface SourceMapV3 {\n  file?: string | null;\n  names: string[];\n  sourceRoot?: string;\n  sources: (string | null)[];\n  sourcesContent?: (string | null)[];\n  version: 3;\n  ignoreList?: number[];\n}\n\nexport interface EncodedSourceMap extends SourceMapV3 {\n  mappings: string;\n}\n\nexport interface DecodedSourceMap extends SourceMapV3 {\n  mappings: SourceMapSegment[][];\n}\n\nexport interface Section {\n  offset: { line: number; column: number };\n  map: EncodedSourceMap | DecodedSourceMap | SectionedSourceMap;\n}\n\nexport interface SectionedSourceMap {\n  file?: string | null;\n  sections: Section[];\n  version: 3;\n}\n\nexport type OriginalMapping = {\n  source: string | null;\n  line: number;\n  column: number;\n  name: string | null;\n};\n\nexport type InvalidOriginalMapping = {\n  source: null;\n  line: null;\n  column: null;\n  name: null;\n};\n\nexport type GeneratedMapping = {\n  line: number;\n  column: number;\n};\nexport type InvalidGeneratedMapping = {\n  line: null;\n  column: null;\n};\n\nexport type Bias = typeof GREATEST_LOWER_BOUND | typeof LEAST_UPPER_BOUND;\n\nexport type XInput = { x_google_ignoreList?: SourceMapV3['ignoreList'] };\nexport type EncodedSourceMapXInput = EncodedSourceMap & XInput;\nexport type DecodedSourceMapXInput = DecodedSourceMap & XInput;\nexport type SectionedSourceMapXInput = Omit<SectionedSourceMap, 'sections'> & {\n  sections: SectionXInput[];\n};\nexport type SectionXInput = Omit<Section, 'map'> & {\n  map: SectionedSourceMapInput;\n};\n\nexport type SourceMapInput = string | EncodedSourceMapXInput | DecodedSourceMapXInput | TraceMap;\nexport type SectionedSourceMapInput = SourceMapInput | SectionedSourceMapXInput;\n\nexport type Needle = { line: number; column: number; bias?: Bias };\nexport type SourceNeedle = { source: string; line: number; column: number; bias?: Bias };\n\nexport type EachMapping =\n  | {\n      generatedLine: number;\n      generatedColumn: number;\n      source: null;\n      originalLine: null;\n      originalColumn: null;\n      name: null;\n    }\n  | {\n      generatedLine: number;\n      generatedColumn: number;\n      source: string | null;\n      originalLine: number;\n      originalColumn: number;\n      name: string | null;\n    };\n\nexport abstract class SourceMap {\n  declare version: SourceMapV3['version'];\n  declare file: SourceMapV3['file'];\n  declare names: SourceMapV3['names'];\n  declare sourceRoot: SourceMapV3['sourceRoot'];\n  declare sources: SourceMapV3['sources'];\n  declare sourcesContent: SourceMapV3['sourcesContent'];\n  declare resolvedSources: SourceMapV3['sources'];\n  declare ignoreList: SourceMapV3['ignoreList'];\n}\n\nexport type Ro<T> =\n  T extends Array<infer V>\n    ? V[] | Readonly<V[]> | RoArray<V> | Readonly<RoArray<V>>\n    : T extends object\n      ? T | Readonly<T> | RoObject<T> | Readonly<RoObject<T>>\n      : T;\ntype RoArray<T> = Ro<T>[];\ntype RoObject<T> = { [K in keyof T]: T[K] | Ro<T[K]> };\n\nexport function parse<T>(map: T): Exclude<T, string> {\n  return typeof map === 'string' ? JSON.parse(map) : (map as Exclude<T, string>);\n}\n", "import { TraceMap, presortedDecodedMap, decodedMappings } from './trace-mapping';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\nimport { parse } from './types';\n\nimport type {\n  DecodedSourceMap,\n  DecodedSourceMapXInput,\n  EncodedSourceMapXInput,\n  SectionedSourceMapXInput,\n  SectionedSourceMapInput,\n  SectionXInput,\n  Ro,\n} from './types';\nimport type { SourceMapSegment } from './sourcemap-segment';\n\ntype FlattenMap = {\n  new (map: Ro<SectionedSourceMapInput>, mapUrl?: string | null): TraceMap;\n  (map: Ro<SectionedSourceMapInput>, mapUrl?: string | null): TraceMap;\n};\n\nexport const FlattenMap: FlattenMap = function (map, mapUrl) {\n  const parsed = parse(map as SectionedSourceMapInput);\n\n  if (!('sections' in parsed)) {\n    return new TraceMap(parsed as DecodedSourceMapXInput | EncodedSourceMapXInput, mapUrl);\n  }\n\n  const mappings: SourceMapSegment[][] = [];\n  const sources: string[] = [];\n  const sourcesContent: (string | null)[] = [];\n  const names: string[] = [];\n  const ignoreList: number[] = [];\n\n  recurse(\n    parsed,\n    mapUrl,\n    mappings,\n    sources,\n    sourcesContent,\n    names,\n    ignoreList,\n    0,\n    0,\n    Infinity,\n    Infinity,\n  );\n\n  const joined: DecodedSourceMap = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n    ignoreList,\n  };\n\n  return presortedDecodedMap(joined);\n} as FlattenMap;\n\nfunction recurse(\n  input: SectionedSourceMapXInput,\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  ignoreList: number[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  const { sections } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const { map, offset } = sections[i];\n\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n\n    addSection(\n      map,\n      mapUrl,\n      mappings,\n      sources,\n      sourcesContent,\n      names,\n      ignoreList,\n      lineOffset + offset.line,\n      columnOffset + offset.column,\n      sl,\n      sc,\n    );\n  }\n}\n\nfunction addSection(\n  input: SectionXInput['map'],\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  ignoreList: number[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  const parsed = parse(input);\n  if ('sections' in parsed) return recurse(...(arguments as unknown as Parameters<typeof recurse>));\n\n  const map = new TraceMap(parsed, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;\n\n  append(sources, resolvedSources);\n  append(names, map.names);\n\n  if (contents) append(sourcesContent, contents);\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n\n  if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\n    // still need to check that we don't overstep lines, too.\n    if (lineI > stopLine) return;\n\n    // The out line may already exist in mappings (if we're continuing the line started by a\n    // previous section). Or, we may have jumped ahead several lines to start this section.\n    const out = getLine(mappings, lineI);\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n    // map can be multiple lines), it doesn't.\n    const cOffset = i === 0 ? columnOffset : 0;\n\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n\n      // If this segment steps into the column range that the next section's map controls, we need\n      // to stop early.\n      if (lineI === stopLine && column >= stopColumn) return;\n\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(\n        seg.length === 4\n          ? [column, sourcesIndex, sourceLine, sourceColumn]\n          : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]],\n      );\n    }\n  }\n}\n\nfunction append<T>(arr: T[], other: T[]) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\n\nfunction getLine<T>(arr: T[][], index: number): T[] {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\n", null, null, "import { SetArray, put, remove } from './set-array';\nimport {\n  encode,\n  // encodeGeneratedRanges,\n  // encodeOriginalScopes\n} from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\n\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type { SourceMapInput } from '@jridgewell/trace-mapping';\n// import type { OriginalScope, GeneratedRange } from '@jridgewell/sourcemap-codec';\nimport type { SourceMapSegment } from './sourcemap-segment';\nimport type {\n  DecodedSourceMap,\n  EncodedSourceMap,\n  Pos,\n  Mapping,\n  // BindingExpressionRange,\n  // OriginalPos,\n  // OriginalScopeInfo,\n  // GeneratedRangeInfo,\n} from './types';\n\nexport type { DecodedSourceMap, EncodedSourceMap, Mapping };\n\nexport type Options = {\n  file?: string | null;\n  sourceRoot?: string | null;\n};\n\nconst NO_NAME = -1;\n\n/**\n * Provides the state to generate a sourcemap.\n */\nexport class GenMapping {\n  declare private _names: SetArray<string>;\n  declare private _sources: SetArray<string>;\n  declare private _sourcesContent: (string | null)[];\n  declare private _mappings: SourceMapSegment[][];\n  // private declare _originalScopes: OriginalScope[][];\n  // private declare _generatedRanges: GeneratedRange[];\n  declare private _ignoreList: SetArray<number>;\n  declare file: string | null | undefined;\n  declare sourceRoot: string | null | undefined;\n\n  constructor({ file, sourceRoot }: Options = {}) {\n    this._names = new SetArray();\n    this._sources = new SetArray();\n    this._sourcesContent = [];\n    this._mappings = [];\n    // this._originalScopes = [];\n    // this._generatedRanges = [];\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n    this._ignoreList = new SetArray();\n  }\n}\n\ninterface PublicMap {\n  _names: GenMapping['_names'];\n  _sources: GenMapping['_sources'];\n  _sourcesContent: GenMapping['_sourcesContent'];\n  _mappings: GenMapping['_mappings'];\n  // _originalScopes: GenMapping['_originalScopes'];\n  // _generatedRanges: GenMapping['_generatedRanges'];\n  _ignoreList: GenMapping['_ignoreList'];\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map: unknown): PublicMap {\n  return map as any;\n}\n\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source?: null,\n  sourceLine?: null,\n  sourceColumn?: null,\n  name?: null,\n  content?: null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: string,\n  sourceLine: number,\n  sourceColumn: number,\n  name?: null,\n  content?: string | null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: string,\n  sourceLine: number,\n  sourceColumn: number,\n  name: string,\n  content?: string | null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source?: string | null,\n  sourceLine?: number | null,\n  sourceColumn?: number | null,\n  name?: string | null,\n  content?: string | null,\n): void {\n  return addSegmentInternal(\n    false,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content,\n  );\n}\n\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source?: null;\n    original?: null;\n    name?: null;\n    content?: null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: string;\n    original: Pos;\n    name?: null;\n    content?: string | null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: string;\n    original: Pos;\n    name: string;\n    content?: string | null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source?: string | null;\n    original?: Pos | null;\n    name?: string | null;\n    content?: string | null;\n  },\n): void {\n  return addMappingInternal(false, map, mapping as Parameters<typeof addMappingInternal>[2]);\n}\n\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nexport const maybeAddSegment: typeof addSegment = (\n  map,\n  genLine,\n  genColumn,\n  source,\n  sourceLine,\n  sourceColumn,\n  name,\n  content,\n) => {\n  return addSegmentInternal(\n    true,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content,\n  );\n};\n\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nexport const maybeAddMapping: typeof addMapping = (map, mapping) => {\n  return addMappingInternal(true, map, mapping as Parameters<typeof addMappingInternal>[2]);\n};\n\n/**\n * Adds/removes the content of the source file to the source map.\n */\nexport function setSourceContent(map: GenMapping, source: string, content: string | null): void {\n  const {\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    // _originalScopes: originalScopes,\n  } = cast(map);\n  const index = put(sources, source);\n  sourcesContent[index] = content;\n  // if (index === originalScopes.length) originalScopes[index] = [];\n}\n\nexport function setIgnore(map: GenMapping, source: string, ignore = true) {\n  const {\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _ignoreList: ignoreList,\n    // _originalScopes: originalScopes,\n  } = cast(map);\n  const index = put(sources, source);\n  if (index === sourcesContent.length) sourcesContent[index] = null;\n  // if (index === originalScopes.length) originalScopes[index] = [];\n  if (ignore) put(ignoreList, index);\n  else remove(ignoreList, index);\n}\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function toDecodedMap(map: GenMapping): DecodedSourceMap {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n    _ignoreList: ignoreList,\n    // _originalScopes: originalScopes,\n    // _generatedRanges: generatedRanges,\n  } = cast(map);\n  removeEmptyFinalLines(mappings);\n\n  return {\n    version: 3,\n    file: map.file || undefined,\n    names: names.array,\n    sourceRoot: map.sourceRoot || undefined,\n    sources: sources.array,\n    sourcesContent,\n    mappings,\n    // originalScopes,\n    // generatedRanges,\n    ignoreList: ignoreList.array,\n  };\n}\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function toEncodedMap(map: GenMapping): EncodedSourceMap {\n  const decoded = toDecodedMap(map);\n  return Object.assign({}, decoded, {\n    // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),\n    // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),\n    mappings: encode(decoded.mappings as SourceMapSegment[][]),\n  });\n}\n\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nexport function fromMap(input: SourceMapInput): GenMapping {\n  const map = new TraceMap(input);\n  const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n\n  putAll(cast(gen)._names, map.names);\n  putAll(cast(gen)._sources, map.sources as string[]);\n  cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n  cast(gen)._mappings = decodedMappings(map) as GenMapping['_mappings'];\n  // TODO: implement originalScopes/generatedRanges\n  if (map.ignoreList) putAll(cast(gen)._ignoreList, map.ignoreList);\n\n  return gen;\n}\n\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nexport function allMappings(map: GenMapping): Mapping[] {\n  const out: Mapping[] = [];\n  const { _mappings: mappings, _sources: sources, _names: names } = cast(map);\n\n  for (let i = 0; i < mappings.length; i++) {\n    const line = mappings[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n\n      const generated = { line: i + 1, column: seg[COLUMN] };\n      let source: string | undefined = undefined;\n      let original: Pos | undefined = undefined;\n      let name: string | undefined = undefined;\n\n      if (seg.length !== 1) {\n        source = sources.array[seg[SOURCES_INDEX]];\n        original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n\n        if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n      }\n\n      out.push({ generated, source, original, name } as Mapping);\n    }\n  }\n\n  return out;\n}\n\n// This split declaration is only so that terser can elminiate the static initialization block.\nfunction addSegmentInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: S,\n  sourceLine: S extends string ? number : null | undefined,\n  sourceColumn: S extends string ? number : null | undefined,\n  name: S extends string ? string | null | undefined : null | undefined,\n  content: S extends string ? string | null | undefined : null | undefined,\n): void {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n    // _originalScopes: originalScopes,\n  } = cast(map);\n  const line = getIndex(mappings, genLine);\n  const index = getColumnIndex(line, genColumn);\n\n  if (!source) {\n    if (skipable && skipSourceless(line, index)) return;\n    return insert(line, index, [genColumn]);\n  }\n\n  // Sigh, TypeScript can't figure out sourceLine and sourceColumn aren't nullish if source\n  // isn't nullish.\n  assert<number>(sourceLine);\n  assert<number>(sourceColumn);\n\n  const sourcesIndex = put(sources, source);\n  const namesIndex = name ? put(names, name) : NO_NAME;\n  if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content ?? null;\n  // if (sourcesIndex === originalScopes.length) originalScopes[sourcesIndex] = [];\n\n  if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n    return;\n  }\n\n  return insert(\n    line,\n    index,\n    name\n      ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n      : [genColumn, sourcesIndex, sourceLine, sourceColumn],\n  );\n}\n\nfunction assert<T>(_val: unknown): asserts _val is T {\n  // noop.\n}\n\nfunction getIndex<T>(arr: T[][], index: number): T[] {\n  for (let i = arr.length; i <= index; i++) {\n    arr[i] = [];\n  }\n  return arr[index];\n}\n\nfunction getColumnIndex(line: SourceMapSegment[], genColumn: number): number {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; index = i--) {\n    const current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n  return index;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\nfunction removeEmptyFinalLines(mappings: SourceMapSegment[][]) {\n  const { length } = mappings;\n  let len = length;\n  for (let i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n  if (len < length) mappings.length = len;\n}\n\nfunction putAll<T extends string | number>(setarr: SetArray<T>, array: T[]) {\n  for (let i = 0; i < array.length; i++) put(setarr, array[i]);\n}\n\nfunction skipSourceless(line: SourceMapSegment[], index: number): boolean {\n  // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n  // doesn't generate any useful information.\n  if (index === 0) return true;\n\n  const prev = line[index - 1];\n  // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n  // genrate any new information. Else, this segment will end the source/named segment and point to\n  // a sourceless position, which is useful.\n  return prev.length === 1;\n}\n\nfunction skipSource(\n  line: SourceMapSegment[],\n  index: number,\n  sourcesIndex: number,\n  sourceLine: number,\n  sourceColumn: number,\n  namesIndex: number,\n): boolean {\n  // A source/named segment at the start of a line gives position at that genColumn\n  if (index === 0) return false;\n\n  const prev = line[index - 1];\n\n  // If the previous segment is sourceless, then we're transitioning to a source.\n  if (prev.length === 1) return false;\n\n  // If the previous segment maps to the exact same source position, then this segment doesn't\n  // provide any new position information.\n  return (\n    sourcesIndex === prev[SOURCES_INDEX] &&\n    sourceLine === prev[SOURCE_LINE] &&\n    sourceColumn === prev[SOURCE_COLUMN] &&\n    namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME)\n  );\n}\n\nfunction addMappingInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: S;\n    original: S extends string ? Pos : null | undefined;\n    name: S extends string ? string | null | undefined : null | undefined;\n    content: S extends string ? string | null | undefined : null | undefined;\n  },\n) {\n  const { generated, source, original, name, content } = mapping;\n  if (!source) {\n    return addSegmentInternal(\n      skipable,\n      map,\n      generated.line - 1,\n      generated.column,\n      null,\n      null,\n      null,\n      null,\n      null,\n    );\n  }\n  assert<Pos>(original);\n  return addSegmentInternal(\n    skipable,\n    map,\n    generated.line - 1,\n    generated.column,\n    source as string,\n    original.line - 1,\n    original.column,\n    name,\n    content,\n  );\n}\n\n/*\nexport function addOriginalScope(\n  map: GenMapping,\n  data: {\n    start: Pos;\n    end: Pos;\n    source: string;\n    kind: string;\n    name?: string;\n    variables?: string[];\n  },\n): OriginalScopeInfo {\n  const { start, end, source, kind, name, variables } = data;\n  const {\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _originalScopes: originalScopes,\n    _names: names,\n  } = cast(map);\n  const index = put(sources, source);\n  if (index === sourcesContent.length) sourcesContent[index] = null;\n  if (index === originalScopes.length) originalScopes[index] = [];\n\n  const kindIndex = put(names, kind);\n  const scope: OriginalScope = name\n    ? [start.line - 1, start.column, end.line - 1, end.column, kindIndex, put(names, name)]\n    : [start.line - 1, start.column, end.line - 1, end.column, kindIndex];\n  if (variables) {\n    scope.vars = variables.map((v) => put(names, v));\n  }\n  const len = originalScopes[index].push(scope);\n  return [index, len - 1, variables];\n}\n*/\n\n// Generated Ranges\n/*\nexport function addGeneratedRange(\n  map: GenMapping,\n  data: {\n    start: Pos;\n    isScope: boolean;\n    originalScope?: OriginalScopeInfo;\n    callsite?: OriginalPos;\n  },\n): GeneratedRangeInfo {\n  const { start, isScope, originalScope, callsite } = data;\n  const {\n    _originalScopes: originalScopes,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _generatedRanges: generatedRanges,\n  } = cast(map);\n\n  const range: GeneratedRange = [\n    start.line - 1,\n    start.column,\n    0,\n    0,\n    originalScope ? originalScope[0] : -1,\n    originalScope ? originalScope[1] : -1,\n  ];\n  if (originalScope?.[2]) {\n    range.bindings = originalScope[2].map(() => [[-1]]);\n  }\n  if (callsite) {\n    const index = put(sources, callsite.source);\n    if (index === sourcesContent.length) sourcesContent[index] = null;\n    if (index === originalScopes.length) originalScopes[index] = [];\n    range.callsite = [index, callsite.line - 1, callsite.column];\n  }\n  if (isScope) range.isScope = true;\n  generatedRanges.push(range);\n\n  return [range, originalScope?.[2]];\n}\n\nexport function setEndPosition(range: GeneratedRangeInfo, pos: Pos) {\n  range[0][2] = pos.line - 1;\n  range[0][3] = pos.column;\n}\n\nexport function addBinding(\n  map: GenMapping,\n  range: GeneratedRangeInfo,\n  variable: string,\n  expression: string | BindingExpressionRange,\n) {\n  const { _names: names } = cast(map);\n  const bindings = (range[0].bindings ||= []);\n  const vars = range[1];\n\n  const index = vars!.indexOf(variable);\n  const binding = getIndex(bindings, index);\n\n  if (typeof expression === 'string') binding[0] = [put(names, expression)];\n  else {\n    const { start } = expression;\n    binding.push([put(names, expression.expression), start.line - 1, start.column]);\n  }\n}\n*/\n", "type Key = string | number | symbol;\n\n/**\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n * index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of the backing array,\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n * and there are never duplicates.\n */\nexport class SetArray<T extends Key = Key> {\n  declare private _indexes: Record<T, number | undefined>;\n  declare array: readonly T[];\n\n  constructor() {\n    this._indexes = { __proto__: null } as any;\n    this.array = [];\n  }\n}\n\ninterface PublicSet<T extends Key> {\n  array: T[];\n  _indexes: SetArray<T>['_indexes'];\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the set into a type\n * with public access modifiers.\n */\nfunction cast<T extends Key>(set: SetArray<T>): PublicSet<T> {\n  return set as any;\n}\n\n/**\n * Gets the index associated with `key` in the backing array, if it is already present.\n */\nexport function get<T extends Key>(setarr: SetArray<T>, key: T): number | undefined {\n  return cast(setarr)._indexes[key];\n}\n\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */\nexport function put<T extends Key>(setarr: SetArray<T>, key: T): number {\n  // The key may or may not be present. If it is present, it's a number.\n  const index = get(setarr, key);\n  if (index !== undefined) return index;\n\n  const { array, _indexes: indexes } = cast(setarr);\n\n  const length = array.push(key);\n  return (indexes[key] = length - 1);\n}\n\n/**\n * Pops the last added item out of the SetArray.\n */\nexport function pop<T extends Key>(setarr: SetArray<T>): void {\n  const { array, _indexes: indexes } = cast(setarr);\n  if (array.length === 0) return;\n\n  const last = array.pop()!;\n  indexes[last] = undefined;\n}\n\n/**\n * Removes the key, if it exists in the set.\n */\nexport function remove<T extends Key>(setarr: SetArray<T>, key: T): void {\n  const index = get(setarr, key);\n  if (index === undefined) return;\n\n  const { array, _indexes: indexes } = cast(setarr);\n  for (let i = index + 1; i < array.length; i++) {\n    const k = array[i];\n    array[i - 1] = k;\n    indexes[k]!--;\n  }\n  indexes[key] = undefined;\n  array.pop();\n}\n", "type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n", "import {\n  GenMapping,\n  maybeAddMapping,\n  setSourceContent,\n  allMappings,\n  toEncodedMap,\n  toDecodedMap,\n} from \"@jridgewell/gen-mapping\";\n\nimport type {\n  EncodedSourceMap,\n  DecodedSourceMap,\n  Mapping,\n} from \"@jridgewell/gen-mapping\";\n\nimport {\n  type SourceMapInput,\n  originalPositionFor,\n  TraceMap,\n} from \"@jridgewell/trace-mapping\";\n\n/**\n * Build a sourcemap.\n */\n\nexport default class SourceMap {\n  private _map: GenMapping;\n  private _rawMappings: Mapping[] | undefined;\n  private _sourceFileName: string | undefined;\n\n  // Any real line is > 0, so init to 0 is fine.\n  private _lastGenLine = 0;\n  private _lastSourceLine = 0;\n\n  // Source columns can be 0, but we only check in unison with sourceLine, which\n  // inits to an impossible value. So init to 0 is fine.\n  private _lastSourceColumn = 0;\n\n  public _inputMap: TraceMap;\n\n  constructor(\n    opts: {\n      sourceFileName?: string;\n      sourceRoot?: string;\n      inputSourceMap?: SourceMapInput;\n    },\n    code: string | { [sourceFileName: string]: string },\n  ) {\n    const map = (this._map = new GenMapping({ sourceRoot: opts.sourceRoot }));\n    this._sourceFileName = opts.sourceFileName?.replace(/\\\\/g, \"/\");\n    this._rawMappings = undefined;\n\n    if (opts.inputSourceMap) {\n      this._inputMap = new TraceMap(opts.inputSourceMap);\n      const resolvedSources = this._inputMap.resolvedSources;\n      if (resolvedSources.length) {\n        for (let i = 0; i < resolvedSources.length; i++) {\n          setSourceContent(\n            map,\n            resolvedSources[i],\n            this._inputMap.sourcesContent?.[i],\n          );\n        }\n      }\n    }\n\n    if (typeof code === \"string\" && !opts.inputSourceMap) {\n      setSourceContent(map, this._sourceFileName, code);\n    } else if (typeof code === \"object\") {\n      for (const sourceFileName of Object.keys(code)) {\n        setSourceContent(\n          map,\n          sourceFileName.replace(/\\\\/g, \"/\"),\n          code[sourceFileName],\n        );\n      }\n    }\n  }\n\n  /**\n   * Get the sourcemap.\n   */\n  get(): EncodedSourceMap {\n    return toEncodedMap(this._map);\n  }\n\n  getDecoded(): DecodedSourceMap {\n    return toDecodedMap(this._map);\n  }\n\n  getRawMappings(): Mapping[] {\n    return (this._rawMappings ||= allMappings(this._map));\n  }\n\n  /**\n   * Mark the current generated position with a source position. May also be passed null line/column\n   * values to insert a mapping to nothing.\n   */\n\n  mark(\n    generated: { line: number; column: number },\n    line: number,\n    column: number,\n    identifierName?: string | null,\n    identifierNamePos?: { line: number; column: number },\n    filename?: string | null,\n  ) {\n    this._rawMappings = undefined;\n\n    let originalMapping: {\n      source: string | null;\n      name?: string | null;\n      line: number | null;\n      column: number | null;\n    };\n\n    if (line != null) {\n      if (this._inputMap) {\n        // This is the lookup for this mark\n        originalMapping = originalPositionFor(this._inputMap, {\n          line,\n          column,\n        });\n\n        // If the we found a name, nothing else needs to be done\n        // Maybe we're marking a `(` and the input map already had a name attached there,\n        // or we're marking a `(` and the sourcemap spanned a `foo(`,\n        // or we're marking an identifier, etc.\n        if (!originalMapping.name && identifierNamePos) {\n          // We're trying to mark a `(` (as that's the only thing that provides\n          // an identifierNamePos currently), and we the AST had an identifier attached.\n          // Lookup it's original name.\n          const originalIdentifierMapping = originalPositionFor(\n            this._inputMap,\n            identifierNamePos,\n          );\n          if (originalIdentifierMapping.name) {\n            identifierName = originalIdentifierMapping.name;\n          }\n        }\n      } else {\n        originalMapping = {\n          source: filename?.replace(/\\\\/g, \"/\") || this._sourceFileName,\n          line: line,\n          column: column,\n        };\n      }\n    }\n\n    maybeAddMapping(this._map, {\n      name: identifierName,\n      generated,\n      source: originalMapping?.source,\n      original: originalMapping,\n    });\n  }\n}\n", "import type SourceMap from \"./source-map.ts\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charcodes from \"charcodes\";\n\nexport type Pos = {\n  line: number;\n  column: number;\n  index: number;\n};\nexport type Loc = {\n  start?: Pos;\n  end?: Pos;\n  filename?: string;\n};\ntype SourcePos = {\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: string | undefined;\n  filename: string | undefined;\n};\ntype InternalSourcePos = SourcePos & { identifierNamePos: Pos };\n\ntype QueueItem = {\n  char: number;\n  repeat: number;\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: undefined; // Not used, it always undefined.\n  identifierNamePos: undefined; // Not used, it always undefined.\n  filename: string | undefined;\n};\n\nexport default class Buffer {\n  constructor(map: SourceMap | null, indentChar: string) {\n    this._map = map;\n    this._indentChar = indentChar;\n\n    for (let i = 0; i < 64; i++) {\n      this._fastIndentations.push(indentChar.repeat(i));\n    }\n\n    this._allocQueue();\n  }\n\n  _map: SourceMap = null;\n  _buf = \"\";\n  _str = \"\";\n  _appendCount = 0;\n  _last = 0;\n  _queue: QueueItem[] = [];\n  _queueCursor = 0;\n  _canMarkIdName = true;\n  _indentChar = \"\";\n  _fastIndentations: string[] = [];\n\n  _position = {\n    line: 1,\n    column: 0,\n  };\n  _sourcePosition: InternalSourcePos = {\n    identifierName: undefined,\n    identifierNamePos: undefined,\n    line: undefined,\n    column: undefined,\n    filename: undefined,\n  };\n\n  _allocQueue() {\n    const queue = this._queue;\n\n    for (let i = 0; i < 16; i++) {\n      queue.push({\n        char: 0,\n        repeat: 1,\n        line: undefined,\n        column: undefined,\n        identifierName: undefined,\n        identifierNamePos: undefined,\n        filename: \"\",\n      });\n    }\n  }\n\n  _pushQueue(\n    char: number,\n    repeat: number,\n    line: number | undefined,\n    column: number | undefined,\n    filename: string | undefined,\n  ) {\n    const cursor = this._queueCursor;\n    if (cursor === this._queue.length) {\n      this._allocQueue();\n    }\n    const item = this._queue[cursor];\n    item.char = char;\n    item.repeat = repeat;\n    item.line = line;\n    item.column = column;\n    item.filename = filename;\n\n    this._queueCursor++;\n  }\n\n  _popQueue(): QueueItem {\n    if (this._queueCursor === 0) {\n      throw new Error(\"Cannot pop from empty queue\");\n    }\n    return this._queue[--this._queueCursor];\n  }\n\n  /**\n   * Get the final string output from the buffer, along with the sourcemap if one exists.\n   */\n\n  get() {\n    this._flush();\n\n    const map = this._map;\n    const result = {\n      // Whatever trim is used here should not execute a regex against the\n      // source string since it may be arbitrarily large after all transformations\n      code: (this._buf + this._str).trimRight(),\n      // Decoded sourcemap is free to generate.\n      decodedMap: map?.getDecoded(),\n      // Used as a marker for backwards compatibility. We moved input map merging\n      // into the generator. We cannot merge the input map a second time, so the\n      // presence of this field tells us we've already done the work.\n      get __mergedMap() {\n        return this.map;\n      },\n      // Encoding the sourcemap is moderately CPU expensive.\n      get map() {\n        const resultMap = map ? map.get() : null;\n        result.map = resultMap;\n        return resultMap;\n      },\n      set map(value) {\n        Object.defineProperty(result, \"map\", { value, writable: true });\n      },\n      // Retrieving the raw mappings is very memory intensive.\n      get rawMappings() {\n        const mappings = map?.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", { value, writable: true });\n      },\n    };\n\n    return result;\n  }\n\n  /**\n   * Add a string to the buffer that cannot be reverted.\n   */\n\n  append(str: string, maybeNewline: boolean): void {\n    this._flush();\n\n    this._append(str, this._sourcePosition, maybeNewline);\n  }\n\n  appendChar(char: number): void {\n    this._flush();\n    this._appendChar(char, 1, this._sourcePosition);\n  }\n\n  /**\n   * Add a string to the buffer than can be reverted.\n   */\n  queue(char: number): void {\n    // Drop trailing spaces when a newline is inserted.\n    if (char === charcodes.lineFeed) {\n      while (this._queueCursor !== 0) {\n        const char = this._queue[this._queueCursor - 1].char;\n        if (char !== charcodes.space && char !== charcodes.tab) {\n          break;\n        }\n\n        this._queueCursor--;\n      }\n    }\n\n    const sourcePosition = this._sourcePosition;\n    this._pushQueue(\n      char,\n      1,\n      sourcePosition.line,\n      sourcePosition.column,\n      sourcePosition.filename,\n    );\n  }\n\n  /**\n   * Same as queue, but this indentation will never have a sourcemap marker.\n   */\n  queueIndentation(repeat: number): void {\n    if (repeat === 0) return;\n    this._pushQueue(-1, repeat, undefined, undefined, undefined);\n  }\n\n  _flush(): void {\n    const queueCursor = this._queueCursor;\n    const queue = this._queue;\n    for (let i = 0; i < queueCursor; i++) {\n      const item: QueueItem = queue[i];\n      this._appendChar(item.char, item.repeat, item);\n    }\n    this._queueCursor = 0;\n  }\n\n  _appendChar(\n    char: number,\n    repeat: number,\n    sourcePos: InternalSourcePos,\n  ): void {\n    this._last = char;\n\n    if (char === -1) {\n      const fastIndentation = this._fastIndentations[repeat];\n      if (fastIndentation !== undefined) {\n        this._str += fastIndentation;\n      } else {\n        this._str +=\n          repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;\n      }\n    } else {\n      this._str +=\n        repeat > 1\n          ? String.fromCharCode(char).repeat(repeat)\n          : String.fromCharCode(char);\n    }\n\n    if (char !== charcodes.lineFeed) {\n      this._mark(\n        sourcePos.line,\n        sourcePos.column,\n        sourcePos.identifierName,\n        sourcePos.identifierNamePos,\n        sourcePos.filename,\n      );\n      this._position.column += repeat;\n    } else {\n      this._position.line++;\n      this._position.column = 0;\n    }\n\n    if (this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n  }\n\n  _append(\n    str: string,\n    sourcePos: InternalSourcePos,\n    maybeNewline: boolean,\n  ): void {\n    const len = str.length;\n    const position = this._position;\n\n    this._last = str.charCodeAt(len - 1);\n\n    if (++this._appendCount > 4096) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n      +this._str; // Unexplainable huge performance boost. Ref: https://github.com/davidmarkclements/flatstr License: MIT\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n\n    if (!maybeNewline && !this._map) {\n      position.column += len;\n      return;\n    }\n\n    const { column, identifierName, identifierNamePos, filename } = sourcePos;\n    let line = sourcePos.line;\n\n    if (\n      (identifierName != null || identifierNamePos != null) &&\n      this._canMarkIdName\n    ) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n\n    // Search for newline chars. We search only for `\\n`, since both `\\r` and\n    // `\\r\\n` are normalized to `\\n` during parse. We exclude `\\u2028` and\n    // `\\u2029` for performance reasons, they're so uncommon that it's probably\n    // ok. It's also unclear how other sourcemap utilities handle them...\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n\n    // If the string starts with a newline char, then adding a mark is redundant.\n    // This catches both \"no newlines\" and \"newline after several chars\".\n    if (i !== 0) {\n      this._mark(line, column, identifierName, identifierNamePos, filename);\n    }\n\n    // Now, find each remaining newline char in the string.\n    while (i !== -1) {\n      position.line++;\n      position.column = 0;\n      last = i + 1;\n\n      // We mark the start of each line, which happens directly after this newline char\n      // unless this is the last char.\n      // When manually adding multi-line content (such as a comment), `line` will be `undefined`.\n      if (last < len && line !== undefined) {\n        this._mark(++line, 0, null, null, filename);\n      }\n      i = str.indexOf(\"\\n\", last);\n    }\n    position.column += len - last;\n  }\n\n  _mark(\n    line: number | undefined,\n    column: number | undefined,\n    identifierName: string | undefined,\n    identifierNamePos: Pos | undefined,\n    filename: string | undefined,\n  ): void {\n    this._map?.mark(\n      this._position,\n      line,\n      column,\n      identifierName,\n      identifierNamePos,\n      filename,\n    );\n  }\n\n  removeTrailingNewline(): void {\n    const queueCursor = this._queueCursor;\n    if (\n      queueCursor !== 0 &&\n      this._queue[queueCursor - 1].char === charcodes.lineFeed\n    ) {\n      this._queueCursor--;\n    }\n  }\n\n  removeLastSemicolon(): void {\n    const queueCursor = this._queueCursor;\n    if (\n      queueCursor !== 0 &&\n      this._queue[queueCursor - 1].char === charcodes.semicolon\n    ) {\n      this._queueCursor--;\n    }\n  }\n\n  getLastChar(): number {\n    const queueCursor = this._queueCursor;\n    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n  }\n\n  /**\n   * This will only detect at most 1 newline after a call to `flush()`,\n   * but this has not been found so far, and an accurate count can be achieved if needed later.\n   */\n  getNewlineCount(): number {\n    const queueCursor = this._queueCursor;\n    let count = 0;\n    if (queueCursor === 0) return this._last === charcodes.lineFeed ? 1 : 0;\n    for (let i = queueCursor - 1; i >= 0; i--) {\n      if (this._queue[i].char !== charcodes.lineFeed) {\n        break;\n      }\n      count++;\n    }\n    return count === queueCursor && this._last === charcodes.lineFeed\n      ? count + 1\n      : count;\n  }\n\n  /**\n   * check if current _last + queue ends with newline, return the character before newline\n   */\n  endsWithCharAndNewline(): number {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0) {\n      // every element in queue is one-length whitespace string\n      const lastCp = queue[queueCursor - 1].char;\n      if (lastCp !== charcodes.lineFeed) return;\n      if (queueCursor > 1) {\n        return queue[queueCursor - 2].char;\n      } else {\n        return this._last;\n      }\n    }\n    // We assume that everything being matched is at most a single token plus some whitespace,\n    // which everything currently is, but otherwise we'd have to expand _last or check _buf.\n  }\n\n  hasContent(): boolean {\n    return this._queueCursor !== 0 || !!this._last;\n  }\n\n  /**\n   * Certain sourcemap usecases expect mappings to be more accurate than\n   * Babel's generic sourcemap handling allows. For now, we special-case\n   * identifiers to allow for the primary cases to work.\n   * The goal of this line is to ensure that the map output from Babel will\n   * have an exact range on identifiers in the output code. Without this\n   * line, Babel would potentially include some number of trailing tokens\n   * that are printed after the identifier, but before another location has\n   * been assigned.\n   * This allows tooling like Rollup and Webpack to more accurately perform\n   * their own transformations. Most importantly, this allows the import/export\n   * transformations performed by those tools to loose less information when\n   * applying their own transformations on top of the code and map results\n   * generated by Babel itself.\n   *\n   * The primary example of this is the snippet:\n   *\n   *   import mod from \"mod\";\n   *   mod();\n   *\n   * With this line, there will be one mapping range over \"mod\" and another\n   * over \"();\", where previously it would have been a single mapping.\n   */\n  exactSource(loc: Loc | undefined, cb: () => void) {\n    if (!this._map) {\n      cb();\n      return;\n    }\n\n    this.source(\"start\", loc);\n    // @ts-expect-error identifierName is not defined\n    const identifierName = loc.identifierName;\n    const sourcePos = this._sourcePosition;\n    if (identifierName) {\n      this._canMarkIdName = false;\n      sourcePos.identifierName = identifierName;\n    }\n    cb();\n\n    if (identifierName) {\n      this._canMarkIdName = true;\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    this.source(\"end\", loc);\n  }\n\n  /**\n   * Sets a given position as the current source location so generated code after this call\n   * will be given this position in the sourcemap.\n   */\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!this._map) return;\n\n    // Since this is called extremely often, we reuse the same _sourcePosition\n    // object for the whole lifetime of the buffer.\n    this._normalizePosition(prop, loc, 0);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    columnOffset: number,\n  ): void {\n    if (!this._map) return;\n\n    this._normalizePosition(prop, loc, columnOffset);\n  }\n\n  _normalizePosition(prop: \"start\" | \"end\", loc: Loc, columnOffset: number) {\n    const pos = loc[prop];\n    const target = this._sourcePosition;\n\n    if (pos) {\n      target.line = pos.line;\n      // TODO: Fix https://github.com/babel/babel/issues/15712 in downstream\n      target.column = Math.max(pos.column + columnOffset, 0);\n      target.filename = loc.filename;\n    }\n  }\n\n  getCurrentColumn(): number {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n\n    let lastIndex = -1;\n    let len = 0;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      if (item.char === charcodes.lineFeed) {\n        lastIndex = len;\n      }\n      len += item.repeat;\n    }\n\n    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n  }\n\n  getCurrentLine(): number {\n    let count = 0;\n\n    const queue = this._queue;\n    for (let i = 0; i < this._queueCursor; i++) {\n      if (queue[i].char === charcodes.lineFeed) {\n        count++;\n      }\n    }\n\n    return this._position.line + count;\n  }\n}\n", "import {\n  FLIPPED_ALIAS_KEYS,\n  isArrayExpression,\n  isAssignmentExpression,\n  isBinary,\n  isBlockStatement,\n  isCallExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isObjectExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isStringLiteral,\n} from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nimport type { NodeHandlers } from \"./index.ts\";\n\nimport type * as t from \"@babel/types\";\n\nconst enum WhitespaceFlag {\n  before = 1 << 0,\n  after = 1 << 1,\n}\n\nexport type { WhitespaceFlag };\n\nfunction crawlInternal(\n  node: t.Node,\n  state: { hasCall: boolean; hasFunction: boolean; hasHelper: boolean },\n) {\n  if (!node) return state;\n\n  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n    crawlInternal(node.object, state);\n    if (node.computed) crawlInternal(node.property, state);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    crawlInternal(node.left, state);\n    crawlInternal(node.right, state);\n  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawlInternal(node.callee, state);\n  } else if (isFunction(node)) {\n    state.hasFunction = true;\n  } else if (isIdentifier(node)) {\n    state.hasHelper =\n      // @ts-expect-error todo(flow->ts): node.callee is not really expected here…\n      state.hasHelper || (node.callee && isHelper(node.callee));\n  }\n\n  return state;\n}\n\n/**\n * Crawl a node to test if it contains a CallExpression, a Function, or a Helper.\n *\n * @example\n * crawl(node)\n * // { hasCall: false, hasFunction: true, hasHelper: false }\n */\n\nfunction crawl(node: t.Node) {\n  return crawlInternal(node, {\n    hasCall: false,\n    hasFunction: false,\n    hasHelper: false,\n  });\n}\n\n/**\n * Test if a node is or has a helper.\n */\n\nfunction isHelper(node: t.Node): boolean {\n  if (!node) return false;\n\n  if (isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (isIdentifier(node)) {\n    return (\n      node.name === \"require\" ||\n      node.name.charCodeAt(0) === charCodes.underscore\n    );\n  } else if (isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    return (\n      (isIdentifier(node.left) && isHelper(node.left)) || isHelper(node.right)\n    );\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node: t.Node) {\n  return (\n    isLiteral(node) ||\n    isObjectExpression(node) ||\n    isArrayExpression(node) ||\n    isIdentifier(node) ||\n    isMemberExpression(node)\n  );\n}\n\n/**\n * Tests for node types that need whitespace.\n */\n\nexport const nodes: NodeHandlers<WhitespaceFlag> = {\n  /**\n   * Test if AssignmentExpression needs whitespace.\n   */\n\n  AssignmentExpression(node: t.AssignmentExpression): WhitespaceFlag {\n    const state = crawl(node.right);\n    if ((state.hasCall && state.hasHelper) || state.hasFunction) {\n      return state.hasFunction\n        ? WhitespaceFlag.before | WhitespaceFlag.after\n        : WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if SwitchCase needs whitespace.\n   */\n\n  SwitchCase(node: t.SwitchCase, parent: t.SwitchStatement): WhitespaceFlag {\n    return (\n      (!!node.consequent.length || parent.cases[0] === node\n        ? WhitespaceFlag.before\n        : 0) |\n      (!node.consequent.length && parent.cases[parent.cases.length - 1] === node\n        ? WhitespaceFlag.after\n        : 0)\n    );\n  },\n\n  /**\n   * Test if LogicalExpression needs whitespace.\n   */\n\n  LogicalExpression(node: t.LogicalExpression): WhitespaceFlag {\n    if (isFunction(node.left) || isFunction(node.right)) {\n      return WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if Literal needs whitespace.\n   */\n\n  Literal(node: t.Literal): WhitespaceFlag {\n    if (isStringLiteral(node) && node.value === \"use strict\") {\n      return WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if CallExpressionish needs whitespace.\n   */\n\n  CallExpression(node: t.CallExpression): WhitespaceFlag {\n    if (isFunction(node.callee) || isHelper(node)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n\n  OptionalCallExpression(node: t.OptionalCallExpression): WhitespaceFlag {\n    if (isFunction(node.callee)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if VariableDeclaration needs whitespace.\n   */\n\n  VariableDeclaration(node: t.VariableDeclaration): WhitespaceFlag {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n      if (!enabled && declar.init) {\n        const state = crawl(declar.init);\n        enabled = (isHelper(declar.init) && state.hasCall) || state.hasFunction;\n      }\n\n      if (enabled) {\n        return WhitespaceFlag.before | WhitespaceFlag.after;\n      }\n    }\n  },\n\n  /**\n   * Test if IfStatement needs whitespace.\n   */\n\n  IfStatement(node: t.IfStatement): WhitespaceFlag {\n    if (isBlockStatement(node.consequent)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n};\n\n/**\n * Test if Property needs whitespace.\n */\n\nnodes.ObjectProperty =\n  nodes.ObjectTypeProperty =\n  nodes.ObjectMethod =\n    function (\n      node: t.ObjectProperty | t.ObjectTypeProperty | t.ObjectMethod,\n      parent: t.ObjectExpression,\n    ): WhitespaceFlag {\n      if (parent.properties[0] === node) {\n        return WhitespaceFlag.before;\n      }\n    };\n\nnodes.ObjectTypeCallProperty = function (\n  node: t.ObjectTypeCallProperty,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (parent.callProperties[0] === node && !parent.properties?.length) {\n    return WhitespaceFlag.before;\n  }\n};\n\nnodes.ObjectTypeIndexer = function (\n  node: t.ObjectTypeIndexer,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (\n    parent.indexers[0] === node &&\n    !parent.properties?.length &&\n    !parent.callProperties?.length\n  ) {\n    return WhitespaceFlag.before;\n  }\n};\n\nnodes.ObjectTypeInternalSlot = function (\n  node: t.ObjectTypeInternalSlot,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (\n    parent.internalSlots[0] === node &&\n    !parent.properties?.length &&\n    !parent.callProperties?.length &&\n    !parent.indexers?.length\n  ) {\n    return WhitespaceFlag.before;\n  }\n};\n\n/**\n * Add whitespace tests for nodes and their aliases.\n */\n\n(\n  [\n    [\"Function\", true],\n    [\"Class\", true],\n    [\"Loop\", true],\n    [\"LabeledStatement\", true],\n    [\"SwitchStatement\", true],\n    [\"TryStatement\", true],\n  ] as const\n).forEach(function ([type, amounts]) {\n  [type as string]\n    .concat(FLIPPED_ALIAS_KEYS[type] || [])\n    .forEach(function (type) {\n      const ret = amounts ? WhitespaceFlag.before | WhitespaceFlag.after : 0;\n      nodes[type] = () => ret;\n    });\n});\n", "import {\n  isArrayTypeAnnotation,\n  isBinaryExpression,\n  isCallExpression,\n  isForOfStatement,\n  isIndexedAccessType,\n  isMemberExpression,\n  isObjectPattern,\n  isOptionalMemberExpression,\n  isYieldExpression,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport { TokenContext } from \"./index.ts\";\n\nconst PRECEDENCE = new Map([\n  [\"||\", 0],\n  [\"??\", 0],\n  [\"|>\", 0],\n  [\"&&\", 1],\n  [\"|\", 2],\n  [\"^\", 3],\n  [\"&\", 4],\n  [\"==\", 5],\n  [\"===\", 5],\n  [\"!=\", 5],\n  [\"!==\", 5],\n  [\"<\", 6],\n  [\">\", 6],\n  [\"<=\", 6],\n  [\">=\", 6],\n  [\"in\", 6],\n  [\"instanceof\", 6],\n  [\">>\", 7],\n  [\"<<\", 7],\n  [\">>>\", 7],\n  [\"+\", 8],\n  [\"-\", 8],\n  [\"*\", 9],\n  [\"/\", 9],\n  [\"%\", 9],\n  [\"**\", 10],\n]);\n\nfunction getBinaryPrecedence(\n  node: t.Binary | t.TSAsExpression | t.TSSatisfiesExpression,\n  nodeType: string,\n): number;\nfunction getBinaryPrecedence(\n  node: t.Node,\n  nodeType: string,\n): number | undefined;\nfunction getBinaryPrecedence(node: t.Node, nodeType: string) {\n  if (nodeType === \"BinaryExpression\" || nodeType === \"LogicalExpression\") {\n    return PRECEDENCE.get((node as t.Binary).operator);\n  }\n  if (nodeType === \"TSAsExpression\" || nodeType === \"TSSatisfiesExpression\") {\n    return PRECEDENCE.get(\"in\");\n  }\n}\n\nfunction isTSTypeExpression(nodeType: string) {\n  return (\n    nodeType === \"TSAsExpression\" ||\n    nodeType === \"TSSatisfiesExpression\" ||\n    nodeType === \"TSTypeAssertion\"\n  );\n}\n\nconst isClassExtendsClause = (\n  node: t.Node,\n  parent: t.Node,\n): parent is t.Class => {\n  const parentType = parent.type;\n  return (\n    (parentType === \"ClassDeclaration\" || parentType === \"ClassExpression\") &&\n    parent.superClass === node\n  );\n};\n\nconst hasPostfixPart = (node: t.Node, parent: t.Node) => {\n  const parentType = parent.type;\n  return (\n    ((parentType === \"MemberExpression\" ||\n      parentType === \"OptionalMemberExpression\") &&\n      parent.object === node) ||\n    ((parentType === \"CallExpression\" ||\n      parentType === \"OptionalCallExpression\" ||\n      parentType === \"NewExpression\") &&\n      parent.callee === node) ||\n    (parentType === \"TaggedTemplateExpression\" && parent.tag === node) ||\n    parentType === \"TSNonNullExpression\"\n  );\n};\n\nexport function NullableTypeAnnotation(\n  node: t.NullableTypeAnnotation,\n  parent: t.Node,\n): boolean {\n  return isArrayTypeAnnotation(parent);\n}\n\nexport function FunctionTypeAnnotation(\n  node: t.FunctionTypeAnnotation,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  const parentType = parent.type;\n  return (\n    // (() => A) | (() => B)\n    parentType === \"UnionTypeAnnotation\" ||\n    // (() => A) & (() => B)\n    parentType === \"IntersectionTypeAnnotation\" ||\n    // (() => A)[]\n    parentType === \"ArrayTypeAnnotation\" ||\n    Boolean(tokenContext & TokenContext.arrowFlowReturnType)\n  );\n}\n\nexport function UpdateExpression(\n  node: t.UpdateExpression,\n  parent: t.Node,\n): boolean {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction needsParenBeforeExpressionBrace(tokenContext: number) {\n  return Boolean(\n    tokenContext & (TokenContext.expressionStatement | TokenContext.arrowBody),\n  );\n}\n\nexport function ObjectExpression(\n  node: t.ObjectExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  return needsParenBeforeExpressionBrace(tokenContext);\n}\n\nexport function DoExpression(\n  node: t.DoExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  // `async do` can start an expression statement\n  return (\n    !node.async && Boolean(tokenContext & TokenContext.expressionStatement)\n  );\n}\n\nexport function Binary(\n  node: t.Binary | t.TSAsExpression | t.TSSatisfiesExpression,\n  parent: t.Node,\n): boolean | undefined {\n  const parentType = parent.type;\n  if (\n    node.type === \"BinaryExpression\" &&\n    node.operator === \"**\" &&\n    parentType === \"BinaryExpression\" &&\n    parent.operator === \"**\"\n  ) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (\n    hasPostfixPart(node, parent) ||\n    parentType === \"UnaryExpression\" ||\n    parentType === \"SpreadElement\" ||\n    parentType === \"AwaitExpression\"\n  ) {\n    return true;\n  }\n\n  const parentPos = getBinaryPrecedence(parent, parentType);\n  if (parentPos != null) {\n    const nodePos = getBinaryPrecedence(node, node.type);\n    if (\n      // Logical expressions with the same precedence don't need parens.\n      (parentPos === nodePos &&\n        parentType === \"BinaryExpression\" &&\n        parent.right === node) ||\n      parentPos > nodePos\n    ) {\n      return true;\n    }\n  }\n\n  return undefined;\n}\n\nexport function UnionTypeAnnotation(\n  node: t.UnionTypeAnnotation,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"ArrayTypeAnnotation\" ||\n    parentType === \"NullableTypeAnnotation\" ||\n    parentType === \"IntersectionTypeAnnotation\" ||\n    parentType === \"UnionTypeAnnotation\"\n  );\n}\n\nexport { UnionTypeAnnotation as IntersectionTypeAnnotation };\n\nexport function OptionalIndexedAccessType(\n  node: t.OptionalIndexedAccessType,\n  parent: t.Node,\n): boolean {\n  return isIndexedAccessType(parent) && parent.objectType === node;\n}\n\nexport function TSAsExpression(\n  node: t.TSAsExpression | t.TSSatisfiesExpression,\n  parent: t.Node,\n): boolean {\n  if (\n    (parent.type === \"AssignmentExpression\" ||\n      parent.type === \"AssignmentPattern\") &&\n    parent.left === node\n  ) {\n    return true;\n  }\n  if (\n    parent.type === \"BinaryExpression\" &&\n    (parent.operator === \"|\" || parent.operator === \"&\") &&\n    node === parent.left\n  ) {\n    return true;\n  }\n  return Binary(node, parent);\n}\n\nexport { TSAsExpression as TSSatisfiesExpression };\n\nexport { UnaryLike as TSTypeAssertion };\n\nexport function TSConditionalType(\n  node: t.TSConditionalType,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  if (\n    parentType === \"TSArrayType\" ||\n    (parentType === \"TSIndexedAccessType\" && parent.objectType === node) ||\n    parentType === \"TSOptionalType\" ||\n    parentType === \"TSTypeOperator\" ||\n    // for `infer K extends (L extends M ? M : ...)`\n    parentType === \"TSTypeParameter\"\n  ) {\n    return true;\n  }\n  if (\n    (parentType === \"TSIntersectionType\" || parentType === \"TSUnionType\") &&\n    parent.types[0] === node\n  ) {\n    return true;\n  }\n  if (\n    parentType === \"TSConditionalType\" &&\n    (parent.checkType === node || parent.extendsType === node)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function TSUnionType(node: t.TSUnionType, parent: t.Node): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"TSIntersectionType\" ||\n    parentType === \"TSTypeOperator\" ||\n    parentType === \"TSArrayType\" ||\n    (parentType === \"TSIndexedAccessType\" && parent.objectType === node) ||\n    parentType === \"TSOptionalType\"\n  );\n}\n\nexport function TSIntersectionType(\n  node: t.TSUnionType,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"TSTypeOperator\" ||\n    parentType === \"TSArrayType\" ||\n    (parentType === \"TSIndexedAccessType\" && parent.objectType === node) ||\n    parentType === \"TSOptionalType\"\n  );\n}\n\nexport function TSInferType(node: t.TSInferType, parent: t.Node): boolean {\n  const parentType = parent.type;\n  if (\n    parentType === \"TSArrayType\" ||\n    (parentType === \"TSIndexedAccessType\" && parent.objectType === node) ||\n    parentType === \"TSOptionalType\"\n  ) {\n    return true;\n  }\n  if (node.typeParameter.constraint) {\n    if (\n      (parentType === \"TSIntersectionType\" || parentType === \"TSUnionType\") &&\n      parent.types[0] === node\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function TSTypeOperator(\n  node: t.TSTypeOperator,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"TSArrayType\" ||\n    (parentType === \"TSIndexedAccessType\" && parent.objectType === node) ||\n    parentType === \"TSOptionalType\"\n  );\n}\n\nexport function TSInstantiationExpression(\n  node: t.TSInstantiationExpression,\n  parent: t.Node,\n) {\n  const parentType = parent.type;\n  return (\n    (parentType === \"CallExpression\" ||\n      parentType === \"OptionalCallExpression\" ||\n      parentType === \"NewExpression\" ||\n      parentType === \"TSInstantiationExpression\") &&\n    !!(process.env.BABEL_8_BREAKING\n      ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n        parent.typeArguments\n      : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        parent.typeParameters)\n  );\n}\n\nexport function TSFunctionType(\n  node: t.TSFunctionType,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"TSIntersectionType\" ||\n    parentType === \"TSUnionType\" ||\n    parentType === \"TSTypeOperator\" ||\n    parentType === \"TSOptionalType\" ||\n    parentType === \"TSArrayType\" ||\n    (parentType === \"TSIndexedAccessType\" && parent.objectType === node) ||\n    (parentType === \"TSConditionalType\" &&\n      (parent.checkType === node || parent.extendsType === node))\n  );\n}\n\nexport { TSFunctionType as TSConstructorType };\n\nexport function BinaryExpression(\n  node: t.BinaryExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  // for ((1 in []);;);\n  // for (var x = (1 in []) in 2);\n  return (\n    node.operator === \"in\" &&\n    Boolean(tokenContext & TokenContext.forInOrInitHeadAccumulate)\n  );\n}\n\nexport function SequenceExpression(\n  node: t.SequenceExpression,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  if (\n    parentType === \"SequenceExpression\" ||\n    parentType === \"ParenthesizedExpression\" ||\n    (parentType === \"MemberExpression\" && parent.property === node) ||\n    (parentType === \"OptionalMemberExpression\" && parent.property === node) ||\n    parentType === \"TemplateLiteral\"\n  ) {\n    return false;\n  }\n  if (parentType === \"ClassDeclaration\") {\n    return true;\n  }\n  if (parentType === \"ForOfStatement\") {\n    return parent.right === node;\n  }\n  if (parentType === \"ExportDefaultDeclaration\") {\n    return true;\n  }\n\n  return !isStatement(parent);\n}\n\nexport function YieldExpression(\n  node: t.YieldExpression,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"BinaryExpression\" ||\n    parentType === \"LogicalExpression\" ||\n    parentType === \"UnaryExpression\" ||\n    parentType === \"SpreadElement\" ||\n    hasPostfixPart(node, parent) ||\n    (parentType === \"AwaitExpression\" && isYieldExpression(node)) ||\n    (parentType === \"ConditionalExpression\" && node === parent.test) ||\n    isClassExtendsClause(node, parent) ||\n    isTSTypeExpression(parentType)\n  );\n}\n\nexport { YieldExpression as AwaitExpression };\n\nexport function ClassExpression(\n  node: t.ClassExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  return Boolean(\n    tokenContext &\n      (TokenContext.expressionStatement | TokenContext.exportDefault),\n  );\n}\n\nexport function UnaryLike(\n  node:\n    | t.UnaryLike\n    | t.TSTypeAssertion\n    | t.ArrowFunctionExpression\n    | t.ConditionalExpression\n    | t.AssignmentExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    hasPostfixPart(node, parent) ||\n    (isBinaryExpression(parent) &&\n      parent.operator === \"**\" &&\n      parent.left === node) ||\n    isClassExtendsClause(node, parent)\n  );\n}\n\nexport function FunctionExpression(\n  node: t.FunctionExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  return Boolean(\n    tokenContext &\n      (TokenContext.expressionStatement | TokenContext.exportDefault),\n  );\n}\n\nexport function ConditionalExpression(\n  node:\n    | t.ConditionalExpression\n    | t.ArrowFunctionExpression\n    | t.AssignmentExpression,\n  parent?: t.Node,\n): boolean {\n  const parentType = parent.type;\n  if (\n    parentType === \"UnaryExpression\" ||\n    parentType === \"SpreadElement\" ||\n    parentType === \"BinaryExpression\" ||\n    parentType === \"LogicalExpression\" ||\n    (parentType === \"ConditionalExpression\" && parent.test === node) ||\n    parentType === \"AwaitExpression\" ||\n    isTSTypeExpression(parentType)\n  ) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nexport { ConditionalExpression as ArrowFunctionExpression };\n\nexport function OptionalMemberExpression(\n  node: t.OptionalMemberExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    (isCallExpression(parent) && parent.callee === node) ||\n    (isMemberExpression(parent) && parent.object === node)\n  );\n}\n\nexport { OptionalMemberExpression as OptionalCallExpression };\n\nexport function AssignmentExpression(\n  node: t.AssignmentExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  if (\n    needsParenBeforeExpressionBrace(tokenContext) &&\n    isObjectPattern(node.left)\n  ) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nexport function LogicalExpression(\n  node: t.LogicalExpression,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  if (isTSTypeExpression(parentType)) return true;\n  if (parentType !== \"LogicalExpression\") return false;\n  switch (node.operator) {\n    case \"||\":\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n    case \"&&\":\n      return parent.operator === \"??\";\n    case \"??\":\n      return parent.operator !== \"??\";\n  }\n}\n\nexport function Identifier(\n  node: t.Identifier,\n  parent: t.Node,\n  tokenContext: number,\n  getRawIdentifier: (node: t.Identifier) => string,\n): boolean {\n  const parentType = parent.type;\n  // 13.15.2 AssignmentExpression RS: Evaluation\n  // (fn) = function () {};\n  if (\n    node.extra?.parenthesized &&\n    parentType === \"AssignmentExpression\" &&\n    parent.left === node\n  ) {\n    const rightType = parent.right.type;\n    if (\n      (rightType === \"FunctionExpression\" || rightType === \"ClassExpression\") &&\n      parent.right.id == null\n    ) {\n      return true;\n    }\n  }\n\n  if (getRawIdentifier && getRawIdentifier(node) !== node.name) {\n    return false;\n  }\n\n  // Non-strict code allows the identifier `let`, but it cannot occur as-is in\n  // certain contexts to avoid ambiguity with contextual keyword `let`.\n  if (node.name === \"let\") {\n    // Some contexts only forbid `let [`, so check if the next token would\n    // be the left bracket of a computed member expression.\n    const isFollowedByBracket =\n      isMemberExpression(parent, {\n        object: node,\n        computed: true,\n      }) ||\n      isOptionalMemberExpression(parent, {\n        object: node,\n        computed: true,\n        optional: false,\n      });\n    if (\n      isFollowedByBracket &&\n      tokenContext &\n        (TokenContext.expressionStatement |\n          TokenContext.forInitHead |\n          TokenContext.forInHead)\n    ) {\n      return true;\n    }\n    return Boolean(tokenContext & TokenContext.forOfHead);\n  }\n\n  // ECMAScript specifically forbids a for-of loop from starting with the\n  // token sequence `for (async of`, because it would be ambiguous with\n  // `for (async of => {};;)`, so we need to add extra parentheses.\n  return (\n    node.name === \"async\" &&\n    isForOfStatement(parent, { left: node, await: false })\n  );\n}\n", "import * as whitespace from \"./whitespace.ts\";\nimport * as parens from \"./parentheses.ts\";\nimport {\n  FLIPPED_ALIAS_KEYS,\n  VISITOR_KEYS,\n  isCallExpression,\n  isDecorator,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression,\n  isParenthesizedExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport type { WhitespaceFlag } from \"./whitespace.ts\";\n\nexport const enum TokenContext {\n  normal = 0,\n  expressionStatement = 1 << 0,\n  arrowBody = 1 << 1,\n  exportDefault = 1 << 2,\n  arrowFlowReturnType = 1 << 3,\n  forInitHead = 1 << 4,\n  forInHead = 1 << 5,\n  forOfHead = 1 << 6,\n  // This flag lives across the token boundary, and will\n  // be reset after forIn or forInit head is printed\n  forInOrInitHeadAccumulate = 1 << 7,\n  forInOrInitHeadAccumulatePassThroughMask = 0x80,\n}\n\ntype NodeHandler<R> = (\n  node: t.Node,\n  // todo:\n  // node: K extends keyof typeof t\n  //   ? Extract<typeof t[K], { type: \"string\" }>\n  //   : t.Node,\n  parent: t.Node,\n  tokenContext?: number,\n  getRawIdentifier?: (node: t.Identifier) => string,\n) => R;\n\nexport type NodeHandlers<R> = {\n  [K in string]?: NodeHandler<R>;\n};\n\nfunction expandAliases<R>(obj: NodeHandlers<R>) {\n  const map = new Map<string, NodeHandler<R>>();\n\n  function add(type: string, func: NodeHandler<R>) {\n    const fn = map.get(type);\n    map.set(\n      type,\n      fn\n        ? function (node, parent, stack, getRawIdentifier) {\n            return (\n              fn(node, parent, stack, getRawIdentifier) ??\n              func(node, parent, stack, getRawIdentifier)\n            );\n          }\n        : func,\n    );\n  }\n\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n\n  return map;\n}\n\n// Rather than using `t.is` on each object property, we pre-expand any type aliases\n// into concrete types so that the 'find' call below can be as fast as possible.\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\n\nfunction isOrHasCallExpression(node: t.Node): boolean {\n  if (isCallExpression(node)) {\n    return true;\n  }\n\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\n\nexport function needsWhitespace(\n  node: t.Node,\n  parent: t.Node,\n  type: WhitespaceFlag,\n): boolean {\n  if (!node) return false;\n\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  const flag = expandedWhitespaceNodes.get(node.type)?.(node, parent);\n\n  if (typeof flag === \"number\") {\n    return (flag & type) !== 0;\n  }\n\n  return false;\n}\n\nexport function needsWhitespaceBefore(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 1);\n}\n\nexport function needsWhitespaceAfter(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 2);\n}\n\nexport function needsParens(\n  node: t.Node,\n  parent: t.Node,\n  tokenContext?: number,\n  getRawIdentifier?: (node: t.Identifier) => string,\n) {\n  if (!parent) return false;\n\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  if (isDecorator(parent)) {\n    return (\n      !isDecoratorMemberExpression(node) &&\n      !(isCallExpression(node) && isDecoratorMemberExpression(node.callee)) &&\n      !isParenthesizedExpression(node)\n    );\n  }\n\n  return expandedParens.get(node.type)?.(\n    node,\n    parent,\n    tokenContext,\n    getRawIdentifier,\n  );\n}\n\nfunction isDecoratorMemberExpression(node: t.Node): boolean {\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n    case \"MemberExpression\":\n      return (\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        isDecoratorMemberExpression(node.object)\n      );\n    default:\n      return false;\n  }\n}\n\nexport function isLastChild(parent: t.Node, child: t.Node) {\n  const visitorKeys = VISITOR_KEYS[parent.type];\n  for (let i = visitorKeys.length - 1; i >= 0; i--) {\n    const val = (parent as any)[visitorKeys[i]] as t.Node | t.Node[] | null;\n    if (val === child) {\n      return true;\n    } else if (Array.isArray(val)) {\n      let j = val.length - 1;\n      while (j >= 0 && val[j] === null) j--;\n      return j >= 0 && val[j] === child;\n    } else if (val) {\n      return false;\n    }\n  }\n  return false;\n}\n", "import type * as t from \"@babel/types\";\nimport type { Token } from \"@babel/parser\";\n\nimport { traverseFast, VISITOR_KEYS } from \"@babel/types\";\n\nexport class TokenMap {\n  _tokens: Token[];\n  _source: string;\n\n  _nodesToTokenIndexes: Map<t.Node, number[]> = new Map();\n  _nodesOccurrencesCountCache: Map<\n    t.Node,\n    { test: string; count: number; i: number }\n  > = new Map();\n\n  _tokensCache = new Map<t.Node, { first: number; last: number }>();\n\n  constructor(ast: t.Node, tokens: Token[], source: string) {\n    this._tokens = tokens;\n    this._source = source;\n\n    traverseFast(ast, node => {\n      const indexes = this._getTokensIndexesOfNode(node);\n      if (indexes.length > 0) this._nodesToTokenIndexes.set(node, indexes);\n    });\n\n    this._tokensCache = null;\n  }\n\n  has(node: t.Node): boolean {\n    return this._nodesToTokenIndexes.has(node);\n  }\n\n  getIndexes(node: t.Node): readonly number[] | undefined {\n    return this._nodesToTokenIndexes.get(node);\n  }\n\n  find(\n    node: t.Node,\n    condition: (token: Token, index: number) => boolean,\n  ): Token | null {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      for (let k = 0; k < indexes.length; k++) {\n        const index = indexes[k];\n        const tok = this._tokens[index];\n        if (condition(tok, index)) return tok;\n      }\n    }\n    return null;\n  }\n\n  findLastIndex(\n    node: t.Node,\n    condition: (token: Token, index: number) => boolean,\n  ): number {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      for (let k = indexes.length - 1; k >= 0; k--) {\n        const index = indexes[k];\n        const tok = this._tokens[index];\n        if (condition(tok, index)) return index;\n      }\n    }\n    return -1;\n  }\n\n  findMatching(\n    node: t.Node,\n    test: string,\n    occurrenceCount: number = 0,\n  ): Token | null {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      let i = 0;\n      const count = occurrenceCount;\n\n      // To avoid O(n^2) search when printing lists (such as arrays), we\n      // cache the last index of a given token for a given occurrence count.\n      // If then we are asked to find the next occurrence of the same token,\n      // we start from the index of the previously found token.\n      // This cache only kicks in after 2 tokens of the same type, to avoid\n      // overhead in the simple case of having unique tokens per node.\n      if (count > 1) {\n        const cache = this._nodesOccurrencesCountCache.get(node);\n        if (cache && cache.test === test && cache.count < count) {\n          i = cache.i + 1;\n          occurrenceCount -= cache.count + 1;\n        }\n      }\n\n      for (; i < indexes.length; i++) {\n        const tok = this._tokens[indexes[i]];\n        if (this.matchesOriginal(tok, test)) {\n          if (occurrenceCount === 0) {\n            if (count > 0) {\n              this._nodesOccurrencesCountCache.set(node, { test, count, i });\n            }\n            return tok;\n          }\n          occurrenceCount--;\n        }\n      }\n    }\n    return null;\n  }\n\n  matchesOriginal(token: Token, test: string) {\n    if (token.end - token.start !== test.length) return false;\n    if (token.value != null) return token.value === test;\n    return this._source.startsWith(test, token.start);\n  }\n\n  startMatches(node: t.Node, test: string): boolean {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (!indexes) return false;\n    const tok = this._tokens[indexes[0]];\n    if (tok.start !== node.start) return false;\n    return this.matchesOriginal(tok, test);\n  }\n\n  endMatches(node: t.Node, test: string): boolean {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (!indexes) return false;\n    const tok = this._tokens[indexes[indexes.length - 1]];\n    if (tok.end !== node.end) return false;\n    return this.matchesOriginal(tok, test);\n  }\n\n  _getTokensIndexesOfNode(node: t.Node): number[] {\n    if (node.start == null || node.end == null) return [];\n\n    const { first, last } = this._findTokensOfNode(\n      node,\n      0,\n      this._tokens.length - 1,\n    );\n\n    let low = first;\n\n    const children = childrenIterator(node);\n\n    if (\n      (node.type === \"ExportNamedDeclaration\" ||\n        node.type === \"ExportDefaultDeclaration\") &&\n      node.declaration &&\n      node.declaration.type === \"ClassDeclaration\"\n    ) {\n      // Exported class declarations can be not properly nested inside\n      // the export declaration that contains them. For example, in\n      // `@dec export class Foo {}` the `export` is covered by the\n      // ClassDeclaration range. Skip the class declaration from the list\n      // of children to skip, so that when looking for `export` we also\n      // traverse its tokens.\n      children.next();\n    }\n\n    const indexes = [];\n\n    for (const child of children) {\n      if (child == null) continue;\n      if (child.start == null || child.end == null) continue;\n\n      const childTok = this._findTokensOfNode(child, low, last);\n\n      const high = childTok.first;\n      for (let k = low; k < high; k++) indexes.push(k);\n\n      low = childTok.last + 1;\n    }\n\n    for (let k = low; k <= last; k++) indexes.push(k);\n\n    return indexes;\n  }\n\n  _findTokensOfNode(node: t.Node, low: number, high: number) {\n    const cached = this._tokensCache.get(node);\n    if (cached) return cached;\n\n    const first = this._findFirstTokenOfNode(node.start, low, high);\n    const last = this._findLastTokenOfNode(node.end, first, high);\n\n    this._tokensCache.set(node, { first, last });\n    return { first, last };\n  }\n\n  _findFirstTokenOfNode(start: number, low: number, high: number): number {\n    while (low <= high) {\n      const mid = (high + low) >> 1;\n      if (start < this._tokens[mid].start) {\n        high = mid - 1;\n      } else if (start > this._tokens[mid].start) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n    return low;\n  }\n\n  _findLastTokenOfNode(end: number, low: number, high: number): number {\n    while (low <= high) {\n      const mid = (high + low) >> 1;\n      if (end < this._tokens[mid].end) {\n        high = mid - 1;\n      } else if (end > this._tokens[mid].end) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n    return high;\n  }\n}\n\nfunction* childrenIterator(node: t.Node) {\n  // We need special handling to iterate TemplateLiteral\n  // children in order, since the two lists are interleaved.\n  if (node.type === \"TemplateLiteral\") {\n    yield node.quasis[0];\n    for (let i = 1; i < node.quasis.length; i++) {\n      yield node.expressions[i - 1];\n      yield node.quasis[i];\n    }\n    return;\n  }\n\n  const keys = VISITOR_KEYS[node.type];\n  for (const key of keys) {\n    const child = (node as any)[key];\n    if (!child) continue;\n    if (Array.isArray(child)) {\n      yield* child;\n    } else {\n      yield child;\n    }\n  }\n}\n", "import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function TaggedTemplateExpression(\n  this: Printer,\n  node: t.TaggedTemplateExpression,\n) {\n  this.print(node.tag);\n  if (process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n    this.print(node.typeArguments);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n    this.print(node.typeParameters);\n  }\n  this.print(node.quasi);\n}\n\nexport function TemplateElement(this: Printer) {\n  throw new Error(\"TemplateElement printing is handled in TemplateLiteral\");\n}\n\nexport type TemplateLiteralBase = t.Node & {\n  quasis: t.TemplateElement[];\n};\n\nexport function _printTemplate<T extends t.Node>(\n  this: Printer,\n  node: TemplateLiteralBase,\n  substitutions: T[],\n) {\n  const quasis = node.quasis;\n  let partRaw = \"`\";\n  for (let i = 0; i < quasis.length - 1; i++) {\n    partRaw += quasis[i].value.raw;\n    this.token(partRaw + \"${\", true);\n    this.print(substitutions[i]);\n    partRaw = \"}\";\n\n    // In Babel 7 we have individual tokens for ${ and }, so the automatic\n    // catchup logic does not work. Manually look for those tokens.\n    if (!process.env.BABEL_8_BREAKING && this.tokenMap) {\n      const token = this.tokenMap.findMatching(node, \"}\", i);\n      if (token) this._catchUpTo(token.loc.start);\n    }\n  }\n  partRaw += quasis[quasis.length - 1].value.raw;\n  this.token(partRaw + \"`\", true);\n}\n\nexport function TemplateLiteral(this: Printer, node: t.TemplateLiteral) {\n  this._printTemplate(node, node.expressions);\n}\n", "import type Printer from \"../printer.ts\";\nimport {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression,\n  isPattern,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function UnaryExpression(this: Printer, node: t.UnaryExpression) {\n  const { operator } = node;\n  if (\n    operator === \"void\" ||\n    operator === \"delete\" ||\n    operator === \"typeof\" ||\n    // throwExpressions\n    operator === \"throw\"\n  ) {\n    this.word(operator);\n    this.space();\n  } else {\n    this.token(operator);\n  }\n\n  this.print(node.argument);\n}\n\nexport function DoExpression(this: Printer, node: t.DoExpression) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  this.word(\"do\");\n  this.space();\n  this.print(node.body);\n}\n\nexport function ParenthesizedExpression(\n  this: Printer,\n  node: t.ParenthesizedExpression,\n) {\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.print(node.expression);\n  exit();\n  this.rightParens(node);\n}\n\nexport function UpdateExpression(this: Printer, node: t.UpdateExpression) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument);\n  } else {\n    this.print(node.argument, true);\n    this.token(node.operator);\n  }\n}\n\nexport function ConditionalExpression(\n  this: Printer,\n  node: t.ConditionalExpression,\n) {\n  this.print(node.test);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.consequent);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.alternate);\n}\n\nexport function NewExpression(\n  this: Printer,\n  node: t.NewExpression,\n  parent: t.Node,\n) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee);\n  if (\n    this.format.minified &&\n    node.arguments.length === 0 &&\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    !node.optional &&\n    !isCallExpression(parent, { callee: node }) &&\n    !isMemberExpression(parent) &&\n    !isNewExpression(parent)\n  ) {\n    return;\n  }\n\n  this.print(node.typeArguments);\n  if (!process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    this.print(node.typeParameters); // Legacy TS AST\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    if (node.optional) {\n      this.token(\"?.\");\n    }\n  }\n\n  if (\n    node.arguments.length === 0 &&\n    this.tokenMap &&\n    !this.tokenMap.endMatches(node, \")\")\n  ) {\n    return;\n  }\n\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments, this.shouldPrintTrailingComma(\")\"));\n  exit();\n  this.rightParens(node);\n}\n\nexport function SequenceExpression(this: Printer, node: t.SequenceExpression) {\n  this.printList(node.expressions);\n}\n\nexport function ThisExpression(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function Super(this: Printer) {\n  this.word(\"super\");\n}\n\nexport function _shouldPrintDecoratorsBeforeExport(\n  this: Printer,\n  node: t.ExportDeclaration & { declaration: t.ClassDeclaration },\n) {\n  if (typeof this.format.decoratorsBeforeExport === \"boolean\") {\n    return this.format.decoratorsBeforeExport;\n  }\n  return (\n    typeof node.start === \"number\" && node.start === node.declaration.start\n  );\n}\n\nexport function Decorator(this: Printer, node: t.Decorator) {\n  this.token(\"@\");\n  this.print(node.expression);\n  this.newline();\n}\n\nexport function OptionalMemberExpression(\n  this: Printer,\n  node: t.OptionalMemberExpression,\n) {\n  let { computed } = node;\n  const { optional, property } = node;\n\n  this.print(node.object);\n\n  if (!computed && isMemberExpression(property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  // @ts-expect-error todo(flow->ts) maybe instead of typeof check specific literal types?\n  if (isLiteral(property) && typeof property.value === \"number\") {\n    computed = true;\n  }\n  if (optional) {\n    this.token(\"?.\");\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(property);\n    this.token(\"]\");\n  } else {\n    if (!optional) {\n      this.token(\".\");\n    }\n    this.print(property);\n  }\n}\n\nexport function OptionalCallExpression(\n  this: Printer,\n  node: t.OptionalCallExpression,\n) {\n  this.print(node.callee);\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    this.print(node.typeParameters); // legacy TS AST\n  }\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.print(node.typeArguments);\n\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments);\n  exit();\n  this.rightParens(node);\n}\n\nexport function CallExpression(this: Printer, node: t.CallExpression) {\n  this.print(node.callee);\n\n  this.print(node.typeArguments);\n  if (!process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    this.print(node.typeParameters); // legacy TS AST\n  }\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments, this.shouldPrintTrailingComma(\")\"));\n  exit();\n  this.rightParens(node);\n}\n\nexport function Import(this: Printer) {\n  this.word(\"import\");\n}\n\nexport function AwaitExpression(this: Printer, node: t.AwaitExpression) {\n  this.word(\"await\");\n  this.space();\n  this.print(node.argument);\n}\n\nexport function YieldExpression(this: Printer, node: t.YieldExpression) {\n  if (node.delegate) {\n    this.word(\"yield\", true);\n    this.token(\"*\");\n    if (node.argument) {\n      this.space();\n      // line terminators are allowed after yield*\n      this.print(node.argument);\n    }\n  } else if (node.argument) {\n    this.word(\"yield\", true);\n    this.space();\n    this.print(node.argument);\n  } else {\n    this.word(\"yield\");\n  }\n}\n\nexport function EmptyStatement(this: Printer) {\n  this.semicolon(true /* force */);\n}\n\nexport function ExpressionStatement(\n  this: Printer,\n  node: t.ExpressionStatement,\n) {\n  this.tokenContext |= TokenContext.expressionStatement;\n  this.print(node.expression);\n  this.semicolon();\n}\n\nexport function AssignmentPattern(this: Printer, node: t.AssignmentPattern) {\n  this.print(node.left);\n  if (node.left.type === \"Identifier\" || isPattern(node.left)) {\n    if (node.left.optional) this.token(\"?\");\n    this.print(node.left.typeAnnotation);\n  }\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right);\n}\n\nexport function AssignmentExpression(\n  this: Printer,\n  node: t.AssignmentExpression | t.BinaryExpression | t.LogicalExpression,\n) {\n  this.print(node.left);\n\n  this.space();\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n    this._endsWithDiv = node.operator === \"/\";\n  }\n  this.space();\n\n  this.print(node.right);\n}\n\nexport function BindExpression(this: Printer, node: t.BindExpression) {\n  this.print(node.object);\n  this.token(\"::\");\n  this.print(node.callee);\n}\n\nexport {\n  AssignmentExpression as BinaryExpression,\n  AssignmentExpression as LogicalExpression,\n};\n\nexport function MemberExpression(this: Printer, node: t.MemberExpression) {\n  this.print(node.object);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n  // @ts-expect-error todo(flow->ts) maybe use specific literal types\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (computed) {\n    const exit = this.enterDelimited();\n    this.token(\"[\");\n    this.print(node.property);\n    this.token(\"]\");\n    exit();\n  } else {\n    this.token(\".\");\n    this.print(node.property);\n  }\n}\n\nexport function MetaProperty(this: Printer, node: t.MetaProperty) {\n  this.print(node.meta);\n  this.token(\".\");\n  this.print(node.property);\n}\n\nexport function PrivateName(this: Printer, node: t.PrivateName) {\n  this.token(\"#\");\n  this.print(node.id);\n}\n\nexport function V8IntrinsicIdentifier(\n  this: Printer,\n  node: t.V8IntrinsicIdentifier,\n) {\n  this.token(\"%\");\n  this.word(node.name);\n}\n\nexport function ModuleExpression(this: Printer, node: t.ModuleExpression) {\n  this.word(\"module\", true);\n  this.space();\n  this.token(\"{\");\n  this.indent();\n  const { body } = node;\n  if (body.body.length || body.directives.length) {\n    this.newline();\n  }\n  this.print(body);\n  this.dedent();\n  this.rightBrace(node);\n}\n", "import type Printer from \"../printer.ts\";\nimport {\n  isFor,\n  isForStatement,\n  isIfStatement,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nexport function WithStatement(this: Printer, node: t.WithStatement) {\n  this.word(\"with\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.object);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport function IfStatement(this: Printer, node: t.IfStatement) {\n  this.word(\"if\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.space();\n\n  const needsBlock =\n    node.alternate && isIfStatement(getLastStatement(node.consequent));\n  if (needsBlock) {\n    this.token(\"{\");\n    this.newline();\n    this.indent();\n  }\n\n  this.printAndIndentOnComments(node.consequent);\n\n  if (needsBlock) {\n    this.dedent();\n    this.newline();\n    this.token(\"}\");\n  }\n\n  if (node.alternate) {\n    if (this.endsWith(charCodes.rightCurlyBrace)) this.space();\n    this.word(\"else\");\n    this.space();\n    this.printAndIndentOnComments(node.alternate);\n  }\n}\n\n// Recursively get the last statement.\nfunction getLastStatement(statement: t.Statement): t.Statement {\n  // @ts-expect-error: If statement.body is empty or not a Node, isStatement will return false\n  const { body } = statement;\n  if (isStatement(body) === false) {\n    return statement;\n  }\n\n  return getLastStatement(body);\n}\n\nexport function ForStatement(this: Printer, node: t.ForStatement) {\n  this.word(\"for\");\n  this.space();\n  this.token(\"(\");\n\n  {\n    const exit = this.enterForStatementInit();\n    this.print(node.init);\n    exit();\n  }\n\n  this.token(\";\");\n\n  if (node.test) {\n    this.space();\n    this.print(node.test);\n  }\n  this.token(\";\", false, 1);\n\n  if (node.update) {\n    this.space();\n    this.print(node.update);\n  }\n\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport function WhileStatement(this: Printer, node: t.WhileStatement) {\n  this.word(\"while\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nfunction ForXStatement(this: Printer, node: t.ForXStatement) {\n  this.word(\"for\");\n  this.space();\n  const isForOf = node.type === \"ForOfStatement\";\n  if (isForOf && node.await) {\n    this.word(\"await\");\n    this.space();\n  }\n  this.noIndentInnerCommentsHere();\n  this.token(\"(\");\n  {\n    const exit = this.enterForXStatementInit(isForOf);\n    this.print(node.left);\n    exit?.();\n  }\n  this.space();\n  this.word(isForOf ? \"of\" : \"in\");\n  this.space();\n  this.print(node.right);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport const ForInStatement = ForXStatement;\nexport const ForOfStatement = ForXStatement;\n\nexport function DoWhileStatement(this: Printer, node: t.DoWhileStatement) {\n  this.word(\"do\");\n  this.space();\n  this.print(node.body);\n  this.space();\n  this.word(\"while\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.semicolon();\n}\n\nfunction printStatementAfterKeyword(printer: Printer, node: t.Node) {\n  if (node) {\n    printer.space();\n    printer.printTerminatorless(node);\n  }\n\n  printer.semicolon();\n}\n\nexport function BreakStatement(this: Printer, node: t.ContinueStatement) {\n  this.word(\"break\");\n  printStatementAfterKeyword(this, node.label);\n}\n\nexport function ContinueStatement(this: Printer, node: t.ContinueStatement) {\n  this.word(\"continue\");\n  printStatementAfterKeyword(this, node.label);\n}\n\nexport function ReturnStatement(this: Printer, node: t.ReturnStatement) {\n  this.word(\"return\");\n  printStatementAfterKeyword(this, node.argument);\n}\n\nexport function ThrowStatement(this: Printer, node: t.ThrowStatement) {\n  this.word(\"throw\");\n  printStatementAfterKeyword(this, node.argument);\n}\n\nexport function LabeledStatement(this: Printer, node: t.LabeledStatement) {\n  this.print(node.label);\n  this.token(\":\");\n  this.space();\n  this.print(node.body);\n}\n\nexport function TryStatement(this: Printer, node: t.TryStatement) {\n  this.word(\"try\");\n  this.space();\n  this.print(node.block);\n  this.space();\n\n  // Esprima bug puts the catch clause in a `handlers` array.\n  // see https://code.google.com/p/esprima/issues/detail?id=433\n  // We run into this from regenerator generated ast.\n  // @ts-expect-error todo(flow->ts) should ast node type be updated to support this?\n  if (node.handlers) {\n    // @ts-expect-error todo(flow->ts) should ast node type be updated to support this?\n    this.print(node.handlers[0]);\n  } else {\n    this.print(node.handler);\n  }\n\n  if (node.finalizer) {\n    this.space();\n    this.word(\"finally\");\n    this.space();\n    this.print(node.finalizer);\n  }\n}\n\nexport function CatchClause(this: Printer, node: t.CatchClause) {\n  this.word(\"catch\");\n  this.space();\n  if (node.param) {\n    this.token(\"(\");\n    this.print(node.param);\n    this.print(node.param.typeAnnotation);\n    this.token(\")\");\n    this.space();\n  }\n  this.print(node.body);\n}\n\nexport function SwitchStatement(this: Printer, node: t.SwitchStatement) {\n  this.word(\"switch\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.discriminant);\n  this.token(\")\");\n  this.space();\n  this.token(\"{\");\n\n  this.printSequence(\n    node.cases,\n    true,\n    undefined,\n    function addNewlines(leading, cas) {\n      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;\n    },\n  );\n\n  this.rightBrace(node);\n}\n\nexport function SwitchCase(this: Printer, node: t.SwitchCase) {\n  if (node.test) {\n    this.word(\"case\");\n    this.space();\n    this.print(node.test);\n    this.token(\":\");\n  } else {\n    this.word(\"default\");\n    this.token(\":\");\n  }\n\n  if (node.consequent.length) {\n    this.newline();\n    this.printSequence(node.consequent, true);\n  }\n}\n\nexport function DebuggerStatement(this: Printer) {\n  this.word(\"debugger\");\n  this.semicolon();\n}\n\nexport function VariableDeclaration(\n  this: Printer,\n  node: t.VariableDeclaration,\n  parent: t.Node,\n) {\n  if (node.declare) {\n    // TS\n    this.word(\"declare\");\n    this.space();\n  }\n\n  const { kind } = node;\n  if (kind === \"await using\") {\n    this.word(\"await\");\n    this.space();\n    this.word(\"using\", true);\n  } else {\n    this.word(kind, kind === \"using\");\n  }\n  this.space();\n\n  let hasInits = false;\n  // don't add whitespace to loop heads\n  if (!isFor(parent)) {\n    for (const declar of node.declarations) {\n      if (declar.init) {\n        // has an init so let's split it up over multiple lines\n        hasInits = true;\n      }\n    }\n  }\n\n  //\n  // use a pretty separator when we aren't in compact mode, have initializers and don't have retainLines on\n  // this will format declarations like:\n  //\n  //   let foo = \"bar\", bar = \"foo\";\n  //\n  // into\n  //\n  //   let foo = \"bar\",\n  //       bar = \"foo\";\n  //\n\n  this.printList(\n    node.declarations,\n    undefined,\n    undefined,\n    node.declarations.length > 1,\n    hasInits\n      ? function (this: Printer, occurrenceCount: number) {\n          this.token(\",\", false, occurrenceCount);\n          this.newline();\n        }\n      : undefined,\n  );\n\n  if (isFor(parent)) {\n    // don't give semicolons to these nodes since they'll be inserted in the parent generator\n    if (isForStatement(parent)) {\n      if (parent.init === node) return;\n    } else {\n      if (parent.left === node) return;\n    }\n  }\n\n  this.semicolon();\n}\n\nexport function VariableDeclarator(this: Printer, node: t.VariableDeclarator) {\n  this.print(node.id);\n  if (node.definite) this.token(\"!\"); // TS\n  // @ts-ignore(Babel 7 vs Babel 8) Property 'typeAnnotation' does not exist on type 'MemberExpression'.\n  this.print(node.id.typeAnnotation);\n  if (node.init) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.init);\n  }\n}\n", "import type Printer from \"../printer.ts\";\nimport {\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nexport function ClassDeclaration(\n  this: Printer,\n  node: t.ClassDeclaration,\n  parent: t.Node,\n) {\n  const inExport =\n    isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);\n\n  if (\n    !inExport ||\n    !this._shouldPrintDecoratorsBeforeExport(\n      parent as t.ExportDeclaration & { declaration: t.ClassDeclaration },\n    )\n  ) {\n    this.printJoin(node.decorators);\n  }\n\n  if (node.declare) {\n    // TS\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    // TS\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  this.word(\"class\");\n\n  if (node.id) {\n    this.space();\n    this.print(node.id);\n  }\n\n  this.print(node.typeParameters);\n\n  if (node.superClass) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.superClass);\n    this.print(\n      process.env.BABEL_8_BREAKING\n        ? // @ts-ignore(Babel 7 vs Babel 8) Renamed\n          node.superTypeArguments\n        : // @ts-ignore(Babel 7 vs Babel 8) Renamed\n          node.superTypeParameters,\n    );\n  }\n\n  if (node.implements) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements);\n  }\n\n  this.space();\n  this.print(node.body);\n}\n\nexport { ClassDeclaration as ClassExpression };\n\nexport function ClassBody(this: Printer, node: t.ClassBody) {\n  this.token(\"{\");\n  if (node.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    this.newline();\n\n    const separator = classBodyEmptySemicolonsPrinter(this, node);\n    separator?.(-1); // print leading semicolons in preserveFormat mode\n\n    const exit = this.enterDelimited();\n    this.printJoin(node.body, true, true, separator, true);\n    exit();\n\n    if (!this.endsWith(charCodes.lineFeed)) this.newline();\n\n    this.rightBrace(node);\n  }\n}\n\nfunction classBodyEmptySemicolonsPrinter(printer: Printer, node: t.ClassBody) {\n  if (!printer.tokenMap || node.start == null || node.end == null) {\n    return null;\n  }\n\n  // \"empty statements\" in class bodies are not represented in the AST.\n  // Print them by checking if there are any ; tokens between the current AST\n  // member and the next one.\n\n  const indexes = printer.tokenMap.getIndexes(node);\n  if (!indexes) return null;\n\n  let k = 1; // start from 1 to skip '{'\n\n  let occurrenceCount = 0;\n\n  let nextLocIndex = 0;\n  const advanceNextLocIndex = () => {\n    while (\n      nextLocIndex < node.body.length &&\n      node.body[nextLocIndex].start == null\n    ) {\n      nextLocIndex++;\n    }\n  };\n  advanceNextLocIndex();\n\n  return (i: number) => {\n    if (nextLocIndex <= i) {\n      nextLocIndex = i + 1;\n      advanceNextLocIndex();\n    }\n\n    const end =\n      nextLocIndex === node.body.length\n        ? node.end\n        : node.body[nextLocIndex].start;\n\n    let tok;\n    while (\n      k < indexes.length &&\n      printer.tokenMap.matchesOriginal(\n        (tok = printer._tokens[indexes[k]]),\n        \";\",\n      ) &&\n      tok.start < end\n    ) {\n      printer.token(\";\", undefined, occurrenceCount++);\n      k++;\n    }\n  };\n}\n\nexport function ClassProperty(this: Printer, node: t.ClassProperty) {\n  this.printJoin(node.decorators);\n\n  if (!node.static && !this.format.preserveFormat) {\n    // catch up to property key, avoid line break\n    // between member TS modifiers and the property key.\n    const endLine = node.key.loc?.end?.line;\n    if (endLine) this.catchUp(endLine);\n  }\n\n  this.tsPrintClassMemberModifiers(node);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    this._variance(node);\n    this.print(node.key);\n  }\n\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassAccessorProperty(\n  this: Printer,\n  node: t.ClassAccessorProperty,\n) {\n  this.printJoin(node.decorators);\n\n  // catch up to property key, avoid line break\n  // between member modifiers and the property key.\n  const endLine = node.key.loc?.end?.line;\n  if (endLine) this.catchUp(endLine);\n\n  // TS does not support class accessor property yet\n  this.tsPrintClassMemberModifiers(node);\n\n  this.word(\"accessor\", true);\n  this.space();\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    // Todo: Flow does not support class accessor property yet.\n    this._variance(node);\n    this.print(node.key);\n  }\n\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassPrivateProperty(\n  this: Printer,\n  node: t.ClassPrivateProperty,\n) {\n  this.printJoin(node.decorators);\n  this.tsPrintClassMemberModifiers(node);\n  this.print(node.key);\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassMethod(this: Printer, node: t.ClassMethod) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function ClassPrivateMethod(this: Printer, node: t.ClassPrivateMethod) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function _classMethodHead(\n  this: Printer,\n  node: t.ClassMethod | t.ClassPrivateMethod | t.TSDeclareMethod,\n) {\n  this.printJoin(node.decorators);\n\n  if (!this.format.preserveFormat) {\n    // catch up to method key, avoid line break\n    // between member modifiers/method heads and the method key.\n    const endLine = node.key.loc?.end?.line;\n    if (endLine) this.catchUp(endLine);\n  }\n\n  this.tsPrintClassMemberModifiers(node);\n  this._methodHead(node);\n}\n\nexport function StaticBlock(this: Printer, node: t.StaticBlock) {\n  this.word(\"static\");\n  this.space();\n  this.token(\"{\");\n  if (node.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    this.newline();\n    this.printSequence(node.body, true);\n    this.rightBrace(node);\n  }\n}\n", "import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\nimport { isIdentifier, type ParentMaps } from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\n\ntype ParentsOf<T extends t.Node> = ParentMaps[T[\"type\"]];\n\nexport function _params(\n  this: Printer,\n  node: t.Function | t.TSDeclareMethod | t.TSDeclareFunction,\n  idNode: t.Expression | t.PrivateName,\n  parentNode: ParentsOf<typeof node>,\n) {\n  this.print(node.typeParameters);\n\n  const nameInfo = _getFuncIdName.call(this, idNode, parentNode);\n  if (nameInfo) {\n    this.sourceIdentifierName(nameInfo.name, nameInfo.pos);\n  }\n\n  this.token(\"(\");\n  this._parameters(node.params, \")\");\n\n  const noLineTerminator = node.type === \"ArrowFunctionExpression\";\n  this.print(node.returnType, noLineTerminator);\n\n  this._noLineTerminator = noLineTerminator;\n}\n\nexport function _parameters(\n  this: Printer,\n  parameters: t.Function[\"params\"],\n  endToken: string,\n) {\n  const exit = this.enterDelimited();\n\n  const trailingComma = this.shouldPrintTrailingComma(endToken);\n\n  const paramLength = parameters.length;\n  for (let i = 0; i < paramLength; i++) {\n    this._param(parameters[i]);\n\n    if (trailingComma || i < paramLength - 1) {\n      this.token(\",\", null, i);\n      this.space();\n    }\n  }\n\n  this.token(endToken);\n  exit();\n}\n\nexport function _param(\n  this: Printer,\n  parameter: t.Identifier | t.RestElement | t.Pattern | t.TSParameterProperty,\n) {\n  // @ts-expect-error decorators is not in VoidPattern\n  this.printJoin(parameter.decorators);\n  this.print(parameter);\n  if (\n    // @ts-expect-error optional is not in TSParameterProperty\n    parameter.optional\n  ) {\n    this.token(\"?\"); // TS / flow\n  }\n\n  this.print(\n    // @ts-expect-error typeAnnotation is not in TSParameterProperty\n    parameter.typeAnnotation,\n  ); // TS / flow\n}\n\nexport function _methodHead(this: Printer, node: t.Method | t.TSDeclareMethod) {\n  const kind = node.kind;\n  const key = node.key;\n\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  if (\n    kind === \"method\" ||\n    // @ts-expect-error Fixme: kind: \"init\" is not defined\n    kind === \"init\"\n  ) {\n    if (node.generator) {\n      this.token(\"*\");\n    }\n  }\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(key);\n    this.token(\"]\");\n  } else {\n    this.print(key);\n  }\n\n  if (\n    // @ts-expect-error optional is not in ObjectMethod\n    node.optional\n  ) {\n    // TS\n    this.token(\"?\");\n  }\n\n  this._params(\n    node,\n    node.computed && node.key.type !== \"StringLiteral\" ? undefined : node.key,\n    undefined,\n  );\n}\n\nexport function _predicate(\n  this: Printer,\n  node:\n    | t.FunctionDeclaration\n    | t.FunctionExpression\n    | t.ArrowFunctionExpression,\n  noLineTerminatorAfter?: boolean,\n) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.token(\":\");\n    }\n    this.space();\n    this.print(node.predicate, noLineTerminatorAfter);\n  }\n}\n\nexport function _functionHead(\n  this: Printer,\n  node: t.FunctionDeclaration | t.FunctionExpression | t.TSDeclareFunction,\n  parent: ParentsOf<typeof node>,\n) {\n  if (node.async) {\n    this.word(\"async\");\n    if (!this.format.preserveFormat) {\n      // We prevent inner comments from being printed here,\n      // so that they are always consistently printed in the\n      // same place regardless of the function type.\n      this._endsWithInnerRaw = false;\n    }\n    this.space();\n  }\n  this.word(\"function\");\n  if (node.generator) {\n    if (!this.format.preserveFormat) {\n      // We prevent inner comments from being printed here,\n      // so that they are always consistently printed in the\n      // same place regardless of the function type.\n      this._endsWithInnerRaw = false;\n    }\n    this.token(\"*\");\n  }\n\n  this.space();\n  if (node.id) {\n    this.print(node.id);\n  }\n\n  this._params(node, node.id, parent);\n  if (node.type !== \"TSDeclareFunction\") {\n    this._predicate(node);\n  }\n}\n\nexport function FunctionExpression(\n  this: Printer,\n  node: t.FunctionExpression,\n  parent: ParentsOf<typeof node>,\n) {\n  this._functionHead(node, parent);\n  this.space();\n  this.print(node.body);\n}\n\nexport { FunctionExpression as FunctionDeclaration };\n\nexport function ArrowFunctionExpression(\n  this: Printer,\n  node: t.ArrowFunctionExpression,\n  parent: ParentsOf<typeof node>,\n) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  if (this._shouldPrintArrowParamsParens(node)) {\n    this._params(node, undefined, parent);\n  } else {\n    this.print(node.params[0], true);\n  }\n\n  this._predicate(node, true);\n  this.space();\n  // When printing (x)/*1*/=>{}, we remove the parentheses\n  // and thus there aren't two contiguous inner tokens.\n  // We forcefully print inner comments here.\n  this.printInnerComments();\n  this.token(\"=>\");\n\n  this.space();\n\n  this.tokenContext |= TokenContext.arrowBody;\n  this.print(node.body);\n}\n\n// Try to avoid printing parens in simple cases, but only if we're pretty\n// sure that they aren't needed by type annotations or potential newlines.\nexport function _shouldPrintArrowParamsParens(\n  this: Printer,\n  node: t.ArrowFunctionExpression,\n): boolean {\n  if (node.params.length !== 1) return true;\n\n  if (node.typeParameters || node.returnType || node.predicate) {\n    return true;\n  }\n\n  const firstParam = node.params[0];\n  if (\n    !isIdentifier(firstParam) ||\n    firstParam.typeAnnotation ||\n    firstParam.optional ||\n    // Flow does not support `foo /*: string*/ => {};`\n    firstParam.leadingComments?.length ||\n    firstParam.trailingComments?.length\n  ) {\n    return true;\n  }\n\n  if (this.tokenMap) {\n    if (node.loc == null) return true;\n    if (this.tokenMap.findMatching(node, \"(\") !== null) return true;\n    const arrowToken = this.tokenMap.findMatching(node, \"=>\");\n    if (arrowToken?.loc == null) return true;\n    return arrowToken.loc.start.line !== node.loc.start.line;\n  }\n\n  if (this.format.retainLines) return true;\n\n  return false;\n}\n\nfunction _getFuncIdName(\n  this: Printer,\n  idNode: t.Expression | t.PrivateName,\n  parent: ParentsOf<t.Function | t.TSDeclareMethod | t.TSDeclareFunction>,\n) {\n  let id: t.Expression | t.PrivateName | t.LVal | t.VoidPattern = idNode;\n\n  if (!id && parent) {\n    const parentType = parent.type;\n\n    if (parentType === \"VariableDeclarator\") {\n      id = parent.id;\n    } else if (\n      parentType === \"AssignmentExpression\" ||\n      parentType === \"AssignmentPattern\"\n    ) {\n      id = parent.left;\n    } else if (\n      parentType === \"ObjectProperty\" ||\n      parentType === \"ClassProperty\"\n    ) {\n      if (!parent.computed || parent.key.type === \"StringLiteral\") {\n        id = parent.key;\n      }\n    } else if (\n      parentType === \"ClassPrivateProperty\" ||\n      parentType === \"ClassAccessorProperty\"\n    ) {\n      id = parent.key;\n    }\n  }\n\n  if (!id) return;\n\n  let nameInfo;\n\n  if (id.type === \"Identifier\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.loc?.identifierName || id.name,\n    };\n  } else if (id.type === \"PrivateName\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: \"#\" + id.id.name,\n    };\n  } else if (id.type === \"StringLiteral\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.value,\n    };\n  }\n\n  return nameInfo;\n}\n", "import type Printer from \"../printer.ts\";\nimport {\n  isClassDeclaration,\n  isExportDefaultSpecifier,\n  isExportNamespaceSpecifier,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function ImportSpecifier(this: Printer, node: t.ImportSpecifier) {\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.word(node.importKind);\n    this.space();\n  }\n\n  this.print(node.imported);\n  // @ts-expect-error todo(flow-ts) maybe check node type instead of relying on name to be undefined on t.StringLiteral\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.local);\n  }\n}\n\nexport function ImportDefaultSpecifier(\n  this: Printer,\n  node: t.ImportDefaultSpecifier,\n) {\n  this.print(node.local);\n}\n\nexport function ExportDefaultSpecifier(\n  this: Printer,\n  node: t.ExportDefaultSpecifier,\n) {\n  this.print(node.exported);\n}\n\nexport function ExportSpecifier(this: Printer, node: t.ExportSpecifier) {\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n\n  this.print(node.local);\n  // @ts-expect-error todo(flow-ts) maybe check node type instead of relying on name to be undefined on t.StringLiteral\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.exported);\n  }\n}\n\nexport function ExportNamespaceSpecifier(\n  this: Printer,\n  node: t.ExportNamespaceSpecifier,\n) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.exported);\n}\n\nlet warningShown = false;\n\nexport function _printAttributes(\n  this: Printer,\n  node: Extract<t.Node, { attributes?: t.ImportAttribute[] }>,\n  hasPreviousBrace: boolean,\n) {\n  const { importAttributesKeyword } = this.format;\n  const { attributes, assertions } = node;\n\n  if (\n    !process.env.BABEL_8_BREAKING &&\n    attributes &&\n    !importAttributesKeyword &&\n    node.extra &&\n    (node.extra.deprecatedAssertSyntax ||\n      node.extra.deprecatedWithLegacySyntax) &&\n    // In the production build only show the warning once.\n    // We want to show it per-usage locally for tests.\n    (!process.env.IS_PUBLISH || !warningShown)\n  ) {\n    warningShown = true;\n    console.warn(`\\\nYou are using import attributes, without specifying the desired output syntax.\nPlease specify the \"importAttributesKeyword\" generator option, whose value can be one of:\n - \"with\"        : \\`import { a } from \"b\" with { type: \"json\" };\\`\n - \"assert\"      : \\`import { a } from \"b\" assert { type: \"json\" };\\`\n - \"with-legacy\" : \\`import { a } from \"b\" with type: \"json\";\\`\n`);\n  }\n\n  const useAssertKeyword =\n    importAttributesKeyword === \"assert\" ||\n    (!importAttributesKeyword && assertions);\n\n  this.word(useAssertKeyword ? \"assert\" : \"with\");\n  this.space();\n\n  if (\n    !process.env.BABEL_8_BREAKING &&\n    !useAssertKeyword &&\n    (importAttributesKeyword === \"with-legacy\" ||\n      (!importAttributesKeyword && node.extra?.deprecatedWithLegacySyntax))\n  ) {\n    // with-legacy\n    this.printList(attributes || assertions);\n    return;\n  }\n\n  const occurrenceCount = hasPreviousBrace ? 1 : 0;\n\n  this.token(\"{\", null, occurrenceCount);\n  this.space();\n  this.printList(attributes || assertions, this.shouldPrintTrailingComma(\"}\"));\n  this.space();\n  this.token(\"}\", null, occurrenceCount);\n}\n\nexport function ExportAllDeclaration(\n  this: Printer,\n  node: t.ExportAllDeclaration | t.DeclareExportAllDeclaration,\n) {\n  this.word(\"export\");\n  this.space();\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.token(\"*\");\n  this.space();\n  this.word(\"from\");\n  this.space();\n  if (node.attributes?.length || node.assertions?.length) {\n    this.print(node.source, true);\n    this.space();\n    this._printAttributes(node, false);\n  } else {\n    this.print(node.source);\n  }\n\n  this.semicolon();\n}\n\nfunction maybePrintDecoratorsBeforeExport(\n  printer: Printer,\n  node: t.ExportNamedDeclaration | t.ExportDefaultDeclaration,\n) {\n  if (\n    isClassDeclaration(node.declaration) &&\n    printer._shouldPrintDecoratorsBeforeExport(\n      node as t.ExportNamedDeclaration & { declaration: t.ClassDeclaration },\n    )\n  ) {\n    printer.printJoin(node.declaration.decorators);\n  }\n}\n\nexport function ExportNamedDeclaration(\n  this: Printer,\n  node: t.ExportNamedDeclaration,\n) {\n  maybePrintDecoratorsBeforeExport(this, node);\n\n  this.word(\"export\");\n  this.space();\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === \"type\") {\n      this.word(\"type\");\n      this.space();\n    }\n\n    const specifiers = node.specifiers.slice(0);\n\n    // print \"special\" specifiers first\n    let hasSpecial = false;\n    for (;;) {\n      const first = specifiers[0];\n      if (\n        isExportDefaultSpecifier(first) ||\n        isExportNamespaceSpecifier(first)\n      ) {\n        hasSpecial = true;\n        this.print(specifiers.shift());\n        if (specifiers.length) {\n          this.token(\",\");\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n\n    let hasBrace = false;\n    if (specifiers.length || (!specifiers.length && !hasSpecial)) {\n      hasBrace = true;\n      this.token(\"{\");\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, this.shouldPrintTrailingComma(\"}\"));\n        this.space();\n      }\n      this.token(\"}\");\n    }\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      if (node.attributes?.length || node.assertions?.length) {\n        this.print(node.source, true);\n        this.space();\n        this._printAttributes(node, hasBrace);\n      } else {\n        this.print(node.source);\n      }\n    }\n\n    this.semicolon();\n  }\n}\n\nexport function ExportDefaultDeclaration(\n  this: Printer,\n  node: t.ExportDefaultDeclaration,\n) {\n  maybePrintDecoratorsBeforeExport(this, node);\n\n  this.word(\"export\");\n  this.noIndentInnerCommentsHere();\n  this.space();\n  this.word(\"default\");\n  this.space();\n  this.tokenContext |= TokenContext.exportDefault;\n  const declar = node.declaration;\n  this.print(declar);\n  if (!isStatement(declar)) this.semicolon();\n}\n\nexport function ImportDeclaration(this: Printer, node: t.ImportDeclaration) {\n  this.word(\"import\");\n  this.space();\n\n  const isTypeKind = node.importKind === \"type\" || node.importKind === \"typeof\";\n  if (isTypeKind) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.importKind);\n    this.space();\n  } else if (node.module) {\n    this.noIndentInnerCommentsHere();\n    this.word(\"module\");\n    this.space();\n  } else if (node.phase) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.phase);\n    this.space();\n  }\n\n  const specifiers = node.specifiers.slice(0);\n  const hasSpecifiers = !!specifiers.length;\n  // print \"special\" specifiers first. The loop condition is constant,\n  // but there is a \"break\" in the body.\n  while (hasSpecifiers) {\n    const first = specifiers[0];\n    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {\n      this.print(specifiers.shift());\n      if (specifiers.length) {\n        this.token(\",\");\n        this.space();\n      }\n    } else {\n      break;\n    }\n  }\n\n  let hasBrace = false;\n  if (specifiers.length) {\n    hasBrace = true;\n    this.token(\"{\");\n    this.space();\n    this.printList(specifiers, this.shouldPrintTrailingComma(\"}\"));\n    this.space();\n    this.token(\"}\");\n  } else if (isTypeKind && !hasSpecifiers) {\n    hasBrace = true;\n    this.token(\"{\");\n    this.token(\"}\");\n  }\n\n  if (hasSpecifiers || isTypeKind) {\n    this.space();\n    this.word(\"from\");\n    this.space();\n  }\n\n  if (node.attributes?.length || node.assertions?.length) {\n    this.print(node.source, true);\n    this.space();\n    this._printAttributes(node, hasBrace);\n  } else {\n    this.print(node.source);\n  }\n\n  this.semicolon();\n}\n\nexport function ImportAttribute(this: Printer, node: t.ImportAttribute) {\n  this.print(node.key);\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ImportNamespaceSpecifier(\n  this: Printer,\n  node: t.ImportNamespaceSpecifier,\n) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.local);\n}\n\nexport function ImportExpression(this: Printer, node: t.ImportExpression) {\n  this.word(\"import\");\n  if (node.phase) {\n    this.token(\".\");\n    this.word(node.phase);\n  }\n  this.token(\"(\");\n  const shouldPrintTrailingComma = this.shouldPrintTrailingComma(\")\");\n  this.print(node.source);\n  if (node.options != null) {\n    this.token(\",\");\n    this.space();\n    this.print(node.options);\n  }\n  if (shouldPrintTrailingComma) {\n    this.token(\",\");\n  }\n  this.rightParens(node);\n}\n", "'use strict';\n\nconst object = {};\nconst hasOwnProperty = object.hasOwnProperty;\nconst forOwn = (object, callback) => {\n\tfor (const key in object) {\n\t\tif (hasOwnProperty.call(object, key)) {\n\t\t\tcallback(key, object[key]);\n\t\t}\n\t}\n};\n\nconst extend = (destination, source) => {\n\tif (!source) {\n\t\treturn destination;\n\t}\n\tforOwn(source, (key, value) => {\n\t\tdestination[key] = value;\n\t});\n\treturn destination;\n};\n\nconst forEach = (array, callback) => {\n\tconst length = array.length;\n\tlet index = -1;\n\twhile (++index < length) {\n\t\tcallback(array[index]);\n\t}\n};\n\nconst fourHexEscape = (hex) => {\n\treturn '\\\\u' + ('0000' + hex).slice(-4);\n}\n\nconst hexadecimal = (code, lowercase) => {\n\tlet hexadecimal = code.toString(16);\n\tif (lowercase) return hexadecimal;\n\treturn hexadecimal.toUpperCase();\n};\n\nconst toString = object.toString;\nconst isArray = Array.isArray;\nconst isBuffer = (value) => {\n\treturn typeof Buffer === 'function' && Buffer.isBuffer(value);\n};\nconst isObject = (value) => {\n\t// This is a very simple check, but it’s good enough for what we need.\n\treturn toString.call(value) == '[object Object]';\n};\nconst isString = (value) => {\n\treturn typeof value == 'string' ||\n\t\ttoString.call(value) == '[object String]';\n};\nconst isNumber = (value) => {\n\treturn typeof value == 'number' ||\n\t\ttoString.call(value) == '[object Number]';\n};\nconst isBigInt = (value) => {\n  return typeof value == 'bigint';\n};\nconst isFunction = (value) => {\n\treturn typeof value == 'function';\n};\nconst isMap = (value) => {\n\treturn toString.call(value) == '[object Map]';\n};\nconst isSet = (value) => {\n\treturn toString.call(value) == '[object Set]';\n};\n\n/*--------------------------------------------------------------------------*/\n\n// https://mathiasbynens.be/notes/javascript-escapes#single\nconst singleEscapes = {\n\t'\\\\': '\\\\\\\\',\n\t'\\b': '\\\\b',\n\t'\\f': '\\\\f',\n\t'\\n': '\\\\n',\n\t'\\r': '\\\\r',\n\t'\\t': '\\\\t'\n\t// `\\v` is omitted intentionally, because in IE < 9, '\\v' == 'v'.\n\t// '\\v': '\\\\x0B'\n};\nconst regexSingleEscape = /[\\\\\\b\\f\\n\\r\\t]/;\n\nconst regexDigit = /[0-9]/;\nconst regexWhitespace = /[\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/;\n\nconst escapeEverythingRegex = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF])|([\\uD800-\\uDFFF])|(['\"`])|[^]/g;\nconst escapeNonAsciiRegex = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF])|([\\uD800-\\uDFFF])|(['\"`])|[^ !#-&\\(-\\[\\]-_a-~]/g;\n\nconst jsesc = (argument, options) => {\n\tconst increaseIndentation = () => {\n\t\toldIndent = indent;\n\t\t++options.indentLevel;\n\t\tindent = options.indent.repeat(options.indentLevel)\n\t};\n\t// Handle options\n\tconst defaults = {\n\t\t'escapeEverything': false,\n\t\t'minimal': false,\n\t\t'isScriptContext': false,\n\t\t'quotes': 'single',\n\t\t'wrap': false,\n\t\t'es6': false,\n\t\t'json': false,\n\t\t'compact': true,\n\t\t'lowercaseHex': false,\n\t\t'numbers': 'decimal',\n\t\t'indent': '\\t',\n\t\t'indentLevel': 0,\n\t\t'__inline1__': false,\n\t\t'__inline2__': false\n\t};\n\tconst json = options && options.json;\n\tif (json) {\n\t\tdefaults.quotes = 'double';\n\t\tdefaults.wrap = true;\n\t}\n\toptions = extend(defaults, options);\n\tif (\n\t\toptions.quotes != 'single' &&\n\t\toptions.quotes != 'double' &&\n\t\toptions.quotes != 'backtick'\n\t) {\n\t\toptions.quotes = 'single';\n\t}\n\tconst quote = options.quotes == 'double' ?\n\t\t'\"' :\n\t\t(options.quotes == 'backtick' ?\n\t\t\t'`' :\n\t\t\t'\\''\n\t\t);\n\tconst compact = options.compact;\n\tconst lowercaseHex = options.lowercaseHex;\n\tlet indent = options.indent.repeat(options.indentLevel);\n\tlet oldIndent = '';\n\tconst inline1 = options.__inline1__;\n\tconst inline2 = options.__inline2__;\n\tconst newLine = compact ? '' : '\\n';\n\tlet result;\n\tlet isEmpty = true;\n\tconst useBinNumbers = options.numbers == 'binary';\n\tconst useOctNumbers = options.numbers == 'octal';\n\tconst useDecNumbers = options.numbers == 'decimal';\n\tconst useHexNumbers = options.numbers == 'hexadecimal';\n\n\tif (json && argument && isFunction(argument.toJSON)) {\n\t\targument = argument.toJSON();\n\t}\n\n\tif (!isString(argument)) {\n\t\tif (isMap(argument)) {\n\t\t\tif (argument.size == 0) {\n\t\t\t\treturn 'new Map()';\n\t\t\t}\n\t\t\tif (!compact) {\n\t\t\t\toptions.__inline1__ = true;\n\t\t\t\toptions.__inline2__ = false;\n\t\t\t}\n\t\t\treturn 'new Map(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isSet(argument)) {\n\t\t\tif (argument.size == 0) {\n\t\t\t\treturn 'new Set()';\n\t\t\t}\n\t\t\treturn 'new Set(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isBuffer(argument)) {\n\t\t\tif (argument.length == 0) {\n\t\t\t\treturn 'Buffer.from([])';\n\t\t\t}\n\t\t\treturn 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isArray(argument)) {\n\t\t\tresult = [];\n\t\t\toptions.wrap = true;\n\t\t\tif (inline1) {\n\t\t\t\toptions.__inline1__ = false;\n\t\t\t\toptions.__inline2__ = true;\n\t\t\t}\n\t\t\tif (!inline2) {\n\t\t\t\tincreaseIndentation();\n\t\t\t}\n\t\t\tforEach(argument, (value) => {\n\t\t\t\tisEmpty = false;\n\t\t\t\tif (inline2) {\n\t\t\t\t\toptions.__inline2__ = false;\n\t\t\t\t}\n\t\t\t\tresult.push(\n\t\t\t\t\t(compact || inline2 ? '' : indent) +\n\t\t\t\t\tjsesc(value, options)\n\t\t\t\t);\n\t\t\t});\n\t\t\tif (isEmpty) {\n\t\t\t\treturn '[]';\n\t\t\t}\n\t\t\tif (inline2) {\n\t\t\t\treturn '[' + result.join(', ') + ']';\n\t\t\t}\n\t\t\treturn '[' + newLine + result.join(',' + newLine) + newLine +\n\t\t\t\t(compact ? '' : oldIndent) + ']';\n\t\t} else if (isNumber(argument) || isBigInt(argument)) {\n\t\t\tif (json) {\n\t\t\t\t// Some number values (e.g. `Infinity`) cannot be represented in JSON.\n\t\t\t\t// `BigInt` values less than `-Number.MAX_VALUE` or greater than\n        // `Number.MAX_VALUE` cannot be represented in JSON so they will become\n        // `-Infinity` or `Infinity`, respectively, and then become `null` when\n        // stringified.\n\t\t\t\treturn JSON.stringify(Number(argument));\n\t\t\t}\n\n      let result;\n\t\t\tif (useDecNumbers) {\n\t\t\t\tresult = String(argument);\n\t\t\t} else if (useHexNumbers) {\n\t\t\t\tlet hexadecimal = argument.toString(16);\n\t\t\t\tif (!lowercaseHex) {\n\t\t\t\t\thexadecimal = hexadecimal.toUpperCase();\n\t\t\t\t}\n\t\t\t\tresult = '0x' + hexadecimal;\n\t\t\t} else if (useBinNumbers) {\n\t\t\t\tresult = '0b' + argument.toString(2);\n\t\t\t} else if (useOctNumbers) {\n\t\t\t\tresult = '0o' + argument.toString(8);\n\t\t\t}\n\n      if (isBigInt(argument)) {\n        return result + 'n';\n      }\n      return result;\n\t\t} else if (isBigInt(argument)) {\n\t\t\tif (json) {\n\t\t\t\t// `BigInt` values less than `-Number.MAX_VALUE` or greater than\n        // `Number.MAX_VALUE` will become `-Infinity` or `Infinity`,\n        // respectively, and cannot be represented in JSON.\n\t\t\t\treturn JSON.stringify(Number(argument));\n\t\t\t}\n      return argument + 'n';\n    } else if (!isObject(argument)) {\n\t\t\tif (json) {\n\t\t\t\t// For some values (e.g. `undefined`, `function` objects),\n\t\t\t\t// `JSON.stringify(value)` returns `undefined` (which isn’t valid\n\t\t\t\t// JSON) instead of `'null'`.\n\t\t\t\treturn JSON.stringify(argument) || 'null';\n\t\t\t}\n\t\t\treturn String(argument);\n\t\t} else { // it’s an object\n\t\t\tresult = [];\n\t\t\toptions.wrap = true;\n\t\t\tincreaseIndentation();\n\t\t\tforOwn(argument, (key, value) => {\n\t\t\t\tisEmpty = false;\n\t\t\t\tresult.push(\n\t\t\t\t\t(compact ? '' : indent) +\n\t\t\t\t\tjsesc(key, options) + ':' +\n\t\t\t\t\t(compact ? '' : ' ') +\n\t\t\t\t\tjsesc(value, options)\n\t\t\t\t);\n\t\t\t});\n\t\t\tif (isEmpty) {\n\t\t\t\treturn '{}';\n\t\t\t}\n\t\t\treturn '{' + newLine + result.join(',' + newLine) + newLine +\n\t\t\t\t(compact ? '' : oldIndent) + '}';\n\t\t}\n\t}\n\n\tconst regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;\n\tresult = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {\n\t\tif (pair) {\n\t\t\tif (options.minimal) return pair;\n\t\t\tconst first = pair.charCodeAt(0);\n\t\t\tconst second = pair.charCodeAt(1);\n\t\t\tif (options.es6) {\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\tconst codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\tconst hex = hexadecimal(codePoint, lowercaseHex);\n\t\t\t\treturn '\\\\u{' + hex + '}';\n\t\t\t}\n\t\t\treturn fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));\n\t\t}\n\n\t\tif (lone) {\n\t\t\treturn fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));\n\t\t}\n\n\t\tif (\n\t\t\tchar == '\\0' &&\n\t\t\t!json &&\n\t\t\t!regexDigit.test(string.charAt(index + 1))\n\t\t) {\n\t\t\treturn '\\\\0';\n\t\t}\n\n\t\tif (quoteChar) {\n\t\t\tif (quoteChar == quote || options.escapeEverything) {\n\t\t\t\treturn '\\\\' + quoteChar;\n\t\t\t}\n\t\t\treturn quoteChar;\n\t\t}\n\n\t\tif (regexSingleEscape.test(char)) {\n\t\t\t// no need for a `hasOwnProperty` check here\n\t\t\treturn singleEscapes[char];\n\t\t}\n\n\t\tif (options.minimal && !regexWhitespace.test(char)) {\n\t\t\treturn char;\n\t\t}\n\n\t\tconst hex = hexadecimal(char.charCodeAt(0), lowercaseHex);\n\t\tif (json || hex.length > 2) {\n\t\t\treturn fourHexEscape(hex);\n\t\t}\n\n\t\treturn '\\\\x' + ('00' + hex).slice(-2);\n\t});\n\n\tif (quote == '`') {\n\t\tresult = result.replace(/\\$\\{/g, '\\\\${');\n\t}\n\tif (options.isScriptContext) {\n\t\t// https://mathiasbynens.be/notes/etago\n\t\tresult = result\n\t\t\t.replace(/<\\/(script|style)/gi, '<\\\\/$1')\n\t\t\t.replace(/<!--/g, json ? '\\\\u003C!--' : '\\\\x3C!--');\n\t}\n\tif (options.wrap) {\n\t\tresult = quote + result + quote;\n\t}\n\treturn result;\n};\n\njsesc.version = '3.0.2';\n\nmodule.exports = jsesc;\n", "import type Printer from \"../printer.ts\";\nimport { isAssignmentPattern, isIdentifier } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport jsesc from \"jsesc\";\n\nlet lastRawIdentNode: t.Identifier | null = null;\nlet lastRawIdentResult: string = \"\";\nexport function _getRawIdentifier(this: Printer, node: t.Identifier) {\n  if (node === lastRawIdentNode) return lastRawIdentResult;\n  lastRawIdentNode = node;\n\n  const { name } = node;\n  const token = this.tokenMap.find(node, tok => tok.value === name);\n  if (token) {\n    lastRawIdentResult = this._originalCode.slice(token.start, token.end);\n    return lastRawIdentResult;\n  }\n  return (lastRawIdentResult = node.name);\n}\n\nexport function Identifier(this: Printer, node: t.Identifier) {\n  this.sourceIdentifierName(node.loc?.identifierName || node.name);\n\n  this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);\n}\n\nexport function ArgumentPlaceholder(this: Printer) {\n  this.token(\"?\");\n}\n\nexport function RestElement(this: Printer, node: t.RestElement) {\n  this.token(\"...\");\n  this.print(node.argument);\n}\n\nexport { RestElement as SpreadElement };\n\nexport function ObjectExpression(this: Printer, node: t.ObjectExpression) {\n  const props = node.properties;\n\n  this.token(\"{\");\n\n  if (props.length) {\n    const exit = this.enterDelimited();\n    this.space();\n    this.printList(props, this.shouldPrintTrailingComma(\"}\"), true, true);\n    this.space();\n    exit();\n  }\n\n  this.sourceWithOffset(\"end\", node.loc, -1);\n\n  this.token(\"}\");\n}\n\nexport { ObjectExpression as ObjectPattern };\n\nexport function ObjectMethod(this: Printer, node: t.ObjectMethod) {\n  this.printJoin(node.decorators);\n  this._methodHead(node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function ObjectProperty(this: Printer, node: t.ObjectProperty) {\n  this.printJoin(node.decorators);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    // print `({ foo: foo = 5 } = {})` as `({ foo = 5 } = {});`\n    if (\n      isAssignmentPattern(node.value) &&\n      isIdentifier(node.key) &&\n      // @ts-expect-error todo(flow->ts) `.name` does not exist on some types in union\n      node.key.name === node.value.left.name\n    ) {\n      this.print(node.value);\n      return;\n    }\n\n    this.print(node.key);\n\n    // shorthand!\n    if (\n      node.shorthand &&\n      isIdentifier(node.key) &&\n      isIdentifier(node.value) &&\n      node.key.name === node.value.name\n    ) {\n      return;\n    }\n  }\n\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ArrayExpression(this: Printer, node: t.ArrayExpression) {\n  const elems = node.elements;\n  const len = elems.length;\n\n  this.token(\"[\");\n\n  const exit = this.enterDelimited();\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem);\n      if (i < len - 1 || this.shouldPrintTrailingComma(\"]\")) {\n        this.token(\",\", false, i);\n      }\n    } else {\n      // If the array expression ends with a hole, that hole\n      // will be ignored by the interpreter, but if it ends with\n      // two (or more) holes, we need to write out two (or more)\n      // commas so that the resulting code is interpreted with\n      // both (all) of the holes.\n      this.token(\",\", false, i);\n    }\n  }\n\n  exit();\n\n  this.token(\"]\");\n}\n\nexport { ArrayExpression as ArrayPattern };\n\nexport function RecordExpression(this: Printer, node: t.RecordExpression) {\n  const props = node.properties;\n\n  let startToken;\n  let endToken;\n  if (process.env.BABEL_8_BREAKING) {\n    startToken = \"#{\";\n    endToken = \"}\";\n  } else {\n    if (this.format.recordAndTupleSyntaxType === \"bar\") {\n      startToken = \"{|\";\n      endToken = \"|}\";\n    } else if (\n      this.format.recordAndTupleSyntaxType !== \"hash\" &&\n      this.format.recordAndTupleSyntaxType != null\n    ) {\n      throw new Error(\n        `The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (${JSON.stringify(\n          this.format.recordAndTupleSyntaxType,\n        )} received).`,\n      );\n    } else {\n      startToken = \"#{\";\n      endToken = \"}\";\n    }\n  }\n\n  this.token(startToken);\n\n  if (props.length) {\n    this.space();\n    this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);\n    this.space();\n  }\n  this.token(endToken);\n}\n\nexport function TupleExpression(this: Printer, node: t.TupleExpression) {\n  const elems = node.elements;\n  const len = elems.length;\n\n  let startToken;\n  let endToken;\n  if (process.env.BABEL_8_BREAKING) {\n    startToken = \"#[\";\n    endToken = \"]\";\n  } else {\n    if (this.format.recordAndTupleSyntaxType === \"bar\") {\n      startToken = \"[|\";\n      endToken = \"|]\";\n    } else if (this.format.recordAndTupleSyntaxType === \"hash\") {\n      startToken = \"#[\";\n      endToken = \"]\";\n    } else {\n      throw new Error(\n        `${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`,\n      );\n    }\n  }\n\n  this.token(startToken);\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem);\n      if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {\n        this.token(\",\", false, i);\n      }\n    }\n  }\n\n  this.token(endToken);\n}\n\nexport function RegExpLiteral(this: Printer, node: t.RegExpLiteral) {\n  this.word(`/${node.pattern}/${node.flags}`);\n}\n\nexport function BooleanLiteral(this: Printer, node: t.BooleanLiteral) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteral(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function NumericLiteral(this: Printer, node: t.NumericLiteral) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value;\n  const str = value + \"\";\n  if (opts.numbers) {\n    this.number(jsesc(value, opts), value);\n  } else if (raw == null) {\n    this.number(str, value); // normalize\n  } else if (this.format.minified) {\n    this.number(raw.length < str.length ? raw : str, value);\n  } else {\n    this.number(raw, value);\n  }\n}\n\nexport function StringLiteral(this: Printer, node: t.StringLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const val = jsesc(node.value, this.format.jsescOption);\n\n  this.token(val);\n}\n\nexport function BigIntLiteral(this: Printer, node: t.BigIntLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"n\");\n}\n\n// Hack pipe operator\nconst validTopicTokenSet = new Set([\"^^\", \"@@\", \"^\", \"%\", \"#\"]);\nexport function TopicReference(this: Printer) {\n  const { topicToken } = this.format;\n\n  if (validTopicTokenSet.has(topicToken)) {\n    this.token(topicToken);\n  } else {\n    const givenTopicTokenJSON = JSON.stringify(topicToken);\n    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));\n    throw new Error(\n      `The \"topicToken\" generator option must be one of ` +\n        `${validTopics.join(\", \")} (${givenTopicTokenJSON} received instead).`,\n    );\n  }\n}\n\n// Smart-mix pipe operator\nexport function PipelineTopicExpression(\n  this: Printer,\n  node: t.PipelineTopicExpression,\n) {\n  this.print(node.expression);\n}\n\nexport function PipelineBareFunction(\n  this: Printer,\n  node: t.PipelineBareFunction,\n) {\n  this.print(node.callee);\n}\n\nexport function PipelinePrimaryTopicReference(this: Printer) {\n  this.token(\"#\");\n}\n\n// discard binding\nexport function VoidPattern(this: Printer) {\n  this.word(\"void\");\n}\n", "import type Printer from \"../printer.ts\";\nimport { isDeclareExportDeclaration, isStatement } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { ExportAllDeclaration } from \"./modules.ts\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function AnyTypeAnnotation(this: Printer) {\n  this.word(\"any\");\n}\n\nexport function ArrayTypeAnnotation(\n  this: Printer,\n  node: t.ArrayTypeAnnotation,\n) {\n  this.print(node.elementType, true);\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nexport function BooleanTypeAnnotation(this: Printer) {\n  this.word(\"boolean\");\n}\n\nexport function BooleanLiteralTypeAnnotation(\n  this: Printer,\n  node: t.BooleanLiteralTypeAnnotation,\n) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteralTypeAnnotation(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function DeclareClass(\n  this: Printer,\n  node: t.DeclareClass,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"class\");\n  this.space();\n  this._interfaceish(node);\n}\n\nexport function DeclareFunction(\n  this: Printer,\n  node: t.DeclareFunction,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"function\");\n  this.space();\n  this.print(node.id);\n  // @ts-ignore(Babel 7 vs Babel 8) TODO(Babel 8) Remove this comment, since we'll remove the Noop node\n  this.print(node.id.typeAnnotation.typeAnnotation);\n\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate);\n  }\n\n  this.semicolon();\n}\n\nexport function InferredPredicate(this: Printer) {\n  this.token(\"%\");\n  this.word(\"checks\");\n}\n\nexport function DeclaredPredicate(this: Printer, node: t.DeclaredPredicate) {\n  this.token(\"%\");\n  this.word(\"checks\");\n  this.token(\"(\");\n  this.print(node.value);\n  this.token(\")\");\n}\n\nexport function DeclareInterface(this: Printer, node: t.DeclareInterface) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\n\nexport function DeclareModule(this: Printer, node: t.DeclareModule) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id);\n  this.space();\n  this.print(node.body);\n}\n\nexport function DeclareModuleExports(\n  this: Printer,\n  node: t.DeclareModuleExports,\n) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.token(\".\");\n  this.word(\"exports\");\n  this.print(node.typeAnnotation);\n}\n\nexport function DeclareTypeAlias(this: Printer, node: t.DeclareTypeAlias) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\n\nexport function DeclareOpaqueType(\n  this: Printer,\n  node: t.DeclareOpaqueType,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.OpaqueType(node);\n}\n\nexport function DeclareVariable(\n  this: Printer,\n  node: t.DeclareVariable,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"var\");\n  this.space();\n  this.print(node.id);\n  this.print(node.id.typeAnnotation);\n  this.semicolon();\n}\n\nexport function DeclareExportDeclaration(\n  this: Printer,\n  node: t.DeclareExportDeclaration,\n) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n\n  FlowExportDeclaration.call(this, node);\n}\n\nexport function DeclareExportAllDeclaration(\n  this: Printer,\n  node: t.DeclareExportAllDeclaration,\n) {\n  this.word(\"declare\");\n  this.space();\n  ExportAllDeclaration.call(this, node);\n}\n\nexport function EnumDeclaration(this: Printer, node: t.EnumDeclaration) {\n  const { id, body } = node;\n  this.word(\"enum\");\n  this.space();\n  this.print(id);\n  this.print(body);\n}\n\nfunction enumExplicitType(\n  context: Printer,\n  name: string,\n  hasExplicitType: boolean,\n) {\n  if (hasExplicitType) {\n    context.space();\n    context.word(\"of\");\n    context.space();\n    context.word(name);\n  }\n  context.space();\n}\n\nfunction enumBody(context: Printer, node: t.EnumBody) {\n  const { members } = node;\n  context.token(\"{\");\n  context.indent();\n  context.newline();\n  for (const member of members) {\n    context.print(member);\n    context.newline();\n  }\n  if (node.hasUnknownMembers) {\n    context.token(\"...\");\n    context.newline();\n  }\n  context.dedent();\n  context.token(\"}\");\n}\n\nexport function EnumBooleanBody(this: Printer, node: t.EnumBooleanBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"boolean\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumNumberBody(this: Printer, node: t.EnumNumberBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"number\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumStringBody(this: Printer, node: t.EnumStringBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"string\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumSymbolBody(this: Printer, node: t.EnumSymbolBody) {\n  enumExplicitType(this, \"symbol\", true);\n  enumBody(this, node);\n}\n\nexport function EnumDefaultedMember(\n  this: Printer,\n  node: t.EnumDefaultedMember,\n) {\n  const { id } = node;\n  this.print(id);\n  this.token(\",\");\n}\n\nfunction enumInitializedMember(\n  context: Printer,\n  node: t.EnumBooleanMember | t.EnumNumberMember | t.EnumStringMember,\n) {\n  context.print(node.id);\n  context.space();\n  context.token(\"=\");\n  context.space();\n  context.print(node.init);\n  context.token(\",\");\n}\n\nexport function EnumBooleanMember(this: Printer, node: t.EnumBooleanMember) {\n  enumInitializedMember(this, node);\n}\n\nexport function EnumNumberMember(this: Printer, node: t.EnumNumberMember) {\n  enumInitializedMember(this, node);\n}\n\nexport function EnumStringMember(this: Printer, node: t.EnumStringMember) {\n  enumInitializedMember(this, node);\n}\n\nfunction FlowExportDeclaration(\n  this: Printer,\n  node: t.DeclareExportDeclaration,\n) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.token(\"{\");\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers);\n      this.space();\n    }\n    this.token(\"}\");\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source);\n    }\n\n    this.semicolon();\n  }\n}\n\nexport function ExistsTypeAnnotation(this: Printer) {\n  this.token(\"*\");\n}\n\nexport function FunctionTypeAnnotation(\n  this: Printer,\n  node: t.FunctionTypeAnnotation,\n  parent?: t.Node,\n) {\n  this.print(node.typeParameters);\n  this.token(\"(\");\n\n  if (node.this) {\n    this.word(\"this\");\n    this.token(\":\");\n    this.space();\n    this.print(node.this.typeAnnotation);\n    if (node.params.length || node.rest) {\n      this.token(\",\");\n      this.space();\n    }\n  }\n\n  this.printList(node.params);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.token(\",\");\n      this.space();\n    }\n    this.token(\"...\");\n    this.print(node.rest);\n  }\n\n  this.token(\")\");\n\n  // this node type is overloaded, not sure why but it makes it EXTREMELY annoying\n\n  const type = parent?.type;\n  if (\n    type != null &&\n    (type === \"ObjectTypeCallProperty\" ||\n      type === \"ObjectTypeInternalSlot\" ||\n      type === \"DeclareFunction\" ||\n      (type === \"ObjectTypeProperty\" && parent.method))\n  ) {\n    this.token(\":\");\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n\n  this.space();\n  this.print(node.returnType);\n}\n\nexport function FunctionTypeParam(this: Printer, node: t.FunctionTypeParam) {\n  this.print(node.name);\n  if (node.optional) this.token(\"?\");\n  if (node.name) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.typeAnnotation);\n}\n\nexport function InterfaceExtends(this: Printer, node: t.InterfaceExtends) {\n  this.print(node.id);\n  this.print(node.typeParameters, true);\n}\n\nexport {\n  InterfaceExtends as ClassImplements,\n  InterfaceExtends as GenericTypeAnnotation,\n};\n\nexport function _interfaceish(\n  this: Printer,\n  node: t.InterfaceDeclaration | t.DeclareInterface | t.DeclareClass,\n) {\n  this.print(node.id);\n  this.print(node.typeParameters);\n  if (node.extends?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends);\n  }\n  if (node.type === \"DeclareClass\") {\n    if (node.mixins?.length) {\n      this.space();\n      this.word(\"mixins\");\n      this.space();\n      this.printList(node.mixins);\n    }\n    if (node.implements?.length) {\n      this.space();\n      this.word(\"implements\");\n      this.space();\n      this.printList(node.implements);\n    }\n  }\n  this.space();\n  this.print(node.body);\n}\n\nexport function _variance(\n  this: Printer,\n  node:\n    | t.TypeParameter\n    | t.ObjectTypeIndexer\n    | t.ObjectTypeProperty\n    | t.ClassProperty\n    | t.ClassPrivateProperty\n    | t.ClassAccessorProperty,\n) {\n  const kind = node.variance?.kind;\n  if (kind != null) {\n    if (kind === \"plus\") {\n      this.token(\"+\");\n    } else if (kind === \"minus\") {\n      this.token(\"-\");\n    }\n  }\n}\n\nexport function InterfaceDeclaration(\n  this: Printer,\n  node: t.InterfaceDeclaration | t.DeclareInterface,\n) {\n  this.word(\"interface\");\n  this.space();\n  this._interfaceish(node);\n}\n\nfunction andSeparator(this: Printer, occurrenceCount: number) {\n  this.space();\n  this.token(\"&\", false, occurrenceCount);\n  this.space();\n}\n\nexport function InterfaceTypeAnnotation(\n  this: Printer,\n  node: t.InterfaceTypeAnnotation,\n) {\n  this.word(\"interface\");\n  if (node.extends?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends);\n  }\n  this.space();\n  this.print(node.body);\n}\n\nexport function IntersectionTypeAnnotation(\n  this: Printer,\n  node: t.IntersectionTypeAnnotation,\n) {\n  this.printJoin(node.types, undefined, undefined, andSeparator);\n}\n\nexport function MixedTypeAnnotation(this: Printer) {\n  this.word(\"mixed\");\n}\n\nexport function EmptyTypeAnnotation(this: Printer) {\n  this.word(\"empty\");\n}\n\nexport function NullableTypeAnnotation(\n  this: Printer,\n  node: t.NullableTypeAnnotation,\n) {\n  this.token(\"?\");\n  this.print(node.typeAnnotation);\n}\n\nexport {\n  NumericLiteral as NumberLiteralTypeAnnotation,\n  StringLiteral as StringLiteralTypeAnnotation,\n} from \"./types.ts\";\n\nexport function NumberTypeAnnotation(this: Printer) {\n  this.word(\"number\");\n}\n\nexport function StringTypeAnnotation(this: Printer) {\n  this.word(\"string\");\n}\n\nexport function ThisTypeAnnotation(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function TupleTypeAnnotation(\n  this: Printer,\n  node: t.TupleTypeAnnotation,\n) {\n  this.token(\"[\");\n  this.printList(node.types);\n  this.token(\"]\");\n}\n\nexport function TypeofTypeAnnotation(\n  this: Printer,\n  node: t.TypeofTypeAnnotation,\n) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument);\n}\n\nexport function TypeAlias(\n  this: Printer,\n  node: t.TypeAlias | t.DeclareTypeAlias,\n) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id);\n  this.print(node.typeParameters);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right);\n  this.semicolon();\n}\n\nexport function TypeAnnotation(\n  this: Printer,\n  node: t.TypeAnnotation,\n  parent: t.Node,\n) {\n  this.token(\":\");\n  this.space();\n  if (parent.type === \"ArrowFunctionExpression\") {\n    this.tokenContext |= TokenContext.arrowFlowReturnType;\n  } else if (\n    // @ts-expect-error todo(flow->ts) can this be removed? `.optional` looks to be not existing property\n    node.optional\n  ) {\n    this.token(\"?\");\n  }\n  this.print(node.typeAnnotation);\n}\n\nexport function TypeParameterInstantiation(\n  this: Printer,\n  node: t.TypeParameterInstantiation,\n): void {\n  this.token(\"<\");\n  this.printList(node.params);\n  this.token(\">\");\n}\n\nexport { TypeParameterInstantiation as TypeParameterDeclaration };\n\nexport function TypeParameter(this: Printer, node: t.TypeParameter) {\n  this._variance(node);\n\n  this.word(node.name);\n\n  if (node.bound) {\n    this.print(node.bound);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default);\n  }\n}\n\nexport function OpaqueType(\n  this: Printer,\n  node: t.OpaqueType | t.DeclareOpaqueType,\n) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id);\n  this.print(node.typeParameters);\n  if (node.supertype) {\n    this.token(\":\");\n    this.space();\n    this.print(node.supertype);\n  }\n\n  if (node.impltype) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.impltype);\n  }\n  this.semicolon();\n}\n\nexport function ObjectTypeAnnotation(\n  this: Printer,\n  node: t.ObjectTypeAnnotation,\n) {\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.token(\"{\");\n  }\n\n  // TODO: remove the array fallbacks and instead enforce the types to require an array\n  const props = [\n    ...node.properties,\n    ...(node.callProperties || []),\n    ...(node.indexers || []),\n    ...(node.internalSlots || []),\n  ];\n\n  if (props.length) {\n    this.newline();\n\n    this.space();\n\n    this.printJoin(\n      props,\n      true,\n      true,\n      undefined,\n      undefined,\n      function addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n      () => {\n        if (props.length !== 1 || node.inexact) {\n          this.token(\",\");\n          this.space();\n        }\n      },\n    );\n\n    this.space();\n  }\n\n  if (node.inexact) {\n    this.indent();\n    this.token(\"...\");\n    if (props.length) {\n      this.newline();\n    }\n    this.dedent();\n  }\n\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.token(\"}\");\n  }\n}\n\nexport function ObjectTypeInternalSlot(\n  this: Printer,\n  node: t.ObjectTypeInternalSlot,\n) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.token(\"[\");\n  this.token(\"[\");\n  this.print(node.id);\n  this.token(\"]\");\n  this.token(\"]\");\n  if (node.optional) this.token(\"?\");\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeCallProperty(\n  this: Printer,\n  node: t.ObjectTypeCallProperty,\n) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeIndexer(this: Printer, node: t.ObjectTypeIndexer) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this._variance(node);\n  this.token(\"[\");\n  if (node.id) {\n    this.print(node.id);\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.key);\n  this.token(\"]\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ObjectTypeProperty(this: Printer, node: t.ObjectTypeProperty) {\n  if (node.proto) {\n    this.word(\"proto\");\n    this.space();\n  }\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (node.kind === \"get\" || node.kind === \"set\") {\n    this.word(node.kind);\n    this.space();\n  }\n  this._variance(node);\n  this.print(node.key);\n  if (node.optional) this.token(\"?\");\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeSpreadProperty(\n  this: Printer,\n  node: t.ObjectTypeSpreadProperty,\n) {\n  this.token(\"...\");\n  this.print(node.argument);\n}\n\nexport function QualifiedTypeIdentifier(\n  this: Printer,\n  node: t.QualifiedTypeIdentifier,\n) {\n  this.print(node.qualification);\n  this.token(\".\");\n  this.print(node.id);\n}\n\nexport function SymbolTypeAnnotation(this: Printer) {\n  this.word(\"symbol\");\n}\n\nfunction orSeparator(this: Printer, occurrenceCount: number) {\n  this.space();\n  this.token(\"|\", false, occurrenceCount);\n  this.space();\n}\n\nexport function UnionTypeAnnotation(\n  this: Printer,\n  node: t.UnionTypeAnnotation,\n) {\n  this.printJoin(node.types, undefined, undefined, orSeparator);\n}\n\nexport function TypeCastExpression(this: Printer, node: t.TypeCastExpression) {\n  this.token(\"(\");\n  this.print(node.expression);\n  this.print(node.typeAnnotation);\n  this.token(\")\");\n}\n\nexport function Variance(this: Printer, node: t.Variance) {\n  if (node.kind === \"plus\") {\n    this.token(\"+\");\n  } else {\n    this.token(\"-\");\n  }\n}\n\nexport function VoidTypeAnnotation(this: Printer) {\n  this.word(\"void\");\n}\n\nexport function IndexedAccessType(this: Printer, node: t.IndexedAccessType) {\n  this.print(node.objectType, true);\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n\nexport function OptionalIndexedAccessType(\n  this: Printer,\n  node: t.OptionalIndexedAccessType,\n) {\n  this.print(node.objectType);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n", "import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function File(this: Printer, node: t.File) {\n  if (node.program) {\n    // Print this here to ensure that Program node 'leadingComments' still\n    // get printed after the hashbang.\n    this.print(node.program.interpreter);\n  }\n\n  this.print(node.program);\n}\n\nexport function Program(this: Printer, node: t.Program) {\n  // An empty Program doesn't have any inner tokens, so\n  // we must explicitly print its inner comments.\n  this.noIndentInnerCommentsHere();\n  this.printInnerComments();\n\n  const directivesLen = node.directives?.length;\n  if (directivesLen) {\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, undefined, newline);\n    if (!node.directives[directivesLen - 1].trailingComments?.length) {\n      this.newline(newline);\n    }\n  }\n\n  this.printSequence(node.body);\n}\n\nexport function BlockStatement(this: Printer, node: t.BlockStatement) {\n  this.token(\"{\");\n  const exit = this.enterDelimited();\n\n  const directivesLen = node.directives?.length;\n  if (directivesLen) {\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, true, newline);\n    if (!node.directives[directivesLen - 1].trailingComments?.length) {\n      this.newline(newline);\n    }\n  }\n\n  this.printSequence(node.body, true);\n\n  exit();\n  this.rightBrace(node);\n}\n\nexport function Directive(this: Printer, node: t.Directive) {\n  this.print(node.value);\n  this.semicolon();\n}\n\n// These regexes match an even number of \\ followed by a quote\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\n\nexport function DirectiveLiteral(this: Printer, node: t.DirectiveLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const { value } = node;\n\n  // NOTE: In directives we can't change escapings,\n  // because they change the behavior.\n  // e.g. \"us\\x65 strict\" (\\x65 is e) is not a \"use strict\" directive.\n\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`\"${value}\"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`'${value}'`);\n  } else {\n    throw new Error(\n      \"Malformed AST: it is not possible to print a directive containing\" +\n        \" both unescaped single and double quotes.\",\n    );\n  }\n}\n\nexport function InterpreterDirective(\n  this: Printer,\n  node: t.InterpreterDirective,\n) {\n  this.token(`#!${node.value}`);\n  this.newline(1, true);\n}\n\nexport function Placeholder(this: Printer, node: t.Placeholder) {\n  this.token(\"%%\");\n  this.print(node.name);\n  this.token(\"%%\");\n\n  if (node.expectedNode === \"Statement\") {\n    this.semicolon();\n  }\n}\n", "import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function JSXAttribute(this: Printer, node: t.JSXAttribute) {\n  this.print(node.name);\n  if (node.value) {\n    this.token(\"=\");\n    this.print(node.value);\n  }\n}\n\nexport function JSXIdentifier(this: Printer, node: t.JSXIdentifier) {\n  this.word(node.name);\n}\n\nexport function JSXNamespacedName(this: Printer, node: t.JSXNamespacedName) {\n  this.print(node.namespace);\n  this.token(\":\");\n  this.print(node.name);\n}\n\nexport function JSXMemberExpression(\n  this: Printer,\n  node: t.JSXMemberExpression,\n) {\n  this.print(node.object);\n  this.token(\".\");\n  this.print(node.property);\n}\n\nexport function JSXSpreadAttribute(this: Printer, node: t.JSXSpreadAttribute) {\n  this.token(\"{\");\n  this.token(\"...\");\n  this.print(node.argument);\n  this.rightBrace(node);\n}\n\nexport function JSXExpressionContainer(\n  this: Printer,\n  node: t.JSXExpressionContainer,\n) {\n  this.token(\"{\");\n  this.print(node.expression);\n  this.rightBrace(node);\n}\n\nexport function JSXSpreadChild(this: Printer, node: t.JSXSpreadChild) {\n  this.token(\"{\");\n  this.token(\"...\");\n  this.print(node.expression);\n  this.rightBrace(node);\n}\n\nexport function JSXText(this: Printer, node: t.JSXText) {\n  const raw = this.getPossibleRaw(node);\n\n  if (raw !== undefined) {\n    this.token(raw, true);\n  } else {\n    this.token(node.value, true);\n  }\n}\n\nexport function JSXElement(this: Printer, node: t.JSXElement) {\n  const open = node.openingElement;\n  this.print(open);\n  if (open.selfClosing) return;\n\n  this.indent();\n  for (const child of node.children) {\n    this.print(child);\n  }\n  this.dedent();\n\n  this.print(node.closingElement);\n}\n\nfunction spaceSeparator(this: Printer) {\n  this.space();\n}\n\nexport function JSXOpeningElement(this: Printer, node: t.JSXOpeningElement) {\n  this.token(\"<\");\n  this.print(node.name);\n  if (process.env.BABEL_8_BREAKING) {\n    //@ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n    this.print(node.typeArguments);\n  } else {\n    if (node.typeArguments) {\n      this.print(node.typeArguments); // Flow AST\n    }\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    this.print(node.typeParameters); // Legacy TS AST\n  }\n\n  if (node.attributes.length > 0) {\n    this.space();\n    this.printJoin(node.attributes, undefined, undefined, spaceSeparator);\n  }\n  if (node.selfClosing) {\n    this.space();\n    this.token(\"/\");\n  }\n  this.token(\">\");\n}\n\nexport function JSXClosingElement(this: Printer, node: t.JSXClosingElement) {\n  this.token(\"<\");\n  this.token(\"/\");\n  this.print(node.name);\n  this.token(\">\");\n}\n\nexport function JSXEmptyExpression(this: Printer) {\n  // This node is empty, so forcefully print its inner comments.\n  this.printInnerComments();\n}\n\nexport function JSXFragment(this: Printer, node: t.JSXFragment) {\n  this.print(node.openingFragment);\n\n  this.indent();\n  for (const child of node.children) {\n    this.print(child);\n  }\n  this.dedent();\n\n  this.print(node.closingFragment);\n}\n\nexport function JSXOpeningFragment(this: Printer) {\n  this.token(\"<\");\n  this.token(\">\");\n}\n\nexport function JSXClosingFragment(this: Printer) {\n  this.token(\"</\");\n  this.token(\">\");\n}\n", "import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function TSTypeAnnotation(\n  this: Printer,\n  node: t.TSTypeAnnotation,\n  parent: t.Node,\n) {\n  // TODO(@nicolo-ribaudo): investigate not including => in the range\n  // of the return type of an arrow function type\n  this.token(\n    (parent.type === \"TSFunctionType\" || parent.type === \"TSConstructorType\") &&\n      (process.env.BABEL_8_BREAKING\n        ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n          parent.returnType\n        : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n          parent.typeAnnotation) === node\n      ? \"=>\"\n      : \":\",\n  );\n  this.space();\n  // @ts-expect-error todo(flow->ts) can this be removed? `.optional` looks to be not existing property\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation);\n}\n\nexport function TSTypeParameterInstantiation(\n  this: Printer,\n  node: t.TSTypeParameterInstantiation,\n  parent: t.Node,\n): void {\n  this.token(\"<\");\n\n  let printTrailingSeparator =\n    parent.type === \"ArrowFunctionExpression\" && node.params.length === 1;\n  if (this.tokenMap && node.start != null && node.end != null) {\n    // Only force the trailing comma for pre-existing nodes if they\n    // already had a comma (either because they were multi-param, or\n    // because they had a trailing comma)\n    printTrailingSeparator &&= !!this.tokenMap.find(node, t =>\n      this.tokenMap.matchesOriginal(t, \",\"),\n    );\n    // Preserve the trailing comma if it was there before\n    printTrailingSeparator ||= this.shouldPrintTrailingComma(\">\");\n  }\n\n  this.printList(node.params, printTrailingSeparator);\n  this.token(\">\");\n}\n\nexport { TSTypeParameterInstantiation as TSTypeParameterDeclaration };\n\nexport function TSTypeParameter(this: Printer, node: t.TSTypeParameter) {\n  if (node.const) {\n    this.word(\"const\");\n    this.space();\n  }\n\n  if (node.in) {\n    this.word(\"in\");\n    this.space();\n  }\n\n  if (node.out) {\n    this.word(\"out\");\n    this.space();\n  }\n\n  this.word(\n    !process.env.BABEL_8_BREAKING\n      ? (node.name as unknown as string)\n      : (node.name as unknown as t.Identifier).name,\n  );\n\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default);\n  }\n}\n\nexport function TSParameterProperty(\n  this: Printer,\n  node: t.TSParameterProperty,\n) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this._param(node.parameter);\n}\n\nexport function TSDeclareFunction(\n  this: Printer,\n  node: t.TSDeclareFunction,\n  parent: t.ParentMaps[\"TSDeclareFunction\"],\n) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this._functionHead(node, parent);\n  this.semicolon();\n}\n\nexport function TSDeclareMethod(this: Printer, node: t.TSDeclareMethod) {\n  this._classMethodHead(node);\n  this.semicolon();\n}\n\nexport function TSQualifiedName(this: Printer, node: t.TSQualifiedName) {\n  this.print(node.left);\n  this.token(\".\");\n  this.print(node.right);\n}\n\nexport function TSCallSignatureDeclaration(\n  this: Printer,\n  node: t.TSCallSignatureDeclaration,\n) {\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nfunction maybePrintTrailingCommaOrSemicolon(printer: Printer, node: t.Node) {\n  if (!printer.tokenMap || !node.start || !node.end) {\n    printer.semicolon();\n    return;\n  }\n\n  if (printer.tokenMap.endMatches(node, \",\")) {\n    printer.token(\",\");\n  } else if (printer.tokenMap.endMatches(node, \";\")) {\n    printer.semicolon();\n  }\n}\n\nexport function TSConstructSignatureDeclaration(\n  this: Printer,\n  node: t.TSConstructSignatureDeclaration,\n) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSPropertySignature(\n  this: Printer,\n  node: t.TSPropertySignature,\n) {\n  const { readonly } = node;\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function tsPrintPropertyOrMethodName(\n  this: Printer,\n  node: t.TSPropertySignature | t.TSMethodSignature,\n) {\n  if (node.computed) {\n    this.token(\"[\");\n  }\n  this.print(node.key);\n  if (node.computed) {\n    this.token(\"]\");\n  }\n  if (node.optional) {\n    this.token(\"?\");\n  }\n}\n\nexport function TSMethodSignature(this: Printer, node: t.TSMethodSignature) {\n  const { kind } = node;\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSIndexSignature(this: Printer, node: t.TSIndexSignature) {\n  const { readonly, static: isStatic } = node;\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.token(\"[\");\n  this._parameters(node.parameters, \"]\");\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSAnyKeyword(this: Printer) {\n  this.word(\"any\");\n}\nexport function TSBigIntKeyword(this: Printer) {\n  this.word(\"bigint\");\n}\nexport function TSUnknownKeyword(this: Printer) {\n  this.word(\"unknown\");\n}\nexport function TSNumberKeyword(this: Printer) {\n  this.word(\"number\");\n}\nexport function TSObjectKeyword(this: Printer) {\n  this.word(\"object\");\n}\nexport function TSBooleanKeyword(this: Printer) {\n  this.word(\"boolean\");\n}\nexport function TSStringKeyword(this: Printer) {\n  this.word(\"string\");\n}\nexport function TSSymbolKeyword(this: Printer) {\n  this.word(\"symbol\");\n}\nexport function TSVoidKeyword(this: Printer) {\n  this.word(\"void\");\n}\nexport function TSUndefinedKeyword(this: Printer) {\n  this.word(\"undefined\");\n}\nexport function TSNullKeyword(this: Printer) {\n  this.word(\"null\");\n}\nexport function TSNeverKeyword(this: Printer) {\n  this.word(\"never\");\n}\nexport function TSIntrinsicKeyword(this: Printer) {\n  this.word(\"intrinsic\");\n}\n\nexport function TSThisType(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function TSFunctionType(this: Printer, node: t.TSFunctionType) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nexport function TSConstructorType(this: Printer, node: t.TSConstructorType) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nexport function tsPrintFunctionOrConstructorType(\n  this: Printer,\n  node: t.TSFunctionType | t.TSConstructorType,\n) {\n  const { typeParameters } = node;\n  const parameters = process.env.BABEL_8_BREAKING\n    ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n      node.params\n    : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      node.parameters;\n  this.print(typeParameters);\n  this.token(\"(\");\n  this._parameters(parameters, \")\");\n  this.space();\n  const returnType = process.env.BABEL_8_BREAKING\n    ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n      node.returnType\n    : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      node.typeAnnotation;\n  this.print(returnType);\n}\n\nexport function TSTypeReference(this: Printer, node: t.TSTypeReference) {\n  const typeArguments = process.env.BABEL_8_BREAKING\n    ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n      node.typeArguments\n    : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      node.typeParameters;\n  this.print(node.typeName, !!typeArguments);\n  this.print(typeArguments);\n}\n\nexport function TSTypePredicate(this: Printer, node: t.TSTypePredicate) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n  this.print(node.parameterName);\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\n\nexport function TSTypeQuery(this: Printer, node: t.TSTypeQuery) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n\n  const typeArguments = process.env.BABEL_8_BREAKING\n    ? //@ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n      node.typeArguments\n    : //@ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n      node.typeParameters;\n  if (typeArguments) {\n    this.print(typeArguments);\n  }\n}\n\nexport function TSTypeLiteral(this: Printer, node: t.TSTypeLiteral) {\n  printBraced(this, node, () => this.printJoin(node.members, true, true));\n}\n\nexport function TSArrayType(this: Printer, node: t.TSArrayType) {\n  this.print(node.elementType, true);\n\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nexport function TSTupleType(this: Printer, node: t.TSTupleType) {\n  this.token(\"[\");\n  this.printList(node.elementTypes, this.shouldPrintTrailingComma(\"]\"));\n  this.token(\"]\");\n}\n\nexport function TSOptionalType(this: Printer, node: t.TSOptionalType) {\n  this.print(node.typeAnnotation);\n  this.token(\"?\");\n}\n\nexport function TSRestType(this: Printer, node: t.TSRestType) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation);\n}\n\nexport function TSNamedTupleMember(this: Printer, node: t.TSNamedTupleMember) {\n  this.print(node.label);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.elementType);\n}\n\nexport function TSUnionType(this: Printer, node: t.TSUnionType) {\n  tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\n\nexport function TSIntersectionType(this: Printer, node: t.TSIntersectionType) {\n  tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\n\nfunction tsPrintUnionOrIntersectionType(\n  printer: Printer,\n  node: t.TSUnionType | t.TSIntersectionType,\n  sep: \"|\" | \"&\",\n) {\n  let hasLeadingToken = 0;\n  if (printer.tokenMap?.startMatches(node, sep)) {\n    hasLeadingToken = 1;\n    printer.token(sep);\n  }\n\n  printer.printJoin(node.types, undefined, undefined, function (i) {\n    this.space();\n    this.token(sep, null, i + hasLeadingToken);\n    this.space();\n  });\n}\n\nexport function TSConditionalType(this: Printer, node: t.TSConditionalType) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.falseType);\n}\n\nexport function TSInferType(this: Printer, node: t.TSInferType) {\n  this.word(\"infer\");\n  this.print(node.typeParameter);\n}\n\nexport function TSParenthesizedType(\n  this: Printer,\n  node: t.TSParenthesizedType,\n) {\n  this.token(\"(\");\n  this.print(node.typeAnnotation);\n  this.token(\")\");\n}\n\nexport function TSTypeOperator(this: Printer, node: t.TSTypeOperator) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation);\n}\n\nexport function TSIndexedAccessType(\n  this: Printer,\n  node: t.TSIndexedAccessType,\n) {\n  this.print(node.objectType, true);\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n\nexport function TSMappedType(this: Printer, node: t.TSMappedType) {\n  const { nameType, optional, readonly, typeAnnotation } = node;\n  this.token(\"{\");\n  const exit = this.enterDelimited();\n  this.space();\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n  if (process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n    this.word(node.key.name);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    this.word(node.typeParameter.name);\n  }\n\n  this.space();\n  this.word(\"in\");\n  this.space();\n  if (process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n    this.print(node.constraint);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    this.print(node.typeParameter.constraint);\n  }\n\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType);\n  }\n\n  this.token(\"]\");\n\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.token(\"?\");\n  }\n\n  if (typeAnnotation) {\n    this.token(\":\");\n    this.space();\n    this.print(typeAnnotation);\n  }\n  this.space();\n  exit();\n  this.token(\"}\");\n}\n\nfunction tokenIfPlusMinus(self: Printer, tok: true | \"+\" | \"-\") {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\n\nexport function TSTemplateLiteralType(\n  this: Printer,\n  node: t.TSTemplateLiteralType,\n) {\n  this._printTemplate(node, node.types);\n}\n\nexport function TSLiteralType(this: Printer, node: t.TSLiteralType) {\n  this.print(node.literal);\n}\n\nexport function TSClassImplements(\n  this: Printer,\n  // TODO(Babel 8): Just use t.TSClassImplements\n  node: t.Node & {\n    expression: t.TSEntityName;\n    typeArguments?: t.TSTypeParameterInstantiation;\n  },\n) {\n  this.print(node.expression);\n  this.print(node.typeArguments);\n}\n\nexport { TSClassImplements as TSInterfaceHeritage };\n\nexport function TSInterfaceDeclaration(\n  this: Printer,\n  node: t.TSInterfaceDeclaration,\n) {\n  const { declare, id, typeParameters, extends: extendz, body } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"interface\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  if (extendz?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz);\n  }\n  this.space();\n  this.print(body);\n}\n\nexport function TSInterfaceBody(this: Printer, node: t.TSInterfaceBody) {\n  printBraced(this, node, () => this.printJoin(node.body, true, true));\n}\n\nexport function TSTypeAliasDeclaration(\n  this: Printer,\n  node: t.TSTypeAliasDeclaration,\n) {\n  const { declare, id, typeParameters, typeAnnotation } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"type\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(typeAnnotation);\n  this.semicolon();\n}\n\nfunction TSTypeExpression(\n  this: Printer,\n  node: t.TSAsExpression | t.TSSatisfiesExpression,\n) {\n  const { type, expression, typeAnnotation } = node;\n  this.print(expression, true);\n  this.space();\n  this.word(type === \"TSAsExpression\" ? \"as\" : \"satisfies\");\n  this.space();\n  this.print(typeAnnotation);\n}\n\nexport {\n  TSTypeExpression as TSAsExpression,\n  TSTypeExpression as TSSatisfiesExpression,\n};\n\nexport function TSTypeAssertion(this: Printer, node: t.TSTypeAssertion) {\n  const { typeAnnotation, expression } = node;\n  this.token(\"<\");\n  this.print(typeAnnotation);\n  this.token(\">\");\n  this.space();\n  this.print(expression);\n}\n\nexport function TSInstantiationExpression(\n  this: Printer,\n  node: t.TSInstantiationExpression,\n) {\n  this.print(node.expression);\n  if (process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n    this.print(node.typeArguments);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    this.print(node.typeParameters);\n  }\n}\n\nexport function TSEnumDeclaration(this: Printer, node: t.TSEnumDeclaration) {\n  const { declare, const: isConst, id } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n  this.word(\"enum\");\n  this.space();\n  this.print(id);\n  this.space();\n\n  if (process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n    this.print(node.body);\n  } else {\n    // cast to TSEnumBody for Babel 7 AST\n    TSEnumBody.call(this, node as unknown as t.TSEnumBody);\n  }\n}\n\nexport function TSEnumBody(this: Printer, node: t.TSEnumBody) {\n  printBraced(this, node, () =>\n    this.printList(\n      node.members,\n      this.shouldPrintTrailingComma(\"}\") ??\n        (process.env.BABEL_8_BREAKING ? false : true),\n      true,\n      true,\n    ),\n  );\n}\n\nexport function TSEnumMember(this: Printer, node: t.TSEnumMember) {\n  const { id, initializer } = node;\n  this.print(id);\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer);\n  }\n}\n\nexport function TSModuleDeclaration(\n  this: Printer,\n  node: t.TSModuleDeclaration,\n) {\n  const { declare, id, kind } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (process.env.BABEL_8_BREAKING) {\n    if (kind !== \"global\") {\n      this.word(kind);\n      this.space();\n    }\n\n    this.print(node.id);\n    if (!node.body) {\n      this.semicolon();\n      return;\n    }\n    this.space();\n    this.print(node.body);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    if (!node.global) {\n      this.word(kind ?? (id.type === \"Identifier\" ? \"namespace\" : \"module\"));\n      this.space();\n    }\n\n    this.print(id);\n\n    if (!node.body) {\n      this.semicolon();\n      return;\n    }\n\n    let body = node.body;\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    while (body.type === \"TSModuleDeclaration\") {\n      this.token(\".\");\n      // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      this.print(body.id);\n      // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      body = body.body;\n    }\n\n    this.space();\n    this.print(body);\n  }\n}\n\nexport function TSModuleBlock(this: Printer, node: t.TSModuleBlock) {\n  printBraced(this, node, () => this.printSequence(node.body, true));\n}\n\nexport function TSImportType(this: Printer, node: t.TSImportType) {\n  const { argument, qualifier, options } = node;\n  this.word(\"import\");\n  this.token(\"(\");\n  this.print(argument);\n  if (options) {\n    this.token(\",\");\n    this.print(options);\n  }\n  this.token(\")\");\n  if (qualifier) {\n    this.token(\".\");\n    this.print(qualifier);\n  }\n  const typeArguments = process.env.BABEL_8_BREAKING\n    ? //@ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n      node.typeArguments\n    : //@ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n      node.typeParameters;\n  if (typeArguments) {\n    this.print(typeArguments);\n  }\n}\n\nexport function TSImportEqualsDeclaration(\n  this: Printer,\n  node: t.TSImportEqualsDeclaration,\n) {\n  const { id, moduleReference } = node;\n  if (\n    !process.env.BABEL_8_BREAKING &&\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n    node.isExport\n  ) {\n    this.word(\"export\");\n    this.space();\n  }\n  this.word(\"import\");\n  this.space();\n  this.print(id);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(moduleReference);\n  this.semicolon();\n}\n\nexport function TSExternalModuleReference(\n  this: Printer,\n  node: t.TSExternalModuleReference,\n) {\n  this.token(\"require(\");\n  this.print(node.expression);\n  this.token(\")\");\n}\n\nexport function TSNonNullExpression(\n  this: Printer,\n  node: t.TSNonNullExpression,\n) {\n  this.print(node.expression);\n  this.token(\"!\");\n}\n\nexport function TSExportAssignment(this: Printer, node: t.TSExportAssignment) {\n  this.word(\"export\");\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.expression);\n  this.semicolon();\n}\n\nexport function TSNamespaceExportDeclaration(\n  this: Printer,\n  node: t.TSNamespaceExportDeclaration,\n) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id);\n  this.semicolon();\n}\n\nexport function tsPrintSignatureDeclarationBase(this: Printer, node: any) {\n  const { typeParameters } = node;\n  const parameters = process.env.BABEL_8_BREAKING\n    ? node.params\n    : node.parameters;\n  this.print(typeParameters);\n  this.token(\"(\");\n  this._parameters(parameters, \")\");\n  const returnType = process.env.BABEL_8_BREAKING\n    ? node.returnType\n    : node.typeAnnotation;\n  this.print(returnType);\n}\n\nexport function tsPrintClassMemberModifiers(\n  this: Printer,\n  node:\n    | t.ClassProperty\n    | t.ClassAccessorProperty\n    | t.ClassPrivateProperty\n    | t.ClassMethod\n    | t.ClassPrivateMethod\n    | t.TSDeclareMethod,\n) {\n  const isPrivateField = node.type === \"ClassPrivateProperty\";\n  const isPublicField =\n    node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n  printModifiersList(this, node, [\n    isPublicField && node.declare && \"declare\",\n    !isPrivateField && node.accessibility,\n  ]);\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  printModifiersList(this, node, [\n    !isPrivateField && node.abstract && \"abstract\",\n    !isPrivateField && node.override && \"override\",\n    (isPublicField || isPrivateField) && node.readonly && \"readonly\",\n  ]);\n}\n\nfunction printBraced(printer: Printer, node: t.Node, cb: () => void) {\n  printer.token(\"{\");\n  const exit = printer.enterDelimited();\n  cb();\n  exit();\n  printer.rightBrace(node);\n}\n\nfunction printModifiersList(\n  printer: Printer,\n  node: t.Node,\n  modifiers: (string | false | null)[],\n) {\n  const modifiersSet = new Set<string>();\n  for (const modifier of modifiers) {\n    if (modifier) modifiersSet.add(modifier);\n  }\n\n  printer.tokenMap?.find(node, tok => {\n    if (modifiersSet.has(tok.value)) {\n      printer.token(tok.value);\n      printer.space();\n      modifiersSet.delete(tok.value);\n      return modifiersSet.size === 0;\n    }\n  });\n\n  for (const modifier of modifiersSet) {\n    printer.word(modifier);\n    printer.space();\n  }\n}\n", "export * from \"./template-literals.ts\";\nexport * from \"./expressions.ts\";\nexport * from \"./statements.ts\";\nexport * from \"./classes.ts\";\nexport * from \"./methods.ts\";\nexport * from \"./modules.ts\";\nexport * from \"./types.ts\";\nexport * from \"./flow.ts\";\nexport * from \"./base.ts\";\nexport * from \"./jsx.ts\";\nexport * from \"./typescript.ts\";\n", "import type Printer from \"../printer\";\nimport type * as t from \"@babel/types\";\n\nexport type DeprecatedBabel7ASTTypes =\n  | \"Noop\"\n  | \"TSExpressionWithTypeArguments\"\n  | \"DecimalLiteral\";\n\nexport function addDeprecatedGenerators(PrinterClass: typeof Printer) {\n  // Add Babel 7 generator methods that is removed in Babel 8\n  if (!process.env.BABEL_8_BREAKING) {\n    const deprecatedBabel7Generators = {\n      Noop(this: Printer) {},\n\n      TSExpressionWithTypeArguments(\n        this: Printer,\n        // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        node: t.TSExpressionWithTypeArguments,\n      ) {\n        this.print(node.expression);\n        this.print(node.typeParameters);\n      },\n\n      DecimalLiteral(this: Printer, node: any) {\n        const raw = this.getPossibleRaw(node);\n        if (!this.format.minified && raw !== undefined) {\n          this.word(raw);\n          return;\n        }\n        this.word(node.value + \"m\");\n      },\n    } satisfies Record<\n      DeprecatedBabel7ASTTypes,\n      (this: Printer, node: any) => void\n    >;\n    Object.assign(PrinterClass.prototype, deprecatedBabel7Generators);\n  }\n}\n", "import Buffer, { type Pos } from \"./buffer.ts\";\nimport type { Loc } from \"./buffer.ts\";\nimport * as n from \"./node/index.ts\";\nimport type * as t from \"@babel/types\";\nimport {\n  isExpression,\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumMember,\n} from \"@babel/types\";\nimport type { Opts as jsescOptions } from \"jsesc\";\n\nimport { TokenMap } from \"./token-map.ts\";\nimport type { GeneratorOptions } from \"./index.ts\";\nimport * as generatorFunctions from \"./generators/index.ts\";\nimport {\n  addDeprecatedGenerators,\n  type DeprecatedBabel7ASTTypes,\n} from \"./generators/deprecated.ts\";\nimport type SourceMap from \"./source-map.ts\";\nimport type { TraceMap } from \"@jridgewell/trace-mapping\";\nimport type { Token } from \"@babel/parser\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\\n\\r\\u2028\\u2029]|\\*\\//;\n\nfunction commentIsNewline(c: t.Comment) {\n  return c.type === \"CommentLine\" || HAS_NEWLINE.test(c.value);\n}\n\nconst { needsParens } = n;\n\nimport { TokenContext } from \"./node/index.ts\";\n\nconst enum COMMENT_TYPE {\n  LEADING,\n  INNER,\n  TRAILING,\n}\n\nconst enum COMMENT_SKIP_NEWLINE {\n  DEFAULT,\n  ALL,\n  LEADING,\n  TRAILING,\n}\n\nconst enum PRINT_COMMENT_HINT {\n  SKIP,\n  ALLOW,\n  DEFER,\n}\n\nexport type Format = {\n  shouldPrintComment: (comment: string) => boolean;\n  preserveFormat: boolean;\n  retainLines: boolean;\n  retainFunctionParens: boolean;\n  comments: boolean;\n  auxiliaryCommentBefore: string;\n  auxiliaryCommentAfter: string;\n  compact: boolean | \"auto\";\n  minified: boolean;\n  concise: boolean;\n  indent: {\n    adjustMultilineComment: boolean;\n    style: string;\n  };\n  /**\n   * @deprecated Removed in Babel 8, syntax type is always 'hash'\n   */\n  recordAndTupleSyntaxType?: GeneratorOptions[\"recordAndTupleSyntaxType\"];\n  jsescOption: jsescOptions;\n  /**\n   * @deprecated Removed in Babel 8, use `jsescOption` instead\n   */\n  jsonCompatibleStrings?: boolean;\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodies’ topic references.\n   */\n  topicToken?: GeneratorOptions[\"topicToken\"];\n  /**\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n};\n\ninterface AddNewlinesOptions {\n  addNewlines(leading: boolean, node: t.Node): number;\n  nextNodeStartLine: number;\n}\n\ninterface PrintSequenceOptions extends Partial<AddNewlinesOptions> {\n  statement?: boolean;\n  indent?: boolean;\n  trailingCommentsLineOffset?: number;\n}\n\ninterface PrintListOptions {\n  separator?: (this: Printer, occurrenceCount: number, last: boolean) => void;\n  iterator?: (node: t.Node, index: number) => void;\n  statement?: boolean;\n  indent?: boolean;\n  printTrailingSeparator?: boolean;\n}\n\nexport type PrintJoinOptions = PrintListOptions & PrintSequenceOptions;\nclass Printer {\n  constructor(\n    format: Format,\n    map: SourceMap,\n    tokens?: Token[],\n    originalCode?: string,\n  ) {\n    this.format = format;\n\n    this._tokens = tokens;\n    this._originalCode = originalCode;\n\n    this._indentRepeat = format.indent.style.length;\n\n    this._inputMap = map?._inputMap;\n\n    this._buf = new Buffer(map, format.indent.style[0]);\n  }\n  declare _inputMap: TraceMap;\n\n  declare format: Format;\n\n  enterForStatementInit() {\n    this.tokenContext |=\n      TokenContext.forInitHead | TokenContext.forInOrInitHeadAccumulate;\n    return () => (this.tokenContext = TokenContext.normal);\n  }\n\n  enterForXStatementInit(isForOf: boolean) {\n    if (isForOf) {\n      this.tokenContext |= TokenContext.forOfHead;\n      return null;\n    } else {\n      this.tokenContext |=\n        TokenContext.forInHead | TokenContext.forInOrInitHeadAccumulate;\n      return () => (this.tokenContext = TokenContext.normal);\n    }\n  }\n\n  enterDelimited() {\n    const oldTokenContext = this.tokenContext;\n    const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n    if (\n      !(oldTokenContext & TokenContext.forInOrInitHeadAccumulate) &&\n      oldNoLineTerminatorAfterNode === null\n    ) {\n      return () => {};\n    }\n    this._noLineTerminatorAfterNode = null;\n    this.tokenContext = TokenContext.normal;\n    return () => {\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n      this.tokenContext = oldTokenContext;\n    };\n  }\n\n  tokenContext: number = TokenContext.normal;\n\n  _tokens: Token[] = null;\n  _originalCode: string | null = null;\n\n  declare _buf: Buffer;\n  _currentNode: t.Node = null;\n  _indent: number = 0;\n  _indentRepeat: number = 0;\n  _insideAux: boolean = false;\n  _noLineTerminator: boolean = false;\n  _noLineTerminatorAfterNode: t.Node | null = null;\n  _printAuxAfterOnNextUserNode: boolean = false;\n  _printedComments = new Set<t.Comment>();\n  _endsWithInteger = false;\n  _endsWithWord = false;\n  _endsWithDiv = false;\n  _lastCommentLine = 0;\n  _endsWithInnerRaw: boolean = false;\n  _indentInnerComments: boolean = true;\n  tokenMap: TokenMap = null;\n\n  _boundGetRawIdentifier = this._getRawIdentifier.bind(this);\n\n  generate(ast: t.Node) {\n    if (this.format.preserveFormat) {\n      this.tokenMap = new TokenMap(ast, this._tokens, this._originalCode);\n    }\n    this.print(ast);\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  /**\n   * Increment indent size.\n   */\n\n  indent(): void {\n    const { format } = this;\n    if (format.preserveFormat || format.compact || format.concise) {\n      return;\n    }\n\n    this._indent++;\n  }\n\n  /**\n   * Decrement indent size.\n   */\n\n  dedent(): void {\n    const { format } = this;\n    if (format.preserveFormat || format.compact || format.concise) {\n      return;\n    }\n\n    this._indent--;\n  }\n\n  /**\n   * If the next token is on the same line, we must first print a semicolon.\n   * This option is only used in `preserveFormat` node, for semicolons that\n   * might have omitted due to them being absent in the original code (thanks\n   * to ASI).\n   *\n   * We need both *NextToken and *NextNode because we only want to insert the\n   * semicolon when the next token starts a new node, and not in cases like\n   * foo} (where } is not starting a new node). So we first set *NextNode, and\n   * then the print() method will move it to *NextToken.\n   */\n  _printSemicolonBeforeNextNode: number = -1;\n  _printSemicolonBeforeNextToken: number = -1;\n\n  /**\n   * Add a semicolon to the buffer.\n   */\n  semicolon(force: boolean = false): void {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(charCodes.semicolon);\n      this._noLineTerminator = false;\n      return;\n    }\n    if (this.tokenMap) {\n      const node = this._currentNode;\n      if (node.start != null && node.end != null) {\n        if (!this.tokenMap.endMatches(node, \";\")) {\n          // no semicolon\n          this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();\n          return;\n        }\n        const indexes = this.tokenMap.getIndexes(this._currentNode);\n        this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);\n      }\n    }\n    this._queue(charCodes.semicolon);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a right brace to the buffer.\n   */\n\n  rightBrace(node: t.Node): void {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\"}\");\n  }\n\n  rightParens(node: t.Node): void {\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\")\");\n  }\n\n  /**\n   * Add a space to the buffer unless it is compact.\n   */\n\n  space(force: boolean = false): void {\n    const { format } = this;\n    if (format.compact || format.preserveFormat) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== charCodes.space && lastCp !== charCodes.lineFeed) {\n        this._space();\n      }\n    }\n  }\n\n  /**\n   * Writes a token that can't be safely parsed without taking whitespace into account.\n   */\n\n  word(str: string, noLineTerminatorAfter: boolean = false): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(str);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str);\n\n    // prevent concatenating words and creating // comment out of division and regex\n    if (\n      this._endsWithWord ||\n      (this._endsWithDiv && str.charCodeAt(0) === charCodes.slash)\n    ) {\n      this._space();\n    }\n    this._append(str, false);\n\n    this._endsWithWord = true;\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n\n  /**\n   * Writes a number token so that we can validate if it is an integer.\n   */\n\n  number(str: string, number?: number): void {\n    // const NON_DECIMAL_LITERAL = /^0[box]/;\n    function isNonDecimalLiteral(str: string) {\n      if (str.length > 2 && str.charCodeAt(0) === charCodes.digit0) {\n        const secondChar = str.charCodeAt(1);\n        return (\n          secondChar === charCodes.lowercaseB ||\n          secondChar === charCodes.lowercaseO ||\n          secondChar === charCodes.lowercaseX\n        );\n      }\n      return false;\n    }\n    this.word(str);\n\n    // Integer tokens need special handling because they cannot have '.'s inserted\n    // immediately after them.\n    this._endsWithInteger =\n      Number.isInteger(number) &&\n      !isNonDecimalLiteral(str) &&\n      !SCIENTIFIC_NOTATION.test(str) &&\n      !ZERO_DECIMAL_INTEGER.test(str) &&\n      str.charCodeAt(str.length - 1) !== charCodes.dot;\n  }\n\n  /**\n   * Writes a simple token.\n   *\n   * @param {string} str The string to append.\n   * @param {boolean} [maybeNewline=false] Wether `str` might potentially\n   *    contain a line terminator or not.\n   * @param {number} [occurrenceCount=0] The occurrence count of this token in\n   *    the current node. This is used when printing in `preserveFormat` mode,\n   *    to know which token we should map to (for example, to disambiguate the\n   *    commas in an array literal).\n   */\n  token(str: string, maybeNewline = false, occurrenceCount = 0): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(str, occurrenceCount);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount);\n\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (\n      (lastChar === charCodes.exclamationMark &&\n        // space is mandatory to avoid outputting <!--\n        // http://javascript.spec.whatwg.org/#comment-syntax\n        (str === \"--\" ||\n          // Needs spaces to avoid changing a! == 0 to a!== 0\n          strFirst === charCodes.equalsTo)) ||\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (strFirst === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (strFirst === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (strFirst === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n\n  tokenChar(char: number): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    const str = String.fromCharCode(char);\n    this._maybePrintInnerComments(str);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str);\n\n    const lastChar = this.getLastChar();\n    if (\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (char === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (char === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (char === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a newline (or many newlines), maintaining formatting.\n   * This function checks the number of newlines in the queue and subtracts them.\n   * It currently has some limitations.\n   * @see {Buffer#getNewlineCount}\n   */\n  newline(i: number = 1, force?: boolean): void {\n    if (i <= 0) return;\n\n    if (!force) {\n      if (this.format.retainLines || this.format.compact) return;\n\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n    }\n\n    if (i > 2) i = 2; // Max two lines\n\n    i -= this._buf.getNewlineCount();\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n\n    return;\n  }\n\n  endsWith(char: number): boolean {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar(): number {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline(): number {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline(): void {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc: Loc | undefined, cb: () => void) {\n    if (!loc) {\n      cb();\n      return;\n    }\n\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    columnOffset: number,\n  ): void {\n    if (!loc || this.format.preserveFormat) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.sourceWithOffset(prop, loc, columnOffset);\n  }\n\n  sourceIdentifierName(identifierName: string, pos?: Pos): void {\n    if (!this._buf._canMarkIdName) return;\n\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n\n  _space(): void {\n    this._queue(charCodes.space);\n  }\n\n  _newline(): void {\n    this._queue(charCodes.lineFeed);\n  }\n\n  _catchUpToCurrentToken(str: string, occurrenceCount: number = 0): void {\n    // Assert: this.tokenMap\n\n    const token = this.tokenMap.findMatching(\n      this._currentNode,\n      str,\n      occurrenceCount,\n    );\n    if (token) this._catchUpTo(token.loc.start);\n\n    if (\n      this._printSemicolonBeforeNextToken !== -1 &&\n      this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()\n    ) {\n      this._buf.appendChar(charCodes.semicolon);\n      this._endsWithWord = false;\n      this._endsWithInteger = false;\n      this._endsWithDiv = false;\n    }\n    this._printSemicolonBeforeNextToken = -1;\n    this._printSemicolonBeforeNextNode = -1;\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    this._maybeIndent(str.charCodeAt(0));\n\n    this._buf.append(str, maybeNewline);\n\n    // callers are expected to then set these to `true` when needed\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n    this._endsWithDiv = false;\n  }\n\n  _appendChar(char: number): void {\n    this._maybeIndent(char);\n\n    this._buf.appendChar(char);\n\n    // callers are expected to then set these to `true` when needed\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n    this._endsWithDiv = false;\n  }\n\n  _queue(char: number) {\n    this._maybeIndent(char);\n\n    this._buf.queue(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(firstChar: number): void {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      this._buf.queueIndentation(this._getIndent());\n    }\n  }\n\n  _shouldIndent(firstChar: number) {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      return true;\n    }\n  }\n\n  catchUp(line: number) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const count = line - this._buf.getCurrentLine();\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n\n  _catchUp(prop: \"start\" | \"end\", loc?: Loc) {\n    const { format } = this;\n    if (!format.preserveFormat) {\n      if (format.retainLines && loc?.[prop]) {\n        this.catchUp(loc[prop].line);\n      }\n      return;\n    }\n\n    // catch up to this nodes newline if we're behind\n    const pos = loc?.[prop];\n    if (pos != null) this._catchUpTo(pos);\n  }\n\n  _catchUpTo({ line, column, index }: Pos) {\n    const count = line - this._buf.getCurrentLine();\n    if (count > 0 && this._noLineTerminator) {\n      // We cannot inject new lines when _noLineTemrinator is set\n      // to `true`, or we would generate invalid code.\n      return;\n    }\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n\n    const spacesCount =\n      count > 0 ? column : column - this._buf.getCurrentColumn();\n    if (spacesCount > 0) {\n      const spaces = this._originalCode\n        ? this._originalCode\n            .slice(index - spacesCount, index)\n            // https://tc39.es/ecma262/#sec-white-space\n            .replace(/[^\\t\\v\\f\\uFEFF\\p{Space_Separator}]/gu, \" \")\n        : \" \".repeat(spacesCount);\n      this._append(spaces, false);\n    }\n  }\n\n  /**\n   * Get the current indent.\n   */\n\n  _getIndent(): number {\n    return this._indentRepeat * this._indent;\n  }\n\n  printTerminatorless(node: t.Node) {\n    /**\n     * Set some state that will be modified if a newline has been inserted before any\n     * non-space characters.\n     *\n     * This is to prevent breaking semantics for terminatorless separator nodes. eg:\n     *\n     *   return foo;\n     *\n     * returns `foo`. But if we do:\n     *\n     *   return\n     *   foo;\n     *\n     *  `undefined` will be returned and not `foo` due to the terminator.\n     */\n    this._noLineTerminator = true;\n    this.print(node);\n  }\n\n  print(\n    node: t.Node | null,\n    noLineTerminatorAfter?: boolean,\n    // trailingCommentsLineOffset also used to check if called from printJoin\n    // it will be ignored if `noLineTerminatorAfter||this._noLineTerminator`\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!node) return;\n\n    this._endsWithInnerRaw = false;\n\n    const nodeType = node.type;\n    const format = this.format;\n\n    const oldConcise = format.concise;\n    if (\n      // @ts-expect-error document _compact AST properties\n      node._compact\n    ) {\n      format.concise = true;\n    }\n\n    const printMethod =\n      this[\n        nodeType as Exclude<\n          t.Node[\"type\"],\n          | DeprecatedBabel7ASTTypes\n          // renamed\n          | t.DeprecatedAliases[\"type\"]\n        >\n      ];\n    if (printMethod === undefined) {\n      throw new ReferenceError(\n        `unknown node of type ${JSON.stringify(\n          nodeType,\n        )} with constructor ${JSON.stringify(node.constructor.name)}`,\n      );\n    }\n\n    const parent = this._currentNode;\n    this._currentNode = node;\n\n    if (this.tokenMap) {\n      this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;\n    }\n\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == null;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    const parenthesized = node.extra?.parenthesized as boolean | undefined;\n    let shouldPrintParens =\n      (parenthesized && format.preserveFormat) ||\n      (parenthesized &&\n        format.retainFunctionParens &&\n        nodeType === \"FunctionExpression\") ||\n      needsParens(\n        node,\n        parent,\n        this.tokenContext,\n        format.preserveFormat ? this._boundGetRawIdentifier : undefined,\n      );\n\n    if (\n      !shouldPrintParens &&\n      parenthesized &&\n      node.leadingComments?.length &&\n      node.leadingComments[0].type === \"CommentBlock\"\n    ) {\n      const parentType = parent?.type;\n      switch (parentType) {\n        case \"ExpressionStatement\":\n        case \"VariableDeclarator\":\n        case \"AssignmentExpression\":\n        case \"ReturnStatement\":\n          break;\n        case \"CallExpression\":\n        case \"OptionalCallExpression\":\n        case \"NewExpression\":\n          if (parent.callee !== node) break;\n        // falls through\n        default:\n          shouldPrintParens = true;\n      }\n    }\n\n    let indentParenthesized = false;\n    if (\n      !shouldPrintParens &&\n      this._noLineTerminator &&\n      (node.leadingComments?.some(commentIsNewline) ||\n        (this.format.retainLines &&\n          node.loc &&\n          node.loc.start.line > this._buf.getCurrentLine()))\n    ) {\n      shouldPrintParens = true;\n      indentParenthesized = true;\n    }\n\n    let oldNoLineTerminatorAfterNode;\n    let oldTokenContext;\n    if (!shouldPrintParens) {\n      noLineTerminatorAfter ||=\n        parent &&\n        this._noLineTerminatorAfterNode === parent &&\n        n.isLastChild(parent, node);\n      if (noLineTerminatorAfter) {\n        if (node.trailingComments?.some(commentIsNewline)) {\n          if (isExpression(node)) shouldPrintParens = true;\n        } else {\n          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n          this._noLineTerminatorAfterNode = node;\n        }\n      }\n    }\n\n    if (shouldPrintParens) {\n      this.token(\"(\");\n      if (indentParenthesized) this.indent();\n      this._endsWithInnerRaw = false;\n      if (this.tokenContext & TokenContext.forInOrInitHeadAccumulate) {\n        oldTokenContext = this.tokenContext;\n        this.tokenContext = TokenContext.normal;\n      }\n      oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n      this._noLineTerminatorAfterNode = null;\n    }\n\n    this._lastCommentLine = 0;\n\n    this._printLeadingComments(node, parent);\n\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n\n    this.exactSource(\n      loc,\n      // @ts-expect-error Expected 1 arguments, but got 3.\n      printMethod.bind(this, node, parent),\n    );\n\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      if (indentParenthesized) {\n        this.dedent();\n        this.newline();\n      }\n      this.token(\")\");\n      this._noLineTerminator = noLineTerminatorAfter;\n      if (oldTokenContext) this.tokenContext = oldTokenContext;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n\n    // end\n    this._currentNode = parent;\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n\n    if (oldNoLineTerminatorAfterNode !== undefined) {\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n    }\n\n    this._endsWithInnerRaw = false;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode?: boolean) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  getPossibleRaw(\n    node:\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral\n      | t.DirectiveLiteral\n      | t.JSXText,\n  ): string | undefined {\n    const extra = node.extra;\n    if (\n      extra?.raw != null &&\n      extra.rawValue != null &&\n      node.value === extra.rawValue\n    ) {\n      // @ts-expect-error: The extra.raw of these AST node types must be a string\n      return extra.raw;\n    }\n  }\n\n  printJoin(\n    nodes: Array<t.Node> | undefined | null,\n    statement?: boolean,\n    indent?: boolean,\n    separator?: PrintJoinOptions[\"separator\"],\n    printTrailingSeparator?: boolean,\n    addNewlines?: PrintJoinOptions[\"addNewlines\"],\n    iterator?: PrintJoinOptions[\"iterator\"],\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!nodes?.length) return;\n\n    if (indent == null && this.format.retainLines) {\n      const startLine = nodes[0].loc?.start.line;\n      if (startLine != null && startLine !== this._buf.getCurrentLine()) {\n        indent = true;\n      }\n    }\n\n    if (indent) this.indent();\n\n    const newlineOpts: AddNewlinesOptions = {\n      addNewlines: addNewlines,\n      nextNodeStartLine: 0,\n    };\n\n    const boundSeparator = separator?.bind(this);\n\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n\n      if (statement) this._printNewline(i === 0, newlineOpts);\n\n      this.print(node, undefined, trailingCommentsLineOffset || 0);\n\n      iterator?.(node, i);\n\n      if (boundSeparator != null) {\n        if (i < len - 1) boundSeparator(i, false);\n        else if (printTrailingSeparator) boundSeparator(i, true);\n      }\n\n      if (statement) {\n        if (!node.trailingComments?.length) {\n          this._lastCommentLine = 0;\n        }\n\n        if (i + 1 === len) {\n          this.newline(1);\n        } else {\n          const nextNode = nodes[i + 1];\n          newlineOpts.nextNodeStartLine = nextNode.loc?.start.line || 0;\n\n          this._printNewline(true, newlineOpts);\n        }\n      }\n    }\n\n    if (indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node: t.Node) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent: Extract<t.Node, { body: t.Statement }>) {\n    const node = parent.body;\n\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n\n    this.print(node);\n  }\n\n  _printTrailingComments(node: t.Node, parent?: t.Node, lineOffset?: number) {\n    const { innerComments, trailingComments } = node;\n    // We print inner comments here, so that if for some reason they couldn't\n    // be printed in earlier locations they are still printed *somewhere*,\n    // even if at the end of the node.\n    if (innerComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        innerComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n    if (trailingComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        trailingComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n  }\n\n  _printLeadingComments(node: t.Node, parent: t.Node) {\n    const comments = node.leadingComments;\n    if (!comments?.length) return;\n    this._printComments(COMMENT_TYPE.LEADING, comments, node, parent);\n  }\n\n  _maybePrintInnerComments(\n    nextTokenStr: string,\n    nextTokenOccurrenceCount?: number,\n  ) {\n    if (this._endsWithInnerRaw) {\n      this.printInnerComments(\n        this.tokenMap?.findMatching(\n          this._currentNode,\n          nextTokenStr,\n          nextTokenOccurrenceCount,\n        ),\n      );\n    }\n    this._endsWithInnerRaw = true;\n    this._indentInnerComments = true;\n  }\n\n  printInnerComments(nextToken?: Token) {\n    const node = this._currentNode;\n    const comments = node.innerComments;\n    if (!comments?.length) return;\n\n    const hasSpace = this.endsWith(charCodes.space);\n    const indent = this._indentInnerComments;\n    const printedCommentsCount = this._printedComments.size;\n    if (indent) this.indent();\n    this._printComments(\n      COMMENT_TYPE.INNER,\n      comments,\n      node,\n      undefined,\n      undefined,\n      nextToken,\n    );\n    if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n      this.space();\n    }\n    if (indent) this.dedent();\n  }\n\n  noIndentInnerCommentsHere() {\n    this._indentInnerComments = false;\n  }\n\n  printSequence(\n    nodes: t.Node[],\n    indent?: boolean,\n    trailingCommentsLineOffset?: number,\n    addNewlines?: PrintSequenceOptions[\"addNewlines\"],\n  ) {\n    this.printJoin(\n      nodes,\n      true,\n      indent ?? false,\n      undefined,\n      undefined,\n      addNewlines,\n      undefined,\n      trailingCommentsLineOffset,\n    );\n  }\n\n  printList(\n    items: t.Node[],\n    printTrailingSeparator?: boolean,\n    statement?: boolean,\n    indent?: boolean,\n    separator?: PrintListOptions[\"separator\"],\n    iterator?: PrintListOptions[\"iterator\"],\n  ) {\n    this.printJoin(\n      items,\n      statement,\n      indent,\n      separator ?? commaSeparator,\n      printTrailingSeparator,\n      undefined,\n      iterator,\n    );\n  }\n\n  shouldPrintTrailingComma(listEnd: string): boolean | null {\n    if (!this.tokenMap) return null;\n\n    const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, token =>\n      this.tokenMap.matchesOriginal(token, listEnd),\n    );\n    if (listEndIndex <= 0) return null;\n    return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], \",\");\n  }\n\n  _printNewline(newLine: boolean, opts: AddNewlinesOptions) {\n    const format = this.format;\n\n    // Fast path since 'this.newline' does nothing when not tracking lines.\n    if (format.retainLines || format.compact) return;\n\n    // Fast path for concise since 'this.newline' just inserts a space when\n    // concise formatting is in use.\n    if (format.concise) {\n      this.space();\n      return;\n    }\n\n    if (!newLine) {\n      return;\n    }\n\n    const startLine = opts.nextNodeStartLine;\n    const lastCommentLine = this._lastCommentLine;\n    if (startLine > 0 && lastCommentLine > 0) {\n      const offset = startLine - lastCommentLine;\n      if (offset >= 0) {\n        this.newline(offset || 1);\n        return;\n      }\n    }\n\n    // don't add newlines at the beginning of the file\n    if (this._buf.hasContent()) {\n      // Here is the logic of the original line wrapping according to the node layout, we are not using it now.\n      // We currently add at most one newline to each node in the list, ignoring `opts.addNewlines`.\n\n      // let lines = 0;\n      // if (!leading) lines++; // always include at least a single line after\n      // if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n\n      // const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      // if (needs(node, parent)) lines++;\n\n      // this.newline(Math.min(2, lines));\n\n      this.newline(1);\n    }\n  }\n\n  // Returns `PRINT_COMMENT_HINT.DEFER` if the comment cannot be printed in this position due to\n  // line terminators, signaling that the print comments loop can stop and\n  // resume printing comments at the next possible position. This happens when\n  // printing inner comments, since if we have an inner comment with a multiline\n  // there is at least one inner position where line terminators are allowed.\n  _shouldPrintComment(\n    comment: t.Comment,\n    nextToken?: Token,\n  ): PRINT_COMMENT_HINT {\n    // Some plugins (such as flow-strip-types) use this to mark comments as removed using the AST-root 'comments' property,\n    // where they can't manually mutate the AST node comment lists.\n    if (comment.ignore) return PRINT_COMMENT_HINT.SKIP;\n\n    if (this._printedComments.has(comment)) return PRINT_COMMENT_HINT.SKIP;\n\n    if (\n      this._noLineTerminator &&\n      HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)\n    ) {\n      return PRINT_COMMENT_HINT.DEFER;\n    }\n\n    if (nextToken && this.tokenMap) {\n      const commentTok = this.tokenMap.find(\n        this._currentNode,\n        token => token.value === comment.value,\n      );\n      if (commentTok && commentTok.start > nextToken.start) {\n        return PRINT_COMMENT_HINT.DEFER;\n      }\n    }\n\n    this._printedComments.add(comment);\n\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return PRINT_COMMENT_HINT.SKIP;\n    }\n\n    return PRINT_COMMENT_HINT.ALLOW;\n  }\n\n  _printComment(comment: t.Comment, skipNewLines: COMMENT_SKIP_NEWLINE) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === \"CommentBlock\";\n\n    // Add a newline before and after a block comment, unless explicitly\n    // disallowed\n    const printNewLines =\n      isBlockComment &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.ALL &&\n      !this._noLineTerminator;\n\n    if (\n      printNewLines &&\n      this._buf.hasContent() &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.LEADING\n    ) {\n      this.newline(1);\n    }\n\n    const lastCharCode = this.getLastChar();\n    if (\n      lastCharCode !== charCodes.leftSquareBracket &&\n      lastCharCode !== charCodes.leftCurlyBrace &&\n      lastCharCode !== charCodes.leftParenthesis\n    ) {\n      this.space();\n    }\n\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        const offset = comment.loc?.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n        if (this.format.concise) {\n          val = val.replace(/\\n(?!$)/g, `\\n`);\n        } else {\n          let indentSize = this.format.retainLines\n            ? 0\n            : this._buf.getCurrentColumn();\n\n          if (this._shouldIndent(charCodes.slash) || this.format.retainLines) {\n            indentSize += this._getIndent();\n          }\n\n          val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n        }\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      // It was a single-line comment, so it's guaranteed to not\n      // contain newlines and it can be safely printed as a block\n      // comment.\n      val = `/*${comment.value}*/`;\n    }\n\n    // Avoid converting a / operator into a line comment by appending /* to it\n    if (this._endsWithDiv) this._space();\n\n    if (this.tokenMap) {\n      const { _printSemicolonBeforeNextToken, _printSemicolonBeforeNextNode } =\n        this;\n      this._printSemicolonBeforeNextToken = -1;\n      this._printSemicolonBeforeNextNode = -1;\n      this.source(\"start\", comment.loc);\n      this._append(val, isBlockComment);\n      this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;\n      this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;\n    } else {\n      this.source(\"start\", comment.loc);\n      this._append(val, isBlockComment);\n    }\n\n    if (!isBlockComment && !noLineTerminator) {\n      this.newline(1, true);\n    }\n\n    if (printNewLines && skipNewLines !== COMMENT_SKIP_NEWLINE.TRAILING) {\n      this.newline(1);\n    }\n  }\n\n  _printComments(\n    type: COMMENT_TYPE,\n    comments: readonly t.Comment[],\n    node: t.Node,\n    parent?: t.Node,\n    lineOffset: number = 0,\n    nextToken?: Token,\n  ) {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n\n    const maybeNewline = this._noLineTerminator\n      ? function () {}\n      : this.newline.bind(this);\n\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n\n      const shouldPrint = this._shouldPrintComment(comment, nextToken);\n      if (shouldPrint === PRINT_COMMENT_HINT.DEFER) {\n        hasLoc = false;\n        break;\n      }\n      if (hasLoc && comment.loc && shouldPrint === PRINT_COMMENT_HINT.ALLOW) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === COMMENT_TYPE.LEADING) {\n          let offset = 0;\n          if (i === 0) {\n            // Because currently we cannot handle blank lines before leading comments,\n            // we always wrap before and after multi-line comments.\n            if (\n              this._buf.hasContent() &&\n              (comment.type === \"CommentLine\" ||\n                commentStartLine !== commentEndLine)\n            ) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(\n              Math.max(nodeStartLine - lastLine, leadingCommentNewline),\n            );\n            lastLine = nodeStartLine;\n          }\n        } else if (type === COMMENT_TYPE.INNER) {\n          const offset =\n            commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(Math.min(1, nodeEndLine - lastLine)); // TODO: Improve here when inner comments processing is stronger\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset =\n            commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== PRINT_COMMENT_HINT.ALLOW) {\n          continue;\n        }\n\n        if (len === 1) {\n          const singleLine = comment.loc\n            ? comment.loc.start.line === comment.loc.end.line\n            : !HAS_NEWLINE.test(comment.value);\n\n          const shouldSkipNewline =\n            singleLine &&\n            !isStatement(node) &&\n            !isClassBody(parent) &&\n            !isTSInterfaceBody(parent) &&\n            !isTSEnumMember(node);\n\n          if (type === COMMENT_TYPE.LEADING) {\n            this._printComment(\n              comment,\n              (shouldSkipNewline && node.type !== \"ObjectExpression\") ||\n                (singleLine && isFunction(parent, { body: node }))\n                ? COMMENT_SKIP_NEWLINE.ALL\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n            );\n          } else if (shouldSkipNewline && type === COMMENT_TYPE.TRAILING) {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n          } else {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n          }\n        } else if (\n          type === COMMENT_TYPE.INNER &&\n          !(node.type === \"ObjectExpression\" && node.properties.length > 1) &&\n          node.type !== \"ClassBody\" &&\n          node.type !== \"TSInterfaceBody\"\n        ) {\n          // class X {\n          //   /*:: a: number*/\n          //   /*:: b: ?string*/\n          // }\n\n          this._printComment(\n            comment,\n            i === 0\n              ? COMMENT_SKIP_NEWLINE.LEADING\n              : i === len - 1\n                ? COMMENT_SKIP_NEWLINE.TRAILING\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n          );\n        } else {\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n        }\n      }\n    }\n\n    if (type === COMMENT_TYPE.TRAILING && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n  }\n}\n\n// Expose the node type functions and helpers on the prototype for easy usage.\nObject.assign(Printer.prototype, generatorFunctions);\n\nif (!process.env.BABEL_8_BREAKING) {\n  addDeprecatedGenerators(Printer);\n}\n\ntype GeneratorFunctions = typeof generatorFunctions;\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\ninterface Printer extends GeneratorFunctions {}\nexport default Printer;\n\nfunction commaSeparator(this: Printer, occurrenceCount: number, last: boolean) {\n  this.token(\",\", false, occurrenceCount);\n  if (!last) this.space();\n}\n", "import SourceMap from \"./source-map.ts\";\nimport Printer from \"./printer.ts\";\nimport type * as t from \"@babel/types\";\nimport type { Opts as jsescOptions } from \"jsesc\";\nimport type { Format } from \"./printer.ts\";\nimport type {\n  EncodedSourceMap,\n  DecodedSourceMap,\n  Mapping,\n} from \"@jridgewell/gen-mapping\";\n\n/**\n * Normalize generator options, setting defaults.\n *\n * - Detects code indentation.\n * - If `opts.compact = \"auto\"` and the code is over 500KB, `compact` will be set to `true`.\n */\n\nfunction normalizeOptions(\n  code: string | { [filename: string]: string },\n  opts: GeneratorOptions,\n  ast: t.Node,\n): Format {\n  if (opts.experimental_preserveFormat) {\n    if (typeof code !== \"string\") {\n      throw new Error(\n        \"`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string\",\n      );\n    }\n    if (!opts.retainLines) {\n      throw new Error(\n        \"`experimental_preserveFormat` requires `retainLines` to be set to `true`\",\n      );\n    }\n    if (opts.compact && opts.compact !== \"auto\") {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `compact` option\",\n      );\n    }\n    if (opts.minified) {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `minified` option\",\n      );\n    }\n    if (opts.jsescOption) {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `jsescOption` option\",\n      );\n    }\n    if (!Array.isArray((ast as any).tokens)) {\n      throw new Error(\n        \"`experimental_preserveFormat` requires the AST to have attached the token of the input code. Make sure to enable the `tokens: true` parser option.\",\n      );\n    }\n  }\n\n  const format: Format = {\n    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n    shouldPrintComment: opts.shouldPrintComment,\n    preserveFormat: opts.experimental_preserveFormat,\n    retainLines: opts.retainLines,\n    retainFunctionParens: opts.retainFunctionParens,\n    comments: opts.comments == null || opts.comments,\n    compact: opts.compact,\n    minified: opts.minified,\n    concise: opts.concise,\n    indent: {\n      adjustMultilineComment: true,\n      style: \"  \",\n    },\n    jsescOption: {\n      quotes: \"double\",\n      wrap: true,\n      minimal: process.env.BABEL_8_BREAKING ? true : false,\n      ...opts.jsescOption,\n    },\n    topicToken: opts.topicToken,\n    importAttributesKeyword: opts.importAttributesKeyword,\n  };\n\n  if (!process.env.BABEL_8_BREAKING) {\n    format.decoratorsBeforeExport = opts.decoratorsBeforeExport;\n    format.jsescOption.json = opts.jsonCompatibleStrings;\n    format.recordAndTupleSyntaxType = opts.recordAndTupleSyntaxType ?? \"hash\";\n  }\n\n  if (format.minified) {\n    format.compact = true;\n\n    format.shouldPrintComment =\n      format.shouldPrintComment || (() => format.comments);\n  } else {\n    format.shouldPrintComment =\n      format.shouldPrintComment ||\n      (value =>\n        format.comments ||\n        value.includes(\"@license\") ||\n        value.includes(\"@preserve\"));\n  }\n\n  if (format.compact === \"auto\") {\n    format.compact = typeof code === \"string\" && code.length > 500_000; // 500KB\n\n    if (format.compact) {\n      console.error(\n        \"[BABEL] Note: The code generator has deoptimised the styling of \" +\n          `${opts.filename} as it exceeds the max of ${\"500KB\"}.`,\n      );\n    }\n  }\n\n  if (format.compact || format.preserveFormat) {\n    format.indent.adjustMultilineComment = false;\n  }\n\n  const { auxiliaryCommentBefore, auxiliaryCommentAfter, shouldPrintComment } =\n    format;\n\n  if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {\n    format.auxiliaryCommentBefore = undefined;\n  }\n  if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {\n    format.auxiliaryCommentAfter = undefined;\n  }\n\n  return format;\n}\n\nexport interface GeneratorOptions {\n  /**\n   * Optional string to add as a block comment at the start of the output file.\n   */\n  auxiliaryCommentBefore?: string;\n\n  /**\n   * Optional string to add as a block comment at the end of the output file.\n   */\n  auxiliaryCommentAfter?: string;\n\n  /**\n   * Function that takes a comment (as a string) and returns true if the comment should be included in the output.\n   * By default, comments are included if `opts.comments` is `true` or if `opts.minified` is `false` and the comment\n   * contains `@preserve` or `@license`.\n   */\n  shouldPrintComment?(comment: string): boolean;\n\n  /**\n   * Preserve the input code format while printing the transformed code.\n   * This is experimental, and may have breaking changes in future\n   * patch releases. It will be removed in a future minor release,\n   * when it will graduate to stable.\n   */\n  experimental_preserveFormat?: boolean;\n\n  /**\n   * Attempt to use the same line numbers in the output code as in the source code (helps preserve stack traces).\n   * Defaults to `false`.\n   */\n  retainLines?: boolean;\n\n  /**\n   * Retain parens around function expressions (could be used to change engine parsing behavior)\n   * Defaults to `false`.\n   */\n  retainFunctionParens?: boolean;\n\n  /**\n   * Should comments be included in output? Defaults to `true`.\n   */\n  comments?: boolean;\n\n  /**\n   * Set to true to avoid adding whitespace for formatting. Defaults to the value of `opts.minified`.\n   */\n  compact?: boolean | \"auto\";\n\n  /**\n   * Should the output be minified. Defaults to `false`.\n   */\n  minified?: boolean;\n\n  /**\n   * Set to true to reduce whitespace (but not as much as opts.compact). Defaults to `false`.\n   */\n  concise?: boolean;\n\n  /**\n   * Used in warning messages\n   */\n  filename?: string;\n\n  /**\n   * Enable generating source maps. Defaults to `false`.\n   */\n  sourceMaps?: boolean;\n\n  inputSourceMap?: any;\n\n  /**\n   * A root for all relative URLs in the source map.\n   */\n  sourceRoot?: string;\n\n  /**\n   * The filename for the source code (i.e. the code in the `code` argument).\n   * This will only be used if `code` is a string.\n   */\n  sourceFileName?: string;\n\n  /**\n   * Set to true to run jsesc with \"json\": true to print \"\\u00A9\" vs. \"©\";\n   * @deprecated use `jsescOptions: { json: true }` instead\n   */\n  jsonCompatibleStrings?: boolean;\n\n  /**\n   * Set to true to enable support for experimental decorators syntax before\n   * module exports. If not specified, decorators will be printed in the same\n   * position as they were in the input source code.\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n\n  /**\n   * Options for outputting jsesc representation.\n   */\n  jsescOption?: jsescOptions;\n\n  /**\n   * For use with the recordAndTuple token.\n   * @deprecated It will be removed in Babel 8.\n   */\n  recordAndTupleSyntaxType?: \"bar\" | \"hash\";\n\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodies’ topic references.\n   */\n  topicToken?: \"%\" | \"#\" | \"@@\" | \"^^\" | \"^\";\n\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n}\n\nexport interface GeneratorResult {\n  code: string;\n  map: EncodedSourceMap | null;\n  decodedMap: DecodedSourceMap | undefined;\n  rawMappings: Mapping[] | undefined;\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /**\n   * We originally exported the Generator class above, but to make it extra clear that it is a private API,\n   * we have moved that to an internal class instance and simplified the interface to the two public methods\n   * that we wish to support.\n   */\n\n  // eslint-disable-next-line no-restricted-globals\n  exports.CodeGenerator = class CodeGenerator {\n    private _ast: t.Node;\n    private _format: Format | undefined;\n    private _map: SourceMap | null;\n    constructor(ast: t.Node, opts: GeneratorOptions = {}, code?: string) {\n      this._ast = ast;\n      this._format = normalizeOptions(code, opts, ast);\n      this._map = opts.sourceMaps ? new SourceMap(opts, code) : null;\n    }\n    generate(): GeneratorResult {\n      const printer = new Printer(this._format, this._map);\n\n      return printer.generate(this._ast);\n    }\n  };\n}\n\n/**\n * Turns an AST into code, maintaining sourcemaps, user preferences, and valid output.\n * @param ast - the abstract syntax tree from which to generate output code.\n * @param opts - used for specifying options for code generation.\n * @param code - the original source code, used for source maps.\n * @returns - an object containing the output code and source map.\n */\nexport function generate(\n  ast: t.Node,\n  opts: GeneratorOptions = {},\n  code?: string | { [filename: string]: string },\n): GeneratorResult {\n  const format = normalizeOptions(code, opts, ast);\n  const map = opts.sourceMaps ? new SourceMap(opts, code) : null;\n\n  const printer = new Printer(\n    format,\n    map,\n    (ast as any).tokens,\n    typeof code === \"string\" ? code : null,\n  );\n\n  return printer.generate(ast);\n}\n\nexport default generate;\n", "// This file contains that retrieve or validate anything related to the current paths ancestry.\n\nimport { VISITOR_KEYS } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type NodePath from \"./index.ts\";\n\n/**\n * Starting at the parent path of the current `NodePath` and going up the\n * tree, return the first `NodePath` that causes the provided `callback`\n * to return a truthy value, or `null` if the `callback` never returns a\n * truthy value.\n */\n\nexport function findParent(\n  this: NodePath,\n  callback: (path: NodePath) => boolean,\n): NodePath | null {\n  let path = this;\n  while ((path = path.parentPath)) {\n    if (callback(path)) return path;\n  }\n  return null;\n}\n\n/**\n * Starting at current `NodePath` and going up the tree, return the first\n * `NodePath` that causes the provided `callback` to return a truthy value,\n * or `null` if the `callback` never returns a truthy value.\n */\n\nexport function find(\n  this: NodePath,\n  callback: (path: NodePath) => boolean,\n): NodePath | null {\n  let path = this;\n  do {\n    if (callback(path)) return path;\n  } while ((path = path.parentPath));\n  return null;\n}\n\n/**\n * Get the parent function of the current path.\n */\n\nexport function getFunctionParent(this: NodePath): NodePath<t.Function> | null {\n  return this.findParent(p => p.isFunction()) as NodePath<t.Function> | null;\n}\n\n/**\n * Walk up the tree until we hit a parent node path in a list.\n */\n\nexport function getStatementParent(this: NodePath): NodePath<t.Statement> {\n  let path = this;\n\n  do {\n    if (\n      !path.parentPath ||\n      (Array.isArray(path.container) && path.isStatement())\n    ) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\n      \"File/Program node, we can't possibly find a statement parent to this\",\n    );\n  }\n\n  return path as NodePath<t.Statement>;\n}\n\n/**\n * Get the deepest common ancestor and then from it, get the earliest relationship path\n * to that ancestor.\n *\n * Earliest is defined as being \"before\" all the other nodes in terms of list container\n * position and visiting key.\n */\n\nexport function getEarliestCommonAncestorFrom(\n  this: NodePath,\n  paths: Array<NodePath>,\n): NodePath {\n  return this.getDeepestCommonAncestorFrom(\n    paths,\n    function (deepest, i, ancestries) {\n      let earliest;\n      const keys = VISITOR_KEYS[deepest.type];\n\n      for (const ancestry of ancestries) {\n        const path = ancestry[i + 1];\n\n        // first path\n        if (!earliest) {\n          earliest = path;\n          continue;\n        }\n\n        // handle containers\n        if (path.listKey && earliest.listKey === path.listKey) {\n          // we're in the same container so check if we're earlier\n          if (path.key < earliest.key) {\n            earliest = path;\n            continue;\n          }\n        }\n\n        // handle keys\n        const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n        const currentKeyIndex = keys.indexOf(path.parentKey);\n        if (earliestKeyIndex > currentKeyIndex) {\n          // key appears before so it's earlier\n          earliest = path;\n        }\n      }\n\n      return earliest;\n    },\n  );\n}\n\n/**\n * Get the earliest path in the tree where the provided `paths` intersect.\n *\n * TODO: Possible optimisation target.\n */\n\nexport function getDeepestCommonAncestorFrom(\n  this: NodePath,\n  paths: Array<NodePath>,\n  filter?: (deepest: NodePath, i: number, ancestries: NodePath[][]) => NodePath,\n): NodePath {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  // minimum depth of the tree so we know the highest node\n  let minDepth = Infinity;\n\n  // last common ancestor\n  let lastCommonIndex, lastCommon;\n\n  // get the ancestors of the path, breaking when the parent exceeds ourselves\n  const ancestries = paths.map(path => {\n    const ancestry: NodePath[] = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    // save min depth to avoid going too far in\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n\n  // get the first ancestry so we have a seed to assess all other ancestries with\n  const first = ancestries[0];\n\n  // check ancestor equality\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        // we've hit a snag\n        break depthLoop;\n      }\n    }\n\n    // next iteration may break so store these so they can be returned\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\n/**\n * Build an array of node paths containing the entire ancestry of the current node path.\n *\n * NOTE: The current node path is included in this.\n */\n\nexport function getAncestry(this: NodePath): Array<NodePath> {\n  let path = this;\n  const paths = [];\n  do {\n    paths.push(path);\n  } while ((path = path.parentPath));\n  return paths;\n}\n\n/**\n * A helper to find if `this` path is an ancestor of @param maybeDescendant\n */\nexport function isAncestor(this: NodePath, maybeDescendant: NodePath): boolean {\n  return maybeDescendant.isDescendant(this);\n}\n\n/**\n * A helper to find if `this` path is a descendant of @param maybeAncestor\n */\nexport function isDescendant(this: NodePath, maybeAncestor: NodePath): boolean {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nexport function inType(this: NodePath, ...candidateTypes: string[]): boolean {\n  let path = this;\n  while (path) {\n    if (candidateTypes.includes(path.node.type)) return true;\n    path = path.parentPath;\n  }\n\n  return false;\n}\n", "import {\n  createFlowUnionType,\n  createTSUnionType,\n  createUnionTypeAnnotation,\n  isFlowType,\n  isTSType,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nexport function createUnionType(\n  types: (t.FlowType | t.TSType)[],\n): t.FlowType | t.TSType | undefined {\n  if (process.env.BABEL_8_BREAKING) {\n    if (types.every(v => isFlowType(v))) {\n      return createFlowUnionType(types);\n    }\n    if (types.every(v => isTSType(v))) {\n      return createTSUnionType(types);\n    }\n  } else {\n    if (types.every(v => isFlowType(v))) {\n      if (createFlowUnionType) {\n        return createFlowUnionType(types);\n      }\n\n      return createUnionTypeAnnotation(types);\n    } else if (types.every(v => isTSType(v))) {\n      if (createTSUnionType) {\n        return createTSUnionType(types);\n      }\n    }\n  }\n}\n", "import type NodePath from \"../index.ts\";\nimport {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createTypeAnnotationBasedOnTypeof,\n  numberTypeAnnotation,\n  voidTypeAnnotation,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type Binding from \"../../scope/binding.ts\";\n\nimport { createUnionType } from \"./util.ts\";\n\nexport default function (this: NodePath<t.Identifier>, node: t.Identifier) {\n  if (!this.isReferenced()) return;\n\n  // check if a binding exists of this value and if so then return a union type of all\n  // possible types that the binding could be\n  const binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(\n        binding,\n        this,\n        node.name,\n      );\n    }\n  }\n\n  // built-in values\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {\n    // todo\n  }\n}\n\nfunction getTypeAnnotationBindingConstantViolations(\n  binding: Binding,\n  path: NodePath<t.Identifier>,\n  name: string,\n) {\n  const types = [];\n\n  const functionConstantViolations: NodePath[] = [];\n  let constantViolations = getConstantViolationsBefore(\n    binding,\n    path,\n    functionConstantViolations,\n  );\n\n  const testType = getConditionalAnnotation(binding, path, name);\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(\n      binding,\n      testType.ifStatement,\n    );\n\n    // remove constant violations observed before the IfStatement\n    constantViolations = constantViolations.filter(\n      path => !testConstantViolations.includes(path),\n    );\n\n    // clear current types and add in observed test type\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    // pick one constant from each scope which will represent the last possible\n    // control flow path that it could've taken/been\n    /* This code is broken for the following problems:\n     * It thinks that assignments can only happen in scopes.\n     * What about conditionals, if statements without block,\n     * or guarded assignments.\n     * It also checks to see if one of the assignments is in the\n     * same scope and uses that as the only \"violation\". However,\n     * the binding is returned by `getConstantViolationsBefore` so we for\n     * sure always going to return that as the only \"violation\".\n    let rawConstantViolations = constantViolations.reverse();\n    let visitedScopes = [];\n    constantViolations = [];\n    for (let violation of (rawConstantViolations: Array<NodePath>)) {\n      let violationScope = violation.scope;\n      if (visitedScopes.indexOf(violationScope) >= 0) continue;\n\n      visitedScopes.push(violationScope);\n      constantViolations.push(violation);\n\n      if (violationScope === path.scope) {\n        constantViolations = [violation];\n        break;\n      }\n    }*/\n\n    // add back on function constant violations since we can't track calls\n    constantViolations.push(...functionConstantViolations);\n\n    // push on inferred types of violated paths\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  return createUnionType(types);\n}\n\nfunction getConstantViolationsBefore(\n  binding: Binding,\n  path: NodePath,\n  functions?: NodePath[],\n) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n    const status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(\n  name: string,\n  path: NodePath<t.BinaryExpression>,\n) {\n  const operator = path.node.operator;\n\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n\n  let target;\n  if (left.isIdentifier({ name })) {\n    target = right;\n  } else if (right.isIdentifier({ name })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {\n      return numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n\n  let typeofPath: NodePath<t.UnaryExpression>;\n  let typePath: NodePath<t.Expression>;\n  if (left.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = left;\n    typePath = right as NodePath<t.Expression>;\n  } else if (right.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = right;\n    typePath = left as NodePath<t.Expression>;\n  }\n\n  if (!typeofPath) return;\n  // and that the argument of the typeof path references us!\n  if (!typeofPath.get(\"argument\").isIdentifier({ name })) return;\n\n  // ensure that the type path is a Literal\n  typePath = typePath.resolve() as NodePath<t.Expression>;\n  if (!typePath.isLiteral()) return;\n\n  // and that it's a string so we can infer it\n  // @ts-expect-error todo(flow->ts): value is not defined for NullLiteral and some other\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n\n  // turn type value into a type annotation\n  // @ts-expect-error todo(flow->ts): move validation from helper or relax type constraint to just a string\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(\n  binding: Binding,\n  path: NodePath,\n  name: string,\n) {\n  let parentPath;\n  while ((parentPath = path.parentPath)) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath as NodePath<t.IfStatement | t.ConditionalExpression>;\n    }\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation<T extends t.Node>(\n  binding: Binding,\n  path: NodePath<T>,\n  name?: string,\n): {\n  typeAnnotation: t.FlowType | t.TSType;\n  ifStatement: NodePath<t.IfStatement | t.ConditionalExpression>;\n} {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    return {\n      typeAnnotation: createUnionType(types),\n      ifStatement,\n    };\n  }\n\n  return getConditionalAnnotation(binding, ifStatement, name);\n}\n", "import {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  genericTypeAnnotation,\n  identifier,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation,\n  isIdentifier,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nexport { default as Identifier } from \"./inferer-reference.ts\";\n\nimport { createUnionType } from \"./util.ts\";\nimport type NodePath from \"../index.ts\";\n\nexport function VariableDeclarator(this: NodePath<t.VariableDeclarator>) {\n  if (!this.get(\"id\").isIdentifier()) return;\n  return this.get(\"init\").getTypeAnnotation();\n}\n\nexport function TypeCastExpression(node: t.TypeCastExpression) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nexport function TSAsExpression(node: t.TSAsExpression) {\n  return node.typeAnnotation;\n}\n\nTSAsExpression.validParent = true;\n\nexport function TSNonNullExpression(this: NodePath<t.TSNonNullExpression>) {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nexport function NewExpression(\n  this: NodePath<t.NewExpression>,\n  node: t.NewExpression,\n) {\n  if (node.callee.type === \"Identifier\") {\n    // only resolve identifier callee\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nexport function TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nexport function UnaryExpression(node: t.UnaryExpression) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.includes(operator)) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.includes(operator)) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {\n    return booleanTypeAnnotation();\n  }\n}\n\nexport function BinaryExpression(\n  this: NodePath<t.BinaryExpression>,\n  node: t.BinaryExpression,\n) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.includes(operator)) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      // both numbers so this will be a number\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      // one is a string so the result will be a string\n      return stringTypeAnnotation();\n    }\n\n    // unsure if left and right are strings or numbers so stay on the safe side\n    return unionTypeAnnotation([\n      stringTypeAnnotation(),\n      numberTypeAnnotation(),\n    ]);\n  }\n}\n\nexport function LogicalExpression(this: NodePath<t.LogicalExpression>) {\n  const argumentTypes = [\n    this.get(\"left\").getTypeAnnotation(),\n    this.get(\"right\").getTypeAnnotation(),\n  ];\n\n  return createUnionType(argumentTypes);\n}\n\nexport function ConditionalExpression(this: NodePath<t.ConditionalExpression>) {\n  const argumentTypes = [\n    this.get(\"consequent\").getTypeAnnotation(),\n    this.get(\"alternate\").getTypeAnnotation(),\n  ];\n\n  return createUnionType(argumentTypes);\n}\n\nexport function SequenceExpression(this: NodePath<t.SequenceExpression>) {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nexport function ParenthesizedExpression(\n  this: NodePath<t.ParenthesizedExpression>,\n) {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nexport function AssignmentExpression(this: NodePath<t.AssignmentExpression>) {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nexport function UpdateExpression(\n  this: NodePath<t.UpdateExpression>,\n  node: t.UpdateExpression,\n) {\n  const operator = node.operator;\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nexport function StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nexport function NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nexport function BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nexport function NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nexport function RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nexport function ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nexport function ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nexport function RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nexport {\n  Func as FunctionExpression,\n  Func as ArrowFunctionExpression,\n  Func as FunctionDeclaration,\n  Func as ClassExpression,\n  Func as ClassDeclaration,\n};\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\nexport function CallExpression(this: NodePath<t.CallExpression>) {\n  const { callee } = this.node;\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (\n    isArrayFrom(callee) ||\n    isObjectValues(callee) ||\n    // Detect \"var foo = Array()\" calls so we can optimize for arrays vs iterables.\n    isIdentifier(callee, { name: \"Array\" })\n  ) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(\n      tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]),\n    );\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nexport function TaggedTemplateExpression(\n  this: NodePath<t.TaggedTemplateExpression>,\n) {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee: NodePath) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    const { node } = callee;\n    if (node.async) {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"Iterator\"));\n      } else if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {\n        // todo: get union type of all return arguments\n      }\n    }\n  }\n}\n", "import type NodePath from \"../index.ts\";\nimport * as inferers from \"./inferers.ts\";\nimport {\n  anyTypeAnnotation,\n  isAnyTypeAnnotation,\n  isArrayTypeAnnotation,\n  isBooleanTypeAnnotation,\n  isEmptyTypeAnnotation,\n  isFlowBaseAnnotation,\n  isGenericTypeAnnotation,\n  isIdentifier,\n  isMixedTypeAnnotation,\n  isNumberTypeAnnotation,\n  isStringTypeAnnotation,\n  isTSArrayType,\n  isTSTypeAnnotation,\n  isTSTypeReference,\n  isTupleTypeAnnotation,\n  isTypeAnnotation,\n  isUnionTypeAnnotation,\n  isVoidTypeAnnotation,\n  stringTypeAnnotation,\n  voidTypeAnnotation,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n/**\n * Infer the type of the current `NodePath`.\n */\n\nexport function getTypeAnnotation(this: NodePath): t.FlowType | t.TSType {\n  let type = this.getData(\"typeAnnotation\");\n  if (type != null) {\n    return type;\n  }\n  type = _getTypeAnnotation.call(this) || anyTypeAnnotation();\n  if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {\n    type = type.typeAnnotation;\n  }\n  this.setData(\"typeAnnotation\", type);\n  return type;\n}\n\n// Used to avoid infinite recursion in cases like\n//   var b, c; if (0) { c = 1; b = c; } c = b;\n// It also works with indirect recursion.\nconst typeAnnotationInferringNodes = new WeakSet();\n\n/**\n * todo: split up this method\n */\n\nexport function _getTypeAnnotation(this: NodePath): any {\n  const node = this.node;\n\n  if (!node) {\n    // handle initializerless variables, add in checks for loop initializers too\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      // for (let NODE in bar) {}\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return stringTypeAnnotation();\n      }\n\n      // for (let NODE of bar) {}\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return anyTypeAnnotation();\n      }\n\n      return voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  // @ts-expect-error typeAnnotation may not index node\n  if (node.typeAnnotation) {\n    // @ts-expect-error typeAnnotation may not index node\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    // Bail out from type inference to avoid infinite loops\n    return;\n  }\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    let inferer =\n      // @ts-expect-error inferers do not cover all AST types\n      inferers[node.type];\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    // @ts-expect-error inferers do not cover all AST types\n    inferer = inferers[this.parentPath.type];\n    if (inferer?.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nexport function isBaseType(\n  this: NodePath,\n  baseName: string,\n  soft?: boolean,\n): boolean {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(\n  baseName: string,\n  type?: t.FlowType | t.TSType,\n  soft?: boolean,\n): boolean {\n  if (baseName === \"string\") {\n    return isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nexport function couldBeBaseType(this: NodePath, name: string): boolean {\n  const type = this.getTypeAnnotation();\n  if (isAnyTypeAnnotation(type)) return true;\n\n  if (isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nexport function baseTypeStrictlyMatches(\n  this: NodePath,\n  rightArg: NodePath,\n): boolean {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n  return false;\n}\n\nexport function isGenericType(this: NodePath, genericName: string): boolean {\n  const type = this.getTypeAnnotation();\n  if (genericName === \"Array\") {\n    // T[]\n    if (\n      isTSArrayType(type) ||\n      isArrayTypeAnnotation(type) ||\n      isTupleTypeAnnotation(type)\n    ) {\n      return true;\n    }\n  }\n  return (\n    (isGenericTypeAnnotation(type) &&\n      isIdentifier(type.id, {\n        name: genericName,\n      })) ||\n    (isTSTypeReference(type) &&\n      isIdentifier(type.typeName, {\n        name: genericName,\n      }))\n  );\n}\n", "var x=String;\nvar create=function() {return {isColorSupported:false,reset:x,bold:x,dim:x,italic:x,underline:x,inverse:x,hidden:x,strikethrough:x,black:x,red:x,green:x,yellow:x,blue:x,magenta:x,cyan:x,white:x,gray:x,bgBlack:x,bgRed:x,bgGreen:x,bgYellow:x,bgBlue:x,bgMagenta:x,bgCyan:x,bgWhite:x,blackBright:x,redBright:x,greenBright:x,yellowBright:x,blueBright:x,magentaBright:x,cyanBright:x,whiteBright:x,bgBlackBright:x,bgRedBright:x,bgGreenBright:x,bgYellowBright:x,bgBlueBright:x,bgMagentaBright:x,bgCyanBright:x,bgWhiteBright:x}};\nmodule.exports=create();\nmodule.exports.createColors = create;\n", "// Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell\n// License: MIT. (See LICENSE.)\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n})\n\n// This regex comes from regex.coffee, and is inserted here by generate-index.js\n// (run `npm run build`).\nexports.default = /((['\"])(?:(?!\\2|\\\\).|\\\\(?:\\r\\n|[\\s\\S]))*(\\2)?|`(?:[^`\\\\$]|\\\\[\\s\\S]|\\$(?!\\{)|\\$\\{(?:[^{}]|\\{[^}]*\\}?)*\\}?)*(`)?)|(\\/\\/.*)|(\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?)|(\\/(?!\\*)(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)+\\/(?:(?!\\s*(?:\\b|[\\u0080-\\uFFFF$\\\\'\"~({]|[+\\-!](?!=)|\\.?\\d))|[gmiyus]{1,6}\\b(?![\\u0080-\\uFFFF$\\\\]|\\s*(?:[+\\-*%&|^<>!=?({]|\\/(?![\\/*])))))|(0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?)|((?!\\d)(?:(?!\\s)[$\\w\\u0080-\\uFFFF]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+)|(--|\\+\\+|&&|\\|\\||=>|\\.{3}|(?:[+\\-\\/%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\\](){}])|(\\s+)|(^$|[\\s\\S])/g\n\nexports.matchToToken = function(match) {\n  var token = {type: \"invalid\", value: match[0], closed: undefined}\n       if (match[ 1]) token.type = \"string\" , token.closed = !!(match[3] || match[4])\n  else if (match[ 5]) token.type = \"comment\"\n  else if (match[ 6]) token.type = \"comment\", token.closed = !!match[7]\n  else if (match[ 8]) token.type = \"regex\"\n  else if (match[ 9]) token.type = \"number\"\n  else if (match[10]) token.type = \"name\"\n  else if (match[11]) token.type = \"punctuator\"\n  else if (match[12]) token.type = \"whitespace\"\n  return token\n}\n", "import picocolors, { createColors } from \"picocolors\";\nimport type { Colors, Formatter } from \"picocolors/types\";\n\nexport function isColorSupported() {\n  return (\n    // See https://github.com/alexeyraspopov/picocolors/issues/62\n    typeof process === \"object\" &&\n      (process.env.FORCE_COLOR === \"0\" || process.env.FORCE_COLOR === \"false\")\n      ? false\n      : picocolors.isColorSupported\n  );\n}\n\nexport type InternalTokenType =\n  | \"keyword\"\n  | \"capitalized\"\n  | \"jsxIdentifier\"\n  | \"punctuator\"\n  | \"number\"\n  | \"string\"\n  | \"regex\"\n  | \"comment\"\n  | \"invalid\";\n\ntype UITokens = \"gutter\" | \"marker\" | \"message\";\n\nexport type Defs = {\n  [_ in InternalTokenType | UITokens | \"reset\"]: Formatter;\n};\n\nconst compose: <T, U, V>(f: (gv: U) => V, g: (v: T) => U) => (v: T) => V =\n  (f, g) => v =>\n    f(g(v));\n\n/**\n * Styles for token types.\n */\nfunction buildDefs(colors: Colors): Defs {\n  return {\n    keyword: colors.cyan,\n    capitalized: colors.yellow,\n    jsxIdentifier: colors.yellow,\n    punctuator: colors.yellow,\n    number: colors.magenta,\n    string: colors.green,\n    regex: colors.magenta,\n    comment: colors.gray,\n    invalid: compose(compose(colors.white, colors.bgRed), colors.bold),\n\n    gutter: colors.gray,\n    marker: compose(colors.red, colors.bold),\n    message: compose(colors.red, colors.bold),\n\n    reset: colors.reset,\n  };\n}\n\nconst defsOn = buildDefs(createColors(true));\nconst defsOff = buildDefs(createColors(false));\n\nexport function getDefs(enabled: boolean): Defs {\n  return enabled ? defsOn : defsOff;\n}\n", "import type { Token as JSToken, JSXToken } from \"js-tokens\";\nimport jsTokens from \"js-tokens\";\n\nimport {\n  isStrictReservedWord,\n  isKeyword,\n} from \"@babel/helper-validator-identifier\";\n\nimport { getDefs, type InternalTokenType } from \"./defs.ts\";\n\n/**\n * Names that are always allowed as identifiers, but also appear as keywords\n * within certain syntactic productions.\n *\n * https://tc39.es/ecma262/#sec-keywords-and-reserved-words\n *\n * `target` has been omitted since it is very likely going to be a false\n * positive.\n */\nconst sometimesKeywords = new Set([\"as\", \"async\", \"from\", \"get\", \"of\", \"set\"]);\n\ntype Token = {\n  type: InternalTokenType | \"uncolored\";\n  value: string;\n};\n\n/**\n * RegExp to test for newlines in terminal.\n */\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\n/**\n * RegExp to test for the three types of brackets.\n */\nconst BRACKET = /^[()[\\]{}]$/;\n\nlet tokenize: (\n  text: string,\n) => Generator<{ type: InternalTokenType | \"uncolored\"; value: string }>;\n\nif (process.env.BABEL_8_BREAKING) {\n  /**\n   * Get the type of token, specifying punctuator type.\n   */\n  const getTokenType = function (\n    token: JSToken | JSXToken,\n  ): InternalTokenType | \"uncolored\" {\n    if (token.type === \"IdentifierName\") {\n      if (\n        isKeyword(token.value) ||\n        isStrictReservedWord(token.value, true) ||\n        sometimesKeywords.has(token.value)\n      ) {\n        return \"keyword\";\n      }\n\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return \"capitalized\";\n      }\n    }\n\n    if (token.type === \"Punctuator\" && BRACKET.test(token.value)) {\n      return \"uncolored\";\n    }\n\n    if (token.type === \"Invalid\" && token.value === \"@\") {\n      return \"punctuator\";\n    }\n\n    switch (token.type) {\n      case \"NumericLiteral\":\n        return \"number\";\n\n      case \"StringLiteral\":\n      case \"JSXString\":\n      case \"NoSubstitutionTemplate\":\n        return \"string\";\n\n      case \"RegularExpressionLiteral\":\n        return \"regex\";\n\n      case \"Punctuator\":\n      case \"JSXPunctuator\":\n        return \"punctuator\";\n\n      case \"MultiLineComment\":\n      case \"SingleLineComment\":\n        return \"comment\";\n\n      case \"Invalid\":\n      case \"JSXInvalid\":\n        return \"invalid\";\n\n      case \"JSXIdentifier\":\n        return \"jsxIdentifier\";\n\n      default:\n        return \"uncolored\";\n    }\n  };\n\n  /**\n   * Turn a string of JS into an array of objects.\n   */\n  tokenize = function* (text: string): Generator<Token> {\n    for (const token of jsTokens(text, { jsx: true })) {\n      switch (token.type) {\n        case \"TemplateHead\":\n          yield { type: \"string\", value: token.value.slice(0, -2) };\n          yield { type: \"punctuator\", value: \"${\" };\n          break;\n\n        case \"TemplateMiddle\":\n          yield { type: \"punctuator\", value: \"}\" };\n          yield { type: \"string\", value: token.value.slice(1, -2) };\n          yield { type: \"punctuator\", value: \"${\" };\n          break;\n\n        case \"TemplateTail\":\n          yield { type: \"punctuator\", value: \"}\" };\n          yield { type: \"string\", value: token.value.slice(1) };\n          break;\n\n        default:\n          yield {\n            type: getTokenType(token),\n            value: token.value,\n          };\n      }\n    }\n  };\n} else {\n  /**\n   * RegExp to test for what seems to be a JSX tag name.\n   */\n  const JSX_TAG = /^[a-z][\\w-]*$/i;\n\n  // The token here is defined in js-tokens@4. However we don't bother\n  // typing it since the whole block will be removed in Babel 8\n  const getTokenType = function (token: any, offset: number, text: string) {\n    if (token.type === \"name\") {\n      if (\n        isKeyword(token.value) ||\n        isStrictReservedWord(token.value, true) ||\n        sometimesKeywords.has(token.value)\n      ) {\n        return \"keyword\";\n      }\n\n      if (\n        JSX_TAG.test(token.value) &&\n        (text[offset - 1] === \"<\" || text.slice(offset - 2, offset) === \"</\")\n      ) {\n        return \"jsxIdentifier\";\n      }\n\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return \"capitalized\";\n      }\n    }\n\n    if (token.type === \"punctuator\" && BRACKET.test(token.value)) {\n      return \"bracket\";\n    }\n\n    if (\n      token.type === \"invalid\" &&\n      (token.value === \"@\" || token.value === \"#\")\n    ) {\n      return \"punctuator\";\n    }\n\n    return token.type;\n  };\n\n  tokenize = function* (text: string) {\n    let match;\n    while ((match = (jsTokens as any).default.exec(text))) {\n      const token = (jsTokens as any).matchToToken(match);\n\n      yield {\n        type: getTokenType(token, match.index, text),\n        value: token.value,\n      };\n    }\n  };\n}\n\nexport function highlight(text: string) {\n  if (text === \"\") return \"\";\n\n  const defs = getDefs(true);\n\n  let highlighted = \"\";\n\n  for (const { type, value } of tokenize(text)) {\n    if (type in defs) {\n      highlighted += value\n        .split(NEWLINE)\n        .map(str => defs[type as InternalTokenType](str))\n        .join(\"\\n\");\n    } else {\n      highlighted += value;\n    }\n  }\n\n  return highlighted;\n}\n", "import { getDefs, isColorSupported } from \"./defs.ts\";\nimport { highlight } from \"./highlight.ts\";\n\nexport { highlight };\n\nlet deprecationWarningShown = false;\n\ntype Location = {\n  column: number;\n  line: number;\n};\n\ntype NodeLocation = {\n  end?: Location;\n  start: Location;\n};\n\nexport interface Options {\n  /** Syntax highlight the code as JavaScript for terminals. default: false */\n  highlightCode?: boolean;\n  /**  The number of lines to show above the error. default: 2 */\n  linesAbove?: number;\n  /**  The number of lines to show below the error. default: 3 */\n  linesBelow?: number;\n  /**\n   * Forcibly syntax highlight the code as JavaScript (for non-terminals);\n   * overrides highlightCode.\n   * default: false\n   */\n  forceColor?: boolean;\n  /**\n   * Pass in a string to be displayed inline (if possible) next to the\n   * highlighted location in the code. If it can't be positioned inline,\n   * it will be placed above the code frame.\n   * default: nothing\n   */\n  message?: string;\n}\n\n/**\n * RegExp to test for newlines in terminal.\n */\n\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\n/**\n * Extract what lines should be marked and highlighted.\n */\n\ntype MarkerLines = Record<number, true | [number, number]>;\n\nfunction getMarkerLines(\n  loc: NodeLocation,\n  source: Array<string>,\n  opts: Options,\n): {\n  start: number;\n  end: number;\n  markerLines: MarkerLines;\n} {\n  const startLoc: Location = {\n    column: 0,\n    line: -1,\n    ...loc.start,\n  };\n  const endLoc: Location = {\n    ...startLoc,\n    ...loc.end,\n  };\n  const { linesAbove = 2, linesBelow = 3 } = opts || {};\n  const startLine = startLoc.line;\n  const startColumn = startLoc.column;\n  const endLine = endLoc.line;\n  const endColumn = endLoc.column;\n\n  let start = Math.max(startLine - (linesAbove + 1), 0);\n  let end = Math.min(source.length, endLine + linesBelow);\n\n  if (startLine === -1) {\n    start = 0;\n  }\n\n  if (endLine === -1) {\n    end = source.length;\n  }\n\n  const lineDiff = endLine - startLine;\n  const markerLines: MarkerLines = {};\n\n  if (lineDiff) {\n    for (let i = 0; i <= lineDiff; i++) {\n      const lineNumber = i + startLine;\n\n      if (!startColumn) {\n        markerLines[lineNumber] = true;\n      } else if (i === 0) {\n        const sourceLength = source[lineNumber - 1].length;\n\n        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];\n      } else if (i === lineDiff) {\n        markerLines[lineNumber] = [0, endColumn];\n      } else {\n        const sourceLength = source[lineNumber - i].length;\n\n        markerLines[lineNumber] = [0, sourceLength];\n      }\n    }\n  } else {\n    if (startColumn === endColumn) {\n      if (startColumn) {\n        markerLines[startLine] = [startColumn, 0];\n      } else {\n        markerLines[startLine] = true;\n      }\n    } else {\n      markerLines[startLine] = [startColumn, endColumn - startColumn];\n    }\n  }\n\n  return { start, end, markerLines };\n}\n\nexport function codeFrameColumns(\n  rawLines: string,\n  loc: NodeLocation,\n  opts: Options = {},\n): string {\n  const shouldHighlight =\n    opts.forceColor || (isColorSupported() && opts.highlightCode);\n  const defs = getDefs(shouldHighlight);\n\n  const lines = rawLines.split(NEWLINE);\n  const { start, end, markerLines } = getMarkerLines(loc, lines, opts);\n  const hasColumns = loc.start && typeof loc.start.column === \"number\";\n\n  const numberMaxWidth = String(end).length;\n\n  const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;\n\n  let frame = highlightedLines\n    .split(NEWLINE, end)\n    .slice(start, end)\n    .map((line, index) => {\n      const number = start + 1 + index;\n      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);\n      const gutter = ` ${paddedNumber} |`;\n      const hasMarker = markerLines[number];\n      const lastMarkerLine = !markerLines[number + 1];\n      if (hasMarker) {\n        let markerLine = \"\";\n        if (Array.isArray(hasMarker)) {\n          const markerSpacing = line\n            .slice(0, Math.max(hasMarker[0] - 1, 0))\n            .replace(/[^\\t]/g, \" \");\n          const numberOfMarkers = hasMarker[1] || 1;\n\n          markerLine = [\n            \"\\n \",\n            defs.gutter(gutter.replace(/\\d/g, \" \")),\n            \" \",\n            markerSpacing,\n            defs.marker(\"^\").repeat(numberOfMarkers),\n          ].join(\"\");\n\n          if (lastMarkerLine && opts.message) {\n            markerLine += \" \" + defs.message(opts.message);\n          }\n        }\n        return [\n          defs.marker(\">\"),\n          defs.gutter(gutter),\n          line.length > 0 ? ` ${line}` : \"\",\n          markerLine,\n        ].join(\"\");\n      } else {\n        return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : \"\"}`;\n      }\n    })\n    .join(\"\\n\");\n\n  if (opts.message && !hasColumns) {\n    frame = `${\" \".repeat(numberMaxWidth + 1)}${opts.message}\\n${frame}`;\n  }\n\n  if (shouldHighlight) {\n    return defs.reset(frame);\n  } else {\n    return frame;\n  }\n}\n\n/**\n * Create a code frame, adding line numbers, code highlighting, and pointing to a given position.\n */\n\nexport default function (\n  rawLines: string,\n  lineNumber: number,\n  colNumber?: number | null,\n  opts: Options = {},\n): string {\n  if (!deprecationWarningShown) {\n    deprecationWarningShown = true;\n\n    const message =\n      \"Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.\";\n\n    if (process.emitWarning) {\n      // A string is directly supplied to emitWarning, because when supplying an\n      // Error object node throws in the tests because of different contexts\n      process.emitWarning(message, \"DeprecationWarning\");\n    } else {\n      const deprecationError = new Error(message);\n      deprecationError.name = \"DeprecationWarning\";\n      console.warn(new Error(message));\n    }\n  }\n\n  colNumber = Math.max(colNumber, 0);\n\n  const location: NodeLocation = {\n    start: { column: colNumber, line: lineNumber },\n  };\n\n  return codeFrameColumns(rawLines, location, opts);\n}\n", "// this file contains hooks that handle ancestry cleanup of parent nodes when removing children\n\nimport type NodePath from \"../index.ts\";\nimport type * as t from \"@babel/types\";\n/**\n * Pre hooks should be used for either rejecting removal or delegating removal\n */\n\nexport const hooks = [\n  function (self: NodePath, parent: NodePath) {\n    const removeParent =\n      // while (NODE);\n      // removing the test of a while/switch, we can either just remove it entirely *or* turn the\n      // `test` into `true` unlikely that the latter will ever be what's wanted so we just remove\n      // the loop to avoid infinite recursion\n      (self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase())) ||\n      // export NODE;\n      // just remove a declaration for an export as this is no longer valid\n      (self.key === \"declaration\" && parent.isExportDeclaration()) ||\n      // label: NODE\n      // stray labeled statement with no body\n      (self.key === \"body\" && parent.isLabeledStatement()) ||\n      // let NODE;\n      // remove an entire declaration if there are no declarators left\n      (self.listKey === \"declarations\" &&\n        parent.isVariableDeclaration() &&\n        parent.node.declarations.length === 1) ||\n      // NODE;\n      // remove the entire expression statement if there's no expression\n      (self.key === \"expression\" && parent.isExpressionStatement());\n\n    if (removeParent) {\n      parent.remove();\n      return true;\n    }\n  },\n\n  function (self: NodePath, parent: NodePath) {\n    if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n      // (node, NODE);\n      // we've just removed the second element of a sequence expression so let's turn that sequence\n      // expression into a regular expression\n      parent.replaceWith(parent.node.expressions[0]);\n      return true;\n    }\n  },\n\n  function (self: NodePath, parent: NodePath) {\n    if (parent.isBinary()) {\n      // left + NODE;\n      // NODE + right;\n      // we're in a binary expression, better remove it and replace it with the last expression\n      if (self.key === \"left\") {\n        parent.replaceWith(parent.node.right);\n      } else {\n        // key === \"right\"\n        parent.replaceWith(parent.node.left);\n      }\n      return true;\n    }\n  },\n\n  function (self: NodePath, parent: NodePath) {\n    if (\n      (parent.isIfStatement() && self.key === \"consequent\") ||\n      (self.key === \"body\" &&\n        (parent.isLoop() || parent.isArrowFunctionExpression()))\n    ) {\n      self.replaceWith({\n        type: \"BlockStatement\",\n        body: [],\n      } as t.BlockStatement);\n      return true;\n    }\n  },\n];\n", "// This file contains methods responsible for removing a node.\n\nimport { hooks } from \"./lib/removal-hooks.ts\";\nimport { getCachedPaths } from \"../cache.ts\";\nimport { _replaceWith } from \"./replacement.ts\";\nimport type NodePath from \"./index.ts\";\nimport { REMOVED, SHOULD_SKIP } from \"./index.ts\";\nimport { getBindingIdentifiers } from \"@babel/types\";\nimport { updateSiblingKeys } from \"./modification.ts\";\nimport { resync } from \"./context.ts\";\n\nexport function remove(this: NodePath) {\n  _assertUnremoved.call(this);\n\n  resync.call(this);\n\n  if (_callRemovalHooks.call(this)) {\n    _markRemoved.call(this);\n    return;\n  }\n\n  if (!this.opts?.noScope) {\n    _removeFromScope.call(this);\n  }\n\n  this.shareCommentsWithSiblings();\n  _remove.call(this);\n  _markRemoved.call(this);\n}\n\nexport function _removeFromScope(this: NodePath) {\n  const bindings = getBindingIdentifiers(this.node, false, false, true);\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nexport function _callRemovalHooks(this: NodePath) {\n  if (this.parentPath) {\n    for (const fn of hooks) {\n      if (fn(this, this.parentPath)) return true;\n    }\n  }\n}\n\nexport function _remove(this: NodePath) {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key as number, 1);\n    updateSiblingKeys.call(this, this.key as number, -1);\n  } else {\n    _replaceWith.call(this, null);\n  }\n}\n\nexport function _markRemoved(this: NodePath) {\n  // this.shouldSkip = true; this.removed = true;\n  this._traverseFlags |= SHOULD_SKIP | REMOVED;\n  if (this.parent) {\n    getCachedPaths(this)?.delete(this.node);\n  }\n  this.node = null;\n}\n\nexport function _assertUnremoved(this: NodePath) {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\n      \"NodePath has been removed so is read-only.\",\n    );\n  }\n}\n", "// TODO: Remove this file in Babel 8\n\nimport { react } from \"@babel/types\";\nimport {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type Scope from \"../../scope/index.ts\";\nimport type NodePath from \"../index.ts\";\nimport type Binding from \"../../scope/binding.ts\";\nimport type { Visitor } from \"../../types.ts\";\n\nconst referenceVisitor: Visitor<PathHoister> = {\n  // This visitor looks for bindings to establish a topmost scope for hoisting.\n  ReferencedIdentifier(path, state) {\n    // Don't hoist regular JSX identifiers ('div', 'span', etc).\n    // We do have to consider member expressions for hoisting (e.g. `this.component`)\n    if (\n      path.isJSXIdentifier() &&\n      react.isCompatTag(path.node.name) &&\n      !path.parentPath.isJSXMemberExpression()\n    ) {\n      return;\n    }\n\n    // If the identifier refers to `this`, we need to break on the closest non-arrow scope.\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n      do {\n        if (\n          scope.path.isFunction() &&\n          !scope.path.isArrowFunctionExpression()\n        ) {\n          break;\n        }\n      } while ((scope = scope.parent));\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    // direct references that we need to track to hoist this to the highest scope we can\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    // we can handle reassignments only if they happen in the same scope as the declaration\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    // this binding isn't accessible from the parent scope so we can safely ignore it\n    // eg. it's in a closure etc\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n\n    state.bindings[path.node.name] = binding;\n  },\n};\n\nexport default class PathHoister<T extends t.Node = t.Node> {\n  breakOnScopePaths: NodePath[];\n  bindings: { [k: string]: Binding };\n  mutableBinding: boolean;\n  private scopes: Scope[];\n  scope: Scope;\n  private path: NodePath<T>;\n  private attachAfter: boolean;\n\n  constructor(path: NodePath<T>, scope: Scope) {\n    // Storage for scopes we can't hoist above.\n    this.breakOnScopePaths = [];\n    // Storage for bindings that may affect what path we can hoist to.\n    this.bindings = {};\n    // \"true\" if the current path contains a reference to a binding whose\n    // value can change and thus can't be safely hoisted.\n    this.mutableBinding = false;\n    // Storage for eligible scopes.\n    this.scopes = [];\n    // Our original scope and path.\n    this.scope = scope;\n    this.path = path;\n    // By default, we attach as far up as we can; but if we're trying\n    // to avoid referencing a binding, we may have to go after.\n    this.attachAfter = false;\n  }\n\n  // A scope is compatible if all required bindings are reachable.\n  isCompatibleScope(scope: Scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Look through all scopes and push compatible ones.\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      // deopt: These scopes are set in the visitor on const violations\n      if (this.breakOnScopePaths.includes(scope.path)) {\n        break;\n      }\n    } while ((scope = scope.parent));\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n    if (!path) return;\n\n    let targetScope = path.scope;\n\n    // don't allow paths that have their own lexical environments to pollute\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    // avoid hoisting to a scope that contains bindings that are executed after our attachment path\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        // check binding is a direct child of this paths scope\n        if (!targetScope.hasOwnBinding(name)) continue;\n\n        const binding = this.bindings[name];\n\n        // allow parameter references and expressions in params (like destructuring rest)\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        // For each binding, get its attachment parent. This gives us an idea of where we might\n        // introduce conflicts.\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        // If the binding's attachment appears at or after our attachment point, then we move after it.\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          // We also move past any constant violations.\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n\n    const scope = scopes.pop();\n    // deopt: no compatible scopes\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        // deopt: should ignore this scope since it's ourselves\n        if (this.scope === scope) return;\n\n        // needs to be attached to the body\n        const bodies = scope.path.get(\"body\").get(\"body\") as NodePath[];\n        for (let i = 0; i < bodies.length; i++) {\n          // Don't attach to something that's going to get hoisted,\n          // like a default parameter\n          // @ts-expect-error todo(flow->ts): avoid mutating the node, introducing new fields\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n        // deopt: If here, no attachment path found\n      } else {\n        // doesn't need to be be attached to this scope\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  // Find an attachment for this path.\n  getAttachmentParentForPath(path: NodePath) {\n    do {\n      if (\n        // Beginning of the scope\n        !path.parentPath ||\n        // Has siblings and is a statement\n        (Array.isArray(path.container) && path.isStatement())\n      ) {\n        return path;\n      }\n    } while ((path = path.parentPath));\n  }\n\n  // Returns true if a scope has param bindings.\n  hasOwnParamBindings(scope: Scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n\n      const binding = this.bindings[name];\n      // Ensure constant; without it we could place behind a reassignment\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n    return false;\n  }\n\n  run(): NodePath<t.Expression> | undefined {\n    this.path.traverse(referenceVisitor, this);\n\n    if (this.mutableBinding) return;\n\n    this.getCompatibleScopes();\n\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n\n    // don't bother hoisting to the same function as this will cause multiple branches to be\n    // evaluated more than once leading to a bad optimisation\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n\n    // generate declaration and insert it to our point\n    let uid: t.Identifier | t.JSXExpressionContainer =\n      attachTo.scope.generateUidIdentifier(\"ref\");\n\n    // @ts-expect-error todo(flow->ts): more specific type for this.path\n    const declarator = variableDeclarator(uid, this.path.node);\n\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([\n      attachTo.isVariableDeclarator()\n        ? declarator\n        : variableDeclaration(\"var\", [declarator]),\n    ]);\n\n    const parent = this.path.parentPath;\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      // turning the `span` in `<div><span /></div>` to an expression so we need to wrap it with\n      // an expression container\n      uid = jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(cloneNode(uid));\n\n    // TODO: Should we use `attached.isVariableDeclaration()`?\n    return attachTo.isVariableDeclarator()\n      ? // @ts-expect-error TS cannot refine the type of `attached`\n        attached.get(\"init\")\n      : attached.get(\"declarations.0.init\");\n  }\n}\n", "// This file contains methods that modify the path/node in some ways.\n\nimport { getCachedPaths } from \"../cache.ts\";\nimport NodePath from \"./index.ts\";\nimport { _getQueueContexts, pushContext, setScope } from \"./context.ts\";\nimport { _assertUnremoved } from \"./removal.ts\";\nimport {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isAssignmentExpression,\n  isCallExpression,\n  isExportNamedDeclaration,\n  isExpression,\n  isIdentifier,\n  isSequenceExpression,\n  isSuper,\n  thisExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type Scope from \"../scope/index.ts\";\n\n/**\n * Insert the provided nodes before the current one.\n */\n\nexport function insertBefore(\n  this: NodePath,\n  nodes_: t.Node | t.Node[],\n): NodePath[] {\n  _assertUnremoved.call(this);\n\n  const nodes = _verifyNodeList.call(this, nodes_);\n\n  const { parentPath, parent } = this;\n\n  if (\n    parentPath.isExpressionStatement() ||\n    parentPath.isLabeledStatement() ||\n    // https://github.com/babel/babel/issues/15293\n    // When Babel transforms `export class String { field }`, the class properties plugin will inject the defineProperty\n    // helper, which depends on the builtins e.g. String, Number, Symbol, etc. To prevent them from being shadowed by local\n    // exports, the helper injector replaces the named export into `class _String { field }; export { _String as String }`,\n    // with `parentPath` here changed to the moved ClassDeclaration, causing rare inconsistency between `parent` and `parentPath`.\n    // Here we retrieve the parent type from the `parent` property. This is a temporary fix and we should revisit when\n    // helpers should get injected.\n    isExportNamedDeclaration(parent) ||\n    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())\n  ) {\n    return parentPath.insertBefore(nodes);\n  } else if (\n    (this.isNodeType(\"Expression\") && !this.isJSXElement()) ||\n    (parentPath.isForStatement() && this.key === \"init\")\n  ) {\n    if (this.node) nodes.push(this.node);\n    // @ts-expect-error todo(flow->ts): check that nodes is an array of statements\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return _containerInsertBefore.call(this, nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node as t.Statement;\n    const shouldInsertCurrentNode =\n      node &&\n      (!this.isExpressionStatement() ||\n        (node as t.ExpressionStatement).expression != null);\n\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return (this as NodePath<t.BlockStatement>).unshiftContainer(\n      \"body\",\n      // @ts-expect-error Fixme: refine nodes to t.BlockStatement[\"body\"] when this is a BlockStatement path\n      nodes,\n    );\n  } else {\n    throw new Error(\n      \"We don't know what to do with this node type. \" +\n        \"We were previously a Statement but we can't fit in here?\",\n    );\n  }\n}\n\nexport function _containerInsert<N extends t.Node>(\n  this: NodePath,\n  from: number,\n  nodes: N[],\n): NodePath<N>[] {\n  updateSiblingKeys.call(this, from, nodes.length);\n\n  const paths: NodePath<N>[] = [];\n\n  // @ts-expect-error todo(flow->ts): this.container could be a NodePath\n  this.container.splice(from, 0, ...nodes);\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to) as NodePath<N>;\n    paths.push(path);\n\n    if (this.context?.queue) {\n      pushContext.call(path, this.context);\n    }\n  }\n\n  const contexts = _getQueueContexts.call(this);\n\n  for (const path of paths) {\n    setScope.call(path);\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nexport function _containerInsertBefore<N extends t.Node>(\n  this: NodePath,\n  nodes: N[],\n) {\n  return _containerInsert.call(this, this.key as number, nodes);\n}\n\nexport function _containerInsertAfter<N extends t.Node>(\n  this: NodePath,\n  nodes: N[],\n) {\n  return _containerInsert.call(this, (this.key as number) + 1, nodes);\n}\n\nconst last = <T>(arr: T[]) => arr[arr.length - 1];\n\nfunction isHiddenInSequenceExpression(path: NodePath): boolean {\n  return (\n    isSequenceExpression(path.parent) &&\n    (last(path.parent.expressions) !== path.node ||\n      isHiddenInSequenceExpression(path.parentPath))\n  );\n}\n\nfunction isAlmostConstantAssignment(\n  node: t.Node,\n  scope: Scope,\n): node is t.AssignmentExpression & { left: t.Identifier } {\n  if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {\n    return false;\n  }\n\n  // Not every scope can contain variables. For example, we might be in\n  // a ClassScope either in the ClassHeritage or in a computed key.\n  const blockScope = scope.getBlockParent();\n\n  // If the variable is defined in the current scope and only assigned here,\n  // we can be sure that its value won't change.\n  return (\n    blockScope.hasOwnBinding(node.left.name) &&\n    blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1\n  );\n}\n\n/**\n * Insert the provided nodes after the current one. When inserting nodes after an\n * expression, ensure that the completion record is correct by pushing the current node.\n */\n\nexport function insertAfter(\n  this: NodePath,\n  nodes_: t.Node | t.Node[],\n): NodePath[] {\n  _assertUnremoved.call(this);\n\n  if (this.isSequenceExpression()) {\n    return last(this.get(\"expressions\")).insertAfter(nodes_);\n  }\n\n  const nodes = _verifyNodeList.call(this, nodes_);\n\n  const { parentPath, parent } = this;\n  if (\n    parentPath.isExpressionStatement() ||\n    parentPath.isLabeledStatement() ||\n    // see insertBefore\n    isExportNamedDeclaration(parent) ||\n    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())\n  ) {\n    return parentPath.insertAfter(\n      nodes.map(node => {\n        // Usually after an expression we can safely insert another expression:\n        //   A.insertAfter(B)\n        //     foo = A;  -> foo = (A, B);\n        // If A is an expression statement, it isn't safe anymore so we need to\n        // convert B to an expression statement\n        //     A;        -> A; B // No semicolon! It could break if followed by [!\n        return isExpression(node) ? expressionStatement(node) : node;\n      }),\n    );\n  } else if (\n    (this.isNodeType(\"Expression\") &&\n      !this.isJSXElement() &&\n      !parentPath.isJSXElement()) ||\n    (parentPath.isForStatement() && this.key === \"init\")\n  ) {\n    const self = this as NodePath<t.Expression | t.VariableDeclaration>;\n    if (self.node) {\n      const node = self.node;\n      let { scope } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n\n        self.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        (self.get(\"callee.body\") as NodePath<t.Expression>).insertAfter(nodes);\n        return [self];\n      }\n\n      if (isHiddenInSequenceExpression(self)) {\n        nodes.unshift(node);\n      }\n      // We need to preserve the value of this expression.\n      else if (isCallExpression(node) && isSuper(node.callee)) {\n        nodes.unshift(node);\n        // `super(...)` always evaluates to `this`.\n        nodes.push(thisExpression());\n      } else if (isAlmostConstantAssignment(node, scope)) {\n        nodes.unshift(node);\n        nodes.push(cloneNode(node.left));\n      } else if (scope.isPure(node, true)) {\n        // Insert the nodes before rather than after; it's not observable.\n        nodes.push(node);\n      } else {\n        // Inserting after the computed key of a method should insert the\n        // temporary binding in the method's parent's scope.\n        if (parentPath.isMethod({ computed: true, key: node })) {\n          scope = scope.parent;\n        }\n        const temp = scope.generateDeclaredUidIdentifier();\n        nodes.unshift(\n          expressionStatement(\n            // @ts-expect-error todo(flow->ts): This can be a variable\n            // declaration in the \"init\" of a for statement, but that's\n            // invalid here.\n            assignmentExpression(\"=\", cloneNode(temp), node),\n          ),\n        );\n        nodes.push(expressionStatement(cloneNode(temp)));\n      }\n    }\n    // @ts-expect-error todo(flow->ts): check that nodes is an array of statements\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return _containerInsertAfter.call(this, nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node as t.Statement;\n    const shouldInsertCurrentNode =\n      node &&\n      (!this.isExpressionStatement() ||\n        (node as t.ExpressionStatement).expression != null);\n\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    // @ts-expect-error Fixme: refine nodes to t.BlockStatement[\"body\"] when this is a BlockStatement path\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\n      \"We don't know what to do with this node type. \" +\n        \"We were previously a Statement but we can't fit in here?\",\n    );\n  }\n}\n\n/**\n * Update all sibling node paths after `fromIndex` by `incrementBy`.\n */\n\nexport function updateSiblingKeys(\n  this: NodePath,\n  fromIndex: number,\n  incrementBy: number,\n) {\n  if (!this.parent) return;\n\n  const paths = getCachedPaths(this);\n  if (!paths) return;\n\n  for (const [, path] of paths) {\n    if (\n      typeof path.key === \"number\" &&\n      path.container === this.container &&\n      path.key >= fromIndex\n    ) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nexport function _verifyNodeList<N extends t.Node>(\n  this: NodePath,\n  nodes: N | N[],\n): N[] {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof NodePath) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(\n        `Node list ${msg} with the index of ${i} and type of ${type}`,\n      );\n    }\n  }\n\n  return nodes;\n}\n\nexport function unshiftContainer<N extends t.Node, K extends keyof N & string>(\n  this: NodePath<N>,\n  listKey: K,\n  nodes: N[K] extends (infer E)[]\n    ? E | E[]\n    : // todo: refine to t.Node[]\n      //  ? E extends t.Node\n      //    ? E | E[]\n      //    : never\n      never,\n) {\n  // todo: NodePaths<Nodes>\n  _assertUnremoved.call(this);\n\n  // @ts-expect-error fixme\n  nodes = _verifyNodeList.call(this, nodes);\n\n  // get the first path and insert our nodes before it, if it doesn't exist then it\n  // doesn't matter, our nodes will be inserted anyway\n  const path = NodePath.get({\n    parentPath: this,\n    parent: this.node,\n    container: (this.node as N)[listKey] as unknown as t.Node | t.Node[],\n    listKey,\n    key: 0,\n  }).setContext(this.context);\n\n  return _containerInsertBefore.call(\n    path,\n    // @ts-expect-error typings needed to narrow down nodes as t.Node[]\n    nodes,\n  );\n}\n\nexport function pushContainer<\n  P extends NodePath,\n  K extends string & keyof P[\"node\"],\n>(\n  this: P,\n  listKey: K,\n  nodes: P[\"node\"][K] extends (infer E)[]\n    ? E | E[]\n    : // todo: refine to t.Node[]\n      //  ? E extends t.Node\n      //    ? E | E[]\n      //    : never\n      never,\n) {\n  _assertUnremoved.call(this);\n\n  const verifiedNodes = _verifyNodeList.call(\n    this,\n    // @ts-expect-error refine typings\n    nodes,\n  );\n\n  // get an invisible path that represents the last node + 1 and replace it with our\n  // nodes, effectively inlining it\n\n  const container = (this.node as P[\"node\"])[listKey] as t.Node[];\n  const path = NodePath.get({\n    parentPath: this,\n    parent: this.node,\n    container: container as unknown as t.Node | t.Node[],\n    listKey,\n    key: container.length,\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nimport PathHoister from \"./lib/hoister.ts\" with { if: \"!process.env.BABEL_8_BREAKING && !USE_ESM\" };\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /**\n   * Hoist the current node to the highest scope possible and return a UID\n   * referencing it.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.hoist = function hoist<T extends t.Node>(\n    this: NodePath<T>,\n    scope: Scope = this.scope,\n  ) {\n    const hoister = new PathHoister<T>(this, scope);\n    return hoister.run();\n  };\n}\n", "// This file contains methods responsible for replacing a node with another.\n\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport traverse from \"../index.ts\";\nimport NodePath from \"./index.ts\";\nimport { getCachedPaths } from \"../cache.ts\";\nimport { _verifyNodeList, _containerInsertAfter } from \"./modification.ts\";\nimport { parse } from \"@babel/parser\";\nimport {\n  FUNCTION_TYPES,\n  arrowFunctionExpression,\n  assignmentExpression,\n  awaitExpression,\n  blockStatement,\n  buildUndefinedNode,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  expressionStatement,\n  getBindingIdentifiers,\n  identifier,\n  inheritLeadingComments,\n  inheritTrailingComments,\n  inheritsComments,\n  isBlockStatement,\n  isEmptyStatement,\n  isExpression,\n  isExpressionStatement,\n  isIfStatement,\n  isProgram,\n  isStatement,\n  isVariableDeclaration,\n  removeComments,\n  returnStatement,\n  sequenceExpression,\n  validate,\n  yieldExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { resync, setScope } from \"./context.ts\";\n\n/**\n * Replace a node with an array of multiple. This method performs the following steps:\n *\n *  - Inherit the comments of first provided node with that of the current node.\n *  - Insert the provided nodes after the current node.\n *  - Remove the current node.\n */\n\nexport function replaceWithMultiple(\n  this: NodePath,\n  nodes: t.Node | t.Node[],\n): NodePath[] {\n  resync.call(this);\n\n  nodes = _verifyNodeList.call(this, nodes);\n  inheritLeadingComments(nodes[0], this.node);\n  inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  getCachedPaths(this)?.delete(this.node);\n  this.node =\n    // @ts-expect-error this.key must present in this.container\n    this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n  return paths;\n}\n\n/**\n * Parse a string as an expression and replace the current node with the result.\n *\n * NOTE: This is typically not a good idea to use. Building source strings when\n * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's\n * easier to use, your transforms will be extremely brittle.\n */\n\nexport function replaceWithSourceString(this: NodePath, replacement: string) {\n  resync.call(this);\n  let ast: t.File;\n\n  try {\n    replacement = `(${replacement})`;\n    ast = parse(replacement);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message +=\n        \" - make sure this is an expression.\\n\" +\n        codeFrameColumns(replacement, {\n          start: {\n            line: loc.line,\n            column: loc.column + 1,\n          },\n        });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n    throw err;\n  }\n\n  const expressionAST = (ast.program.body[0] as t.ExpressionStatement)\n    .expression;\n  traverse.removeProperties(expressionAST);\n  return this.replaceWith(expressionAST);\n}\n\n/**\n * Replace the current node with another.\n */\nexport function replaceWith<R extends t.Node>(\n  this: NodePath,\n  replacementPath: R,\n): [NodePath<R>];\nexport function replaceWith<R extends NodePath>(\n  this: NodePath,\n  replacementPath: R,\n): [R];\nexport function replaceWith(\n  this: NodePath,\n  replacementPath: t.Node | NodePath,\n): [NodePath] {\n  resync.call(this);\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  let replacement: t.Node =\n    replacementPath instanceof NodePath\n      ? replacementPath.node\n      : replacementPath;\n\n  if (!replacement) {\n    throw new Error(\n      \"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\",\n    );\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !isProgram(replacement)) {\n    throw new Error(\n      \"You can only replace a Program root node with another Program node\",\n    );\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\n      \"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\",\n    );\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\n      \"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\",\n    );\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && isExpression(replacement)) {\n    if (\n      !this.canHaveVariableDeclarationOrExpression() &&\n      !this.canSwapBetweenExpressionAndStatement(replacement) &&\n      !this.parentPath.isExportDefaultDeclaration()\n    ) {\n      // replacing a statement with an expression so wrap it in an expression statement\n      replacement = expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && isStatement(replacement)) {\n    if (\n      !this.canHaveVariableDeclarationOrExpression() &&\n      !this.canSwapBetweenExpressionAndStatement(replacement)\n    ) {\n      // replacing an expression with a statement so let's explode it\n      return this.replaceExpressionWithStatements([replacement]) as [NodePath];\n    }\n  }\n\n  const oldNode = this.node;\n  if (oldNode) {\n    inheritsComments(replacement, oldNode);\n    removeComments(oldNode);\n  }\n\n  // replace the node\n  _replaceWith.call(this, replacement);\n  this.type = replacement.type;\n\n  // potentially create new scope\n  setScope.call(this);\n\n  // requeue for visiting\n  this.requeue();\n\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nexport function _replaceWith(this: NodePath, node: t.Node) {\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    // @ts-expect-error todo(flow->ts): check if validate accepts a numeric key\n    validate(this.parent, this.key, [node]);\n  } else {\n    validate(this.parent, this.key as string, node);\n  }\n\n  this.debug(`Replace with ${node?.type}`);\n  getCachedPaths(this)?.set(node, this).delete(this.node);\n\n  this.node =\n    // @ts-expect-error this.key must present in this.container\n    this.container[this.key] = node;\n}\n\n/**\n * This method takes an array of statements nodes and then explodes it\n * into expressions. This method retains completion records which is\n * extremely important to retain original semantics.\n */\n\nexport function replaceExpressionWithStatements(\n  this: NodePath,\n  nodes: Array<t.Statement>,\n) {\n  resync.call(this);\n\n  const declars: t.Identifier[] = [];\n  const nodesAsSingleExpression = gatherSequenceExpressions(nodes, declars);\n  if (nodesAsSingleExpression) {\n    for (const id of declars) this.scope.push({ id });\n    return this.replaceWith(nodesAsSingleExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent?.node.async;\n  const isParentGenerator = functionParent?.node.generator;\n\n  const container = arrowFunctionExpression([], blockStatement(nodes));\n\n  this.replaceWith(callExpression(container, []));\n  // replaceWith changes the type of \"this\", but it isn't trackable by TS\n  type ThisType = NodePath<\n    t.CallExpression & {\n      callee: t.ArrowFunctionExpression & { body: t.BlockStatement };\n    }\n  >;\n\n  // hoist variable declaration in do block\n  // `(do { var x = 1; x;})` -> `var x; (() => { x = 1; return x; })()`\n  const callee = (this as ThisType).get(\"callee\");\n  callee.get(\"body\").scope.hoistVariables(id => this.scope.push({ id }));\n\n  // add implicit returns to all ending expression statements\n  const completionRecords: Array<NodePath> = callee.getCompletionRecords();\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n\n    const loop = path.findParent(path => path.isLoop());\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee\n          .get(\"body\")\n          .pushContainer(\"body\", returnStatement(cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = identifier(uid.name);\n      }\n\n      path\n        .get(\"expression\")\n        .replaceWith(\n          assignmentExpression(\"=\", cloneNode(uid), path.node.expression),\n        );\n    } else {\n      path.replaceWith(returnStatement(path.node.expression));\n    }\n  }\n\n  // This is an IIFE, so we don't need to worry about the noNewArrows assumption\n  callee.arrowFunctionToExpression();\n  // Fixme: we can not `assert this is NodePath<t.FunctionExpression>` in `arrowFunctionToExpression`\n  // because it is not a class method known at compile time.\n  const newCallee = callee as unknown as NodePath<t.FunctionExpression>;\n\n  // (() => await xxx)() -> await (async () => await xxx)();\n  const needToAwaitFunction =\n    isParentAsync &&\n    traverse.hasType(\n      (this.get(\"callee.body\") as NodePath<t.BlockStatement>).node,\n      \"AwaitExpression\",\n      FUNCTION_TYPES,\n    );\n  const needToYieldFunction =\n    isParentGenerator &&\n    traverse.hasType(\n      (this.get(\"callee.body\") as NodePath<t.BlockStatement>).node,\n      \"YieldExpression\",\n      FUNCTION_TYPES,\n    );\n  if (needToAwaitFunction) {\n    newCallee.set(\"async\", true);\n    // yield* will await the generator return result\n    if (!needToYieldFunction) {\n      this.replaceWith(awaitExpression((this as ThisType).node));\n    }\n  }\n  if (needToYieldFunction) {\n    newCallee.set(\"generator\", true);\n    this.replaceWith(yieldExpression((this as ThisType).node, true));\n  }\n\n  return newCallee.get(\"body.body\");\n}\n\nfunction gatherSequenceExpressions(\n  nodes: ReadonlyArray<t.Node>,\n  declars: Array<t.Identifier>,\n) {\n  const exprs: t.Expression[] = [];\n  let ensureLastUndefined = true;\n\n  for (const node of nodes) {\n    // if we encounter emptyStatement before a non-emptyStatement\n    // we want to disregard that\n    if (!isEmptyStatement(node)) {\n      ensureLastUndefined = false;\n    }\n\n    if (isExpression(node)) {\n      exprs.push(node);\n    } else if (isExpressionStatement(node)) {\n      exprs.push(node.expression);\n    } else if (isVariableDeclaration(node)) {\n      if (node.kind !== \"var\") return; // bailed\n\n      for (const declar of node.declarations) {\n        const bindings = getBindingIdentifiers(declar);\n        for (const key of Object.keys(bindings)) {\n          declars.push(cloneNode(bindings[key]));\n        }\n\n        if (declar.init) {\n          exprs.push(\n            assignmentExpression(\n              \"=\",\n              // var declarator must not be a void pattern\n              declar.id as Exclude<t.VariableDeclarator[\"id\"], t.VoidPattern>,\n              declar.init,\n            ),\n          );\n        }\n      }\n\n      ensureLastUndefined = true;\n    } else if (isIfStatement(node)) {\n      const consequent = node.consequent\n        ? gatherSequenceExpressions([node.consequent], declars)\n        : buildUndefinedNode();\n      const alternate = node.alternate\n        ? gatherSequenceExpressions([node.alternate], declars)\n        : buildUndefinedNode();\n      if (!consequent || !alternate) return; // bailed\n\n      exprs.push(conditionalExpression(node.test, consequent, alternate));\n    } else if (isBlockStatement(node)) {\n      const body = gatherSequenceExpressions(node.body, declars);\n      if (!body) return; // bailed\n\n      exprs.push(body);\n    } else if (isEmptyStatement(node)) {\n      // empty statement so ensure the last item is undefined if we're last\n      // checks if emptyStatement is first\n      if (nodes.indexOf(node) === 0) {\n        ensureLastUndefined = true;\n      }\n    } else {\n      // bailed, we can't turn this statement into an expression\n      return;\n    }\n  }\n\n  if (ensureLastUndefined) exprs.push(buildUndefinedNode());\n\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return sequenceExpression(exprs);\n  }\n}\n\nexport function replaceInline(this: NodePath, nodes: t.Node | Array<t.Node>) {\n  resync.call(this);\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = _verifyNodeList.call(this, nodes);\n      const paths = _containerInsertAfter.call(this, nodes);\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}\n", "import type NodePath from \"./index.ts\";\nimport type * as t from \"@babel/types\";\n\n// This file contains Babels metainterpreter that can evaluate static code.\n\nconst VALID_OBJECT_CALLEES = [\"Number\", \"String\", \"Math\"] as const;\nconst VALID_IDENTIFIER_CALLEES = [\n  \"isFinite\",\n  \"isNaN\",\n  \"parseFloat\",\n  \"parseInt\",\n  \"decodeURI\",\n  \"decodeURIComponent\",\n  \"encodeURI\",\n  \"encodeURIComponent\",\n  process.env.BABEL_8_BREAKING ? \"btoa\" : null,\n  process.env.BABEL_8_BREAKING ? \"atob\" : null,\n] as const;\n\nconst INVALID_METHODS = [\"random\"] as const;\n\nfunction isValidObjectCallee(\n  val: string,\n): val is (typeof VALID_OBJECT_CALLEES)[number] {\n  return VALID_OBJECT_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isValidIdentifierCallee(\n  val: string,\n): val is (typeof VALID_IDENTIFIER_CALLEES)[number] {\n  return VALID_IDENTIFIER_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isInvalidMethod(val: string): val is (typeof INVALID_METHODS)[number] {\n  return INVALID_METHODS.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\n/**\n * Walk the input `node` and statically evaluate if it's truthy.\n *\n * Returning `true` when we're sure that the expression will evaluate to a\n * truthy value, `false` if we're sure that it will evaluate to a falsy\n * value and `undefined` if we aren't sure. Because of this please do not\n * rely on coercion when using this method and check with === if it's false.\n *\n * For example do:\n *\n *   if (t.evaluateTruthy(node) === false) falsyLogic();\n *\n * **AND NOT**\n *\n *   if (!t.evaluateTruthy(node)) falsyLogic();\n *\n */\n\nexport function evaluateTruthy(this: NodePath): boolean {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\ntype State = {\n  confident: boolean;\n  deoptPath: NodePath | null;\n  seen: Map<t.Node, Result>;\n};\n\ntype Result = {\n  resolved: boolean;\n  value?: any;\n};\n/**\n * Deopts the evaluation\n */\nfunction deopt(path: NodePath, state: State) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nconst Globals = new Map([\n  [\"undefined\", undefined],\n  [\"Infinity\", Infinity],\n  [\"NaN\", NaN],\n]);\n\n/**\n * We wrap the _evaluate method so we can track `seen` nodes, we push an item\n * to the map before we actually evaluate it so we can deopt on self recursive\n * nodes such as:\n *\n *   var g = a ? 1 : 2,\n *       a = g * this.foo\n */\nfunction evaluateCached(path: NodePath, state: State): any {\n  const { node } = path;\n  const { seen } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item: Result = { resolved: false };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n    return val;\n  }\n}\n\nfunction _evaluate(path: NodePath, state: State): any {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (\n    path.isStringLiteral() ||\n    path.isNumericLiteral() ||\n    path.isBooleanLiteral()\n  ) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (\n    path.isTaggedTemplateExpression() &&\n    path.get(\"tag\").isMemberExpression()\n  ) {\n    const object = path.get(\"tag.object\") as NodePath;\n    const {\n      // @ts-expect-error todo(flow->ts): possible bug, object is can be any expression and so name might be undefined\n      node: { name },\n    } = object;\n    const property = path.get(\"tag.property\") as NodePath;\n\n    if (\n      object.isIdentifier() &&\n      name === \"String\" &&\n      // todo(flow->ts): was changed from getBinding(name, true)\n      //  should this be hasBinding(name, true) as the binding is never used later?\n      !path.scope.getBinding(name) &&\n      property.isIdentifier() &&\n      property.node.name === \"raw\"\n    ) {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    // TypeCastExpression, ExpressionStatement etc\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  // \"foo\".length, \"foo\"[0]\n  if (\n    path.isMemberExpression() &&\n    !path.parentPath.isCallExpression({ callee: path.node })\n  ) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral()) {\n      // @ts-expect-error todo(flow->ts): instead of typeof - would it be better to check type of ast node?\n      const value = object.node.value;\n      const type = typeof value;\n\n      let key = null;\n      if (path.node.computed) {\n        key = evaluateCached(property, state);\n        if (!state.confident) return;\n      } else if (property.isIdentifier()) {\n        key = property.node.name;\n      }\n      if (\n        (type === \"number\" || type === \"string\") &&\n        key != null &&\n        (typeof key === \"number\" || typeof key === \"string\")\n      ) {\n        return value[key];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding) {\n      if (\n        binding.constantViolations.length > 0 ||\n        path.node.start < binding.path.node.end\n      ) {\n        deopt(binding.path, state);\n        return;\n      }\n      const bindingPathScope = binding.path.scope;\n      if (binding.kind === \"var\" && bindingPathScope !== binding.scope) {\n        let hasUnsafeBlock =\n          !bindingPathScope.path.parentPath.isBlockStatement();\n        for (let scope = bindingPathScope.parent; scope; scope = scope.parent) {\n          if (scope === path.scope) {\n            if (hasUnsafeBlock) {\n              deopt(binding.path, state);\n              return;\n            }\n            break;\n          }\n          if (scope.path.parentPath?.isBlockStatement()) {\n            hasUnsafeBlock = true;\n          }\n        }\n      }\n      if (binding.hasValue) {\n        return binding.value;\n      }\n    }\n\n    const name = path.node.name;\n    if (Globals.has(name)) {\n      if (!binding) {\n        return Globals.get(name);\n      }\n      deopt(binding.path, state);\n      return;\n    }\n\n    const resolved = path.resolve();\n    if (resolved === path) {\n      deopt(path, state);\n      return;\n    }\n    const value = evaluateCached(resolved, state);\n    if (typeof value === \"object\" && value !== null && binding.references > 1) {\n      deopt(resolved, state);\n      return;\n    }\n    return value;\n  }\n\n  if (path.isUnaryExpression({ prefix: true })) {\n    if (path.node.operator === \"void\") {\n      // we don't need to evaluate the argument to know what this will return\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n    if (\n      path.node.operator === \"typeof\" &&\n      (argument.isFunction() || argument.isClass())\n    ) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n      case \"+\":\n        return +arg;\n      case \"-\":\n        return -arg;\n      case \"~\":\n        return ~arg;\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems: Array<NodePath> = path.get(\"elements\");\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        deopt(elemValue.deopt, state);\n        return;\n      }\n    }\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        deopt(prop, state);\n        return;\n      }\n      const keyPath = prop.get(\"key\");\n      let key;\n      if (prop.node.computed) {\n        key = keyPath.evaluate();\n        if (!key.confident) {\n          deopt(key.deopt, state);\n          return;\n        }\n        key = key.value;\n      } else if (keyPath.isIdentifier()) {\n        key = keyPath.node.name;\n      } else {\n        key = (\n          keyPath.node as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral\n        ).value;\n      }\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n      if (!value.confident) {\n        deopt(value.deopt, state);\n        return;\n      }\n      value = value.value;\n      // @ts-expect-error key is any type\n      obj[key] = value;\n    }\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    // If we are confident that the left side of an && is false, or the left\n    // side of an || is true, we can be confident about the entire expression\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        // TODO consider having a \"truthy type\" that doesn't bail on\n        // left uncertainty but can still evaluate to truthy.\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n\n        return left || right;\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n\n        return left && right;\n      case \"??\":\n        state.confident = leftConfident && (left != null || rightConfident);\n        if (!state.confident) return;\n\n        return left ?? right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n      case \"+\":\n        return left + right;\n      case \"/\":\n        return left / right;\n      case \"*\":\n        return left * right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return left ** right;\n      case \"<\":\n        return left < right;\n      case \">\":\n        return left > right;\n      case \"<=\":\n        return left <= right;\n      case \">=\":\n        return left >= right;\n      case \"==\":\n        return left == right; // eslint-disable-line eqeqeq\n      case \"!=\":\n        return left != right; // eslint-disable-line eqeqeq\n      case \"===\":\n        return left === right;\n      case \"!==\":\n        return left !== right;\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \"^\":\n        return left ^ right;\n      case \"<<\":\n        return left << right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    // Number(1);\n    if (\n      callee.isIdentifier() &&\n      !path.scope.getBinding(callee.node.name) &&\n      (isValidObjectCallee(callee.node.name) ||\n        isValidIdentifierCallee(callee.node.name))\n    ) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      // Math.min(1, 2)\n      if (\n        object.isIdentifier() &&\n        property.isIdentifier() &&\n        isValidObjectCallee(object.node.name) &&\n        !isInvalidMethod(property.node.name)\n      ) {\n        context = global[object.node.name];\n        const key = property.node.name;\n        if (Object.hasOwn(context, key)) {\n          func = context[key as keyof typeof context];\n        }\n      }\n\n      // \"abc\".charCodeAt(4)\n      if (object.isLiteral() && property.isIdentifier()) {\n        // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type (StringLiteral and NumberLiteral)\n        const type = typeof object.node.value;\n        if (type === \"string\" || type === \"number\") {\n          // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(\n  path: NodePath<t.TaggedTemplateExpression | t.TemplateLiteral>,\n  quasis: Array<any>,\n  state: State,\n  raw = false,\n) {\n  let str = \"\";\n\n  let i = 0;\n  const exprs: Array<NodePath<t.Node>> = path.isTemplateLiteral()\n    ? path.get(\"expressions\")\n    : path.get(\"quasi.expressions\");\n\n  for (const elem of quasis) {\n    // not confident, evaluated an expression we don't like\n    if (!state.confident) break;\n\n    // add on element\n    str += raw ? elem.value.raw : elem.value.cooked;\n\n    // add on interpolated expression if it's present\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\n/**\n * Walk the input `node` and statically evaluate it.\n *\n * Returns an object in the form `{ confident, value, deopt }`. `confident`\n * indicates whether or not we had to drop out of evaluating the expression\n * because of hitting an unknown node that we couldn't confidently find the\n * value of, in which case `deopt` is the path of said node.\n *\n * Example:\n *\n *   t.evaluate(parse(\"5 + 5\")) // { confident: true, value: 10 }\n *   t.evaluate(parse(\"!true\")) // { confident: true, value: false }\n *   t.evaluate(parse(\"foo + foo\")) // { confident: false, value: undefined, deopt: NodePath }\n *\n */\n\nexport function evaluate(this: NodePath): {\n  confident: boolean;\n  value: any;\n  deopt?: NodePath;\n} {\n  const state: State = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map(),\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value,\n  };\n}\n", "import { assertExpressionStatement } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nexport type Formatter<T> = {\n  code: (source: string) => string;\n  validate: (ast: t.File) => void;\n  unwrap: (ast: t.File) => T;\n};\n\nfunction makeStatementFormatter<T>(\n  fn: (statements: Array<t.Statement>) => T,\n): Formatter<T> {\n  return {\n    // We need to prepend a \";\" to force statement parsing so that\n    // ExpressionStatement strings won't be parsed as directives.\n    // Alongside that, we also prepend a comment so that when a syntax error\n    // is encountered, the user will be less likely to get confused about\n    // where the random semicolon came from.\n    code: str => `/* @babel/template */;\\n${str}`,\n    validate: () => {},\n    unwrap: (ast: t.File): T => {\n      return fn(ast.program.body.slice(1));\n    },\n  };\n}\n\nexport const smart = makeStatementFormatter(body => {\n  if (body.length > 1) {\n    return body;\n  } else {\n    return body[0];\n  }\n});\n\nexport const statements = makeStatementFormatter(body => body);\n\nexport const statement = makeStatementFormatter(body => {\n  // We do this validation when unwrapping since the replacement process\n  // could have added or removed statements.\n  if (body.length === 0) {\n    throw new Error(\"Found nothing to return.\");\n  }\n  if (body.length > 1) {\n    throw new Error(\"Found multiple statements but wanted one\");\n  }\n\n  return body[0];\n});\n\nexport const expression: Formatter<t.Expression> = {\n  code: str => `(\\n${str}\\n)`,\n  validate: ast => {\n    if (ast.program.body.length > 1) {\n      throw new Error(\"Found multiple statements but wanted one\");\n    }\n    if (expression.unwrap(ast).start === 0) {\n      throw new Error(\"Parse result included parens.\");\n    }\n  },\n  unwrap: ({ program }) => {\n    const [stmt] = program.body;\n    assertExpressionStatement(stmt);\n    return stmt.expression;\n  },\n};\n\nexport const program: Formatter<t.Program> = {\n  code: str => str,\n  validate: () => {},\n  unwrap: ast => ast.program,\n};\n", "import type { ParserOptions as ParserOpts } from \"@babel/parser\";\n\nexport type { ParserOpts };\n\n/**\n * These are the options that 'babel-template' actually accepts and typechecks\n * when called. All other options are passed through to the parser.\n */\nexport type PublicOpts = {\n  /**\n   * A set of placeholder names to automatically accept, ignoring the given\n   * pattern entirely.\n   *\n   * This option can be used when using %%foo%% style placeholders.\n   */\n  placeholderWhitelist?: Set<string>;\n  /**\n   * A pattern to search for when looking for Identifier and StringLiteral\n   * nodes that can be replaced.\n   *\n   * 'false' will disable placeholder searching entirely, leaving only the\n   * 'placeholderWhitelist' value to find replacements.\n   *\n   * Defaults to /^[_$A-Z0-9]+$/.\n   *\n   * This option can be used when using %%foo%% style placeholders.\n   */\n  placeholderPattern?: RegExp | false;\n  /**\n   * 'true' to pass through comments from the template into the resulting AST,\n   * or 'false' to automatically discard comments. Defaults to 'false'.\n   */\n  preserveComments?: boolean;\n  /**\n   * 'true' to use %%foo%% style placeholders, 'false' to use legacy placeholders\n   * described by placeholderPattern or placeholderWhitelist.\n   * When it is not set, it behaves as 'true' if there are syntactic placeholders,\n   * otherwise as 'false'.\n   */\n  syntacticPlaceholders?: boolean | null;\n} & ParserOpts;\n\nexport type TemplateOpts = {\n  parser: ParserOpts;\n  placeholderWhitelist?: Set<string>;\n  placeholderPattern?: RegExp | false;\n  preserveComments?: boolean;\n  syntacticPlaceholders?: boolean;\n};\n\nexport function merge(a: TemplateOpts, b: TemplateOpts): TemplateOpts {\n  const {\n    placeholderWhitelist = a.placeholderWhitelist,\n    placeholderPattern = a.placeholderPattern,\n    preserveComments = a.preserveComments,\n    syntacticPlaceholders = a.syntacticPlaceholders,\n  } = b;\n\n  return {\n    parser: {\n      ...a.parser,\n      ...b.parser,\n    },\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n  };\n}\n\nexport function validate(opts: unknown): TemplateOpts {\n  if (opts != null && typeof opts !== \"object\") {\n    throw new Error(\"Unknown template options.\");\n  }\n\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n    ...parser\n  } = opts || ({} as any);\n\n  if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {\n    throw new Error(\n      \"'.placeholderWhitelist' must be a Set, null, or undefined\",\n    );\n  }\n\n  if (\n    placeholderPattern != null &&\n    !(placeholderPattern instanceof RegExp) &&\n    placeholderPattern !== false\n  ) {\n    throw new Error(\n      \"'.placeholderPattern' must be a RegExp, false, null, or undefined\",\n    );\n  }\n\n  if (preserveComments != null && typeof preserveComments !== \"boolean\") {\n    throw new Error(\n      \"'.preserveComments' must be a boolean, null, or undefined\",\n    );\n  }\n\n  if (\n    syntacticPlaceholders != null &&\n    typeof syntacticPlaceholders !== \"boolean\"\n  ) {\n    throw new Error(\n      \"'.syntacticPlaceholders' must be a boolean, null, or undefined\",\n    );\n  }\n  if (\n    syntacticPlaceholders === true &&\n    (placeholderWhitelist != null || placeholderPattern != null)\n  ) {\n    throw new Error(\n      \"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" +\n        \" with '.syntacticPlaceholders: true'\",\n    );\n  }\n\n  return {\n    parser,\n    placeholderWhitelist: placeholderWhitelist || undefined,\n    placeholderPattern:\n      placeholderPattern == null ? undefined : placeholderPattern,\n    preserveComments: preserveComments == null ? undefined : preserveComments,\n    syntacticPlaceholders:\n      syntacticPlaceholders == null ? undefined : syntacticPlaceholders,\n  };\n}\n\nexport type PublicReplacements = { [x: string]: unknown } | Array<unknown>;\nexport type TemplateReplacements = { [x: string]: unknown } | void;\n\nexport function normalizeReplacements(\n  replacements: unknown,\n): TemplateReplacements {\n  if (Array.isArray(replacements)) {\n    return replacements.reduce((acc, replacement, i) => {\n      acc[\"$\" + i] = replacement;\n      return acc;\n    }, {});\n  } else if (typeof replacements === \"object\" || replacements == null) {\n    return (replacements as any) || undefined;\n  }\n\n  throw new Error(\n    \"Template replacements must be an array, object, null, or undefined\",\n  );\n}\n", "import {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { TraversalAncestors } from \"@babel/types\";\nimport { parse } from \"@babel/parser\";\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport type { TemplateOpts, ParserOpts } from \"./options.ts\";\nimport type { Formatter } from \"./formatters.ts\";\n\nexport type Metadata = {\n  ast: t.File;\n  placeholders: Array<Placeholder>;\n  placeholderNames: Set<string>;\n};\n\ntype PlaceholderType = \"string\" | \"param\" | \"statement\" | \"other\";\nexport type Placeholder = {\n  name: string;\n  resolve: (a: t.File) => { parent: t.Node; key: string; index?: number };\n  type: PlaceholderType;\n  isDuplicate: boolean;\n};\n\nconst PATTERN = /^[_$A-Z0-9]+$/;\n\nexport default function parseAndBuildMetadata<T>(\n  formatter: Formatter<T>,\n  code: string,\n  opts: TemplateOpts,\n): Metadata {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n  } = opts;\n\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n\n  removePropertiesDeep(ast, {\n    preserveComments,\n  });\n\n  formatter.validate(ast);\n\n  const state: MetadataState = {\n    syntactic: { placeholders: [], placeholderNames: new Set() },\n    legacy: { placeholders: [], placeholderNames: new Set() },\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders,\n  };\n\n  traverse(ast, placeholderVisitorHandler, state);\n\n  return {\n    ast,\n    ...(state.syntactic.placeholders.length ? state.syntactic : state.legacy),\n  };\n}\n\nfunction placeholderVisitorHandler(\n  node: t.Node,\n  ancestors: TraversalAncestors,\n  state: MetadataState,\n) {\n  let name: string;\n\n  let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;\n\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\n        \"%%foo%%-style placeholders can't be used when \" +\n          \"'.syntacticPlaceholders' is false.\",\n      );\n    }\n    name = node.name.name;\n    hasSyntacticPlaceholders = true;\n  } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n  } else {\n    return;\n  }\n\n  if (\n    hasSyntacticPlaceholders &&\n    (state.placeholderPattern != null || state.placeholderWhitelist != null)\n  ) {\n    // This check is also in options.js. We need it there to handle the default\n    // .syntacticPlaceholders behavior.\n    throw new Error(\n      \"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" +\n        \" with '.syntacticPlaceholders: true'\",\n    );\n  }\n\n  if (\n    !hasSyntacticPlaceholders &&\n    (state.placeholderPattern === false ||\n      !(state.placeholderPattern || PATTERN).test(name)) &&\n    !state.placeholderWhitelist?.has(name)\n  ) {\n    return;\n  }\n\n  // Keep our own copy of the ancestors so we can use it in .resolve().\n  ancestors = ancestors.slice();\n\n  const { node: parent, key } = ancestors[ancestors.length - 1];\n\n  let type: PlaceholderType;\n  if (\n    isStringLiteral(node) ||\n    isPlaceholder(node, { expectedNode: \"StringLiteral\" })\n  ) {\n    type = \"string\";\n  } else if (\n    (isNewExpression(parent) && key === \"arguments\") ||\n    (isCallExpression(parent) && key === \"arguments\") ||\n    (isFunction(parent) && key === \"params\")\n  ) {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n\n  const { placeholders, placeholderNames } = !hasSyntacticPlaceholders\n    ? state.legacy\n    : state.syntactic;\n\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name),\n  });\n  placeholderNames.add(name);\n}\n\nfunction resolveAncestors(ast: t.File, ancestors: TraversalAncestors) {\n  let parent: t.Node = ast;\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const { key, index } = ancestors[i];\n\n    if (index === undefined) {\n      parent = (parent as any)[key];\n    } else {\n      parent = (parent as any)[key][index];\n    }\n  }\n\n  const { key, index } = ancestors[ancestors.length - 1];\n\n  return { parent, key, index };\n}\n\ntype MetadataState = {\n  syntactic: {\n    placeholders: Array<Placeholder>;\n    placeholderNames: Set<string>;\n  };\n  legacy: {\n    placeholders: Array<Placeholder>;\n    placeholderNames: Set<string>;\n  };\n  placeholderWhitelist?: Set<string>;\n  placeholderPattern?: RegExp | false;\n  syntacticPlaceholders?: boolean;\n};\n\nfunction parseWithCodeFrame(\n  code: string,\n  parserOpts: ParserOpts,\n  syntacticPlaceholders?: boolean,\n): t.File {\n  const plugins = (parserOpts.plugins || []).slice();\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n\n  parserOpts = {\n    allowAwaitOutsideFunction: true,\n    allowReturnOutsideFunction: true,\n    allowNewTargetOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    allowYieldOutsideFunction: true,\n    sourceType: \"module\",\n    ...parserOpts,\n    plugins,\n  };\n\n  try {\n    return parse(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message += \"\\n\" + codeFrameColumns(code, { start: loc });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n    throw err;\n  }\n}\n", "import {\n  blockStatement,\n  cloneNode,\n  emptyStatement,\n  expressionStatement,\n  identifier,\n  isStatement,\n  isStringLiteral,\n  stringLiteral,\n  validate,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport type { TemplateReplacements } from \"./options.ts\";\nimport type { Metadata, Placeholder } from \"./parse.ts\";\n\nexport default function populatePlaceholders(\n  metadata: Metadata,\n  replacements: TemplateReplacements,\n): t.File {\n  const ast = cloneNode(metadata.ast);\n\n  if (replacements) {\n    metadata.placeholders.forEach(placeholder => {\n      if (!Object.hasOwn(replacements, placeholder.name)) {\n        const placeholderName = placeholder.name;\n\n        throw new Error(\n          `Error: No substitution given for \"${placeholderName}\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}\n            - { placeholderPattern: /^${placeholderName}$/ }`,\n        );\n      }\n    });\n    Object.keys(replacements).forEach(key => {\n      if (!metadata.placeholderNames.has(key)) {\n        throw new Error(`Unknown substitution \"${key}\" given`);\n      }\n    });\n  }\n\n  // Process in reverse order so AST mutation doesn't change indices that\n  // will be needed for later calls to `placeholder.resolve()`.\n  metadata.placeholders\n    .slice()\n    .reverse()\n    .forEach(placeholder => {\n      try {\n        applyReplacement(\n          placeholder,\n          ast,\n          (replacements && replacements[placeholder.name]) ?? null,\n        );\n      } catch (e) {\n        e.message = `@babel/template placeholder \"${placeholder.name}\": ${e.message}`;\n        throw e;\n      }\n    });\n\n  return ast;\n}\n\nfunction applyReplacement(\n  placeholder: Placeholder,\n  ast: t.File,\n  replacement: any,\n) {\n  // Track inserted nodes and clone them if they are inserted more than\n  // once to avoid injecting the same node multiple times.\n  if (placeholder.isDuplicate) {\n    if (Array.isArray(replacement)) {\n      replacement = replacement.map(node => cloneNode(node));\n    } else if (typeof replacement === \"object\") {\n      replacement = cloneNode(replacement);\n    }\n  }\n\n  const { parent, key, index } = placeholder.resolve(ast);\n\n  if (placeholder.type === \"string\") {\n    if (typeof replacement === \"string\") {\n      replacement = stringLiteral(replacement);\n    }\n    if (!replacement || !isStringLiteral(replacement)) {\n      throw new Error(\"Expected string substitution\");\n    }\n  } else if (placeholder.type === \"statement\") {\n    if (index === undefined) {\n      if (!replacement) {\n        replacement = emptyStatement();\n      } else if (Array.isArray(replacement)) {\n        replacement = blockStatement(replacement);\n      } else if (typeof replacement === \"string\") {\n        replacement = expressionStatement(identifier(replacement));\n      } else if (!isStatement(replacement)) {\n        replacement = expressionStatement(replacement);\n      }\n    } else {\n      if (replacement && !Array.isArray(replacement)) {\n        if (typeof replacement === \"string\") {\n          replacement = identifier(replacement);\n        }\n        if (!isStatement(replacement)) {\n          replacement = expressionStatement(replacement);\n        }\n      }\n    }\n  } else if (placeholder.type === \"param\") {\n    if (typeof replacement === \"string\") {\n      replacement = identifier(replacement);\n    }\n\n    if (index === undefined) throw new Error(\"Assertion failure.\");\n  } else {\n    if (typeof replacement === \"string\") {\n      replacement = identifier(replacement);\n    }\n    if (Array.isArray(replacement)) {\n      throw new Error(\"Cannot replace single expression with an array.\");\n    }\n  }\n\n  function set(parent: any, key: any, value: any) {\n    const node = parent[key] as t.Node;\n    parent[key] = value;\n    if (node.type === \"Identifier\" || node.type === \"Placeholder\") {\n      if (node.typeAnnotation) {\n        value.typeAnnotation = node.typeAnnotation;\n      }\n      if (node.optional) {\n        value.optional = node.optional;\n      }\n      if (node.decorators) {\n        value.decorators = node.decorators;\n      }\n    }\n  }\n\n  if (index === undefined) {\n    validate(parent, key, replacement);\n\n    set(parent, key, replacement);\n  } else {\n    const items: Array<t.Node> = (parent as any)[key].slice();\n\n    if (placeholder.type === \"statement\" || placeholder.type === \"param\") {\n      if (replacement == null) {\n        items.splice(index, 1);\n      } else if (Array.isArray(replacement)) {\n        items.splice(index, 1, ...replacement);\n      } else {\n        set(items, index, replacement);\n      }\n    } else {\n      set(items, index, replacement);\n    }\n\n    validate(parent, key, items);\n    (parent as any)[key] = items;\n  }\n}\n", "import type { Formatter } from \"./formatters.ts\";\nimport type { TemplateOpts } from \"./options.ts\";\nimport type { Metadata } from \"./parse.ts\";\nimport { normalizeReplacements } from \"./options.ts\";\nimport parseAndBuildMetadata from \"./parse.ts\";\nimport populatePlaceholders from \"./populate.ts\";\n\nexport default function stringTemplate<T>(\n  formatter: Formatter<T>,\n  code: string,\n  opts: TemplateOpts,\n): (arg?: unknown) => T {\n  code = formatter.code(code);\n\n  let metadata: Metadata;\n\n  return (arg?: unknown) => {\n    const replacements = normalizeReplacements(arg);\n\n    if (!metadata) metadata = parseAndBuildMetadata(formatter, code, opts);\n\n    return formatter.unwrap(populatePlaceholders(metadata, replacements));\n  };\n}\n", "import type { Formatter } from \"./formatters.ts\";\nimport type { TemplateReplacements, TemplateOpts } from \"./options.ts\";\nimport { normalizeReplacements } from \"./options.ts\";\nimport parseAndBuildMetadata from \"./parse.ts\";\nimport populatePlaceholders from \"./populate.ts\";\n\nexport default function literalTemplate<T>(\n  formatter: Formatter<T>,\n  tpl: Array<string>,\n  opts: TemplateOpts,\n): (_: Array<unknown>) => (_: unknown) => T {\n  const { metadata, names } = buildLiteralData(formatter, tpl, opts);\n\n  return arg => {\n    const defaultReplacements: TemplateReplacements = {};\n    arg.forEach((replacement, i) => {\n      defaultReplacements[names[i]] = replacement;\n    });\n\n    return (arg: unknown) => {\n      const replacements = normalizeReplacements(arg);\n\n      if (replacements) {\n        Object.keys(replacements).forEach(key => {\n          if (Object.hasOwn(defaultReplacements, key)) {\n            throw new Error(\"Unexpected replacement overlap.\");\n          }\n        });\n      }\n\n      return formatter.unwrap(\n        populatePlaceholders(\n          metadata,\n          replacements\n            ? Object.assign(replacements, defaultReplacements)\n            : defaultReplacements,\n        ),\n      );\n    };\n  };\n}\n\nfunction buildLiteralData<T>(\n  formatter: Formatter<T>,\n  tpl: Array<string>,\n  opts: TemplateOpts,\n) {\n  let prefix = \"BABEL_TPL$\";\n\n  const raw = tpl.join(\"\");\n\n  do {\n    // If there are cases where the template already contains $$BABEL_TPL$0 or any other\n    // matching pattern, we keep adding \"$$\" characters until a unique prefix\n    // is found.\n    prefix = \"$$\" + prefix;\n  } while (raw.includes(prefix));\n\n  const { names, code } = buildTemplateCode(tpl, prefix);\n\n  const metadata = parseAndBuildMetadata(formatter, formatter.code(code), {\n    parser: opts.parser,\n\n    // Explicitly include our generated names in the whitelist so users never\n    // have to think about whether their placeholder pattern will match.\n    placeholderWhitelist: new Set(\n      names.concat(\n        opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [],\n      ),\n    ),\n    placeholderPattern: opts.placeholderPattern,\n    preserveComments: opts.preserveComments,\n    syntacticPlaceholders: opts.syntacticPlaceholders,\n  });\n\n  return { metadata, names };\n}\n\nfunction buildTemplateCode(\n  tpl: Array<string>,\n  prefix: string,\n): { names: Array<string>; code: string } {\n  const names = [];\n\n  let code = tpl[0];\n\n  for (let i = 1; i < tpl.length; i++) {\n    const value = `${prefix}${i - 1}`;\n    names.push(value);\n\n    code += value + tpl[i];\n  }\n\n  return { names, code };\n}\n", "import { merge, validate } from \"./options.ts\";\nimport type {\n  TemplateOpts,\n  PublicOpts,\n  PublicReplacements,\n} from \"./options.ts\";\nimport type { Formatter } from \"./formatters.ts\";\n\nimport stringTemplate from \"./string.ts\";\nimport literalTemplate from \"./literal.ts\";\n\nexport type TemplateBuilder<T> = {\n  // Build a new builder, merging the given options with the previous ones.\n  (opts: PublicOpts): TemplateBuilder<T>;\n\n  // Building from a string produces an AST builder function by default.\n  (tpl: string, opts?: PublicOpts): (replacements?: PublicReplacements) => T;\n\n  // Building from a template literal produces an AST builder function by default.\n  (\n    tpl: TemplateStringsArray,\n    ...args: Array<unknown>\n  ): (replacements?: PublicReplacements) => T;\n\n  // Allow users to explicitly create templates that produce ASTs, skipping\n  // the need for an intermediate function.\n  ast: {\n    (tpl: string, opts?: PublicOpts): T;\n    (tpl: TemplateStringsArray, ...args: Array<unknown>): T;\n  };\n};\n\n// Prebuild the options that will be used when parsing a `.ast` template.\n// These do not use a pattern because there is no way for users to pass in\n// replacement patterns to begin with, and disabling pattern matching means\n// users have more flexibility in what type of content they have in their\n// template JS.\nconst NO_PLACEHOLDER: TemplateOpts = validate({\n  placeholderPattern: false,\n});\n\nexport default function createTemplateBuilder<T>(\n  formatter: Formatter<T>,\n  defaultOpts?: TemplateOpts,\n): TemplateBuilder<T> {\n  const templateFnCache = new WeakMap();\n  const templateAstCache = new WeakMap();\n  const cachedOpts = defaultOpts || validate(null);\n\n  return Object.assign(\n    ((tpl, ...args) => {\n      if (typeof tpl === \"string\") {\n        if (args.length > 1) throw new Error(\"Unexpected extra params.\");\n        return extendedTrace(\n          stringTemplate(formatter, tpl, merge(cachedOpts, validate(args[0]))),\n        );\n      } else if (Array.isArray(tpl)) {\n        let builder = templateFnCache.get(tpl);\n        if (!builder) {\n          builder = literalTemplate(formatter, tpl, cachedOpts);\n          templateFnCache.set(tpl, builder);\n        }\n        return extendedTrace(builder(args));\n      } else if (typeof tpl === \"object\" && tpl) {\n        if (args.length > 0) throw new Error(\"Unexpected extra params.\");\n        return createTemplateBuilder(\n          formatter,\n          merge(cachedOpts, validate(tpl)),\n        );\n      }\n      throw new Error(`Unexpected template param ${typeof tpl}`);\n    }) as TemplateBuilder<T>,\n    {\n      ast: (tpl: string | Array<string>, ...args: Array<unknown>) => {\n        if (typeof tpl === \"string\") {\n          if (args.length > 1) throw new Error(\"Unexpected extra params.\");\n          return stringTemplate(\n            formatter,\n            tpl,\n            merge(merge(cachedOpts, validate(args[0])), NO_PLACEHOLDER),\n          )();\n        } else if (Array.isArray(tpl)) {\n          let builder = templateAstCache.get(tpl);\n          if (!builder) {\n            builder = literalTemplate(\n              formatter,\n              tpl,\n              merge(cachedOpts, NO_PLACEHOLDER),\n            );\n            templateAstCache.set(tpl, builder);\n          }\n          return builder(args)();\n        }\n\n        throw new Error(`Unexpected template param ${typeof tpl}`);\n      },\n    },\n  );\n}\n\nfunction extendedTrace<Arg, Result>(\n  fn: (_: Arg) => Result,\n): (_: Arg) => Result {\n  // Since we lazy parse the template, we get the current stack so we have the\n  // original stack to append if it errors when parsing\n  let rootStack = \"\";\n  try {\n    // error stack gets populated in IE only on throw\n    // (https://msdn.microsoft.com/en-us/library/hh699850(v=vs.94).aspx)\n    throw new Error();\n  } catch (error) {\n    if (error.stack) {\n      // error.stack does not exists in IE <= 9\n      // We slice off the top 3 items in the stack to remove the call to\n      // 'extendedTrace', and the anonymous builder function, with the final\n      // stripped line being the error message itself since we threw it\n      // in the first place and it doesn't matter.\n      rootStack = error.stack.split(\"\\n\").slice(3).join(\"\\n\");\n    }\n  }\n\n  return (arg: Arg) => {\n    try {\n      return fn(arg);\n    } catch (err) {\n      err.stack += `\\n    =============\\n${rootStack}`;\n      throw err;\n    }\n  };\n}\n", "import * as formatters from \"./formatters.ts\";\nimport createTemplateBuilder from \"./builder.ts\";\n\nexport const smart = createTemplateBuilder(formatters.smart);\nexport const statement = createTemplateBuilder(formatters.statement);\nexport const statements = createTemplateBuilder(formatters.statements);\nexport const expression = createTemplateBuilder(formatters.expression);\nexport const program = createTemplateBuilder(formatters.program);\n\ntype DefaultTemplateBuilder = typeof smart & {\n  smart: typeof smart;\n  statement: typeof statement;\n  statements: typeof statements;\n  expression: typeof expression;\n  program: typeof program;\n};\n\nexport default Object.assign(smart.bind(undefined) as DefaultTemplateBuilder, {\n  smart,\n  statement,\n  statements,\n  expression,\n  program,\n  ast: smart.ast,\n});\n\nexport type {\n  PublicOpts as Options,\n  PublicReplacements as Replacements,\n} from \"./options.ts\";\n", "// This file contains methods that convert the path node into another node or some other type of data.\n\nimport {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super as _super,\n  thisExpression,\n  toExpression,\n  unaryExpression,\n  toBindingIdentifierName,\n  isFunction,\n  isAssignmentPattern,\n  isRestElement,\n  getFunctionName,\n  cloneNode,\n  variableDeclaration,\n  variableDeclarator,\n  exportNamedDeclaration,\n  exportSpecifier,\n  inherits,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport template from \"@babel/template\";\nimport { environmentVisitor } from \"../visitors.ts\";\nimport type NodePath from \"./index.ts\";\nimport type { Visitor } from \"../types.ts\";\nimport { setup } from \"./context.ts\";\n\nexport function toComputedKey(this: NodePath) {\n  let key;\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  // @ts-expect-error todo(flow->ts) computed does not exist in ClassPrivateProperty\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nexport function ensureBlock(\n  this: NodePath<\n    t.Loop | t.WithStatement | t.Function | t.LabeledStatement | t.CatchClause\n  >,\n): void {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    // @ts-expect-error TS throws because ensureBlock returns the body node path\n    // however, we don't use the return value and treat it as a transform and\n    // assertion utilities. For better type inference we annotate it as an\n    // assertion method\n    // TODO: Unify the implementation with the type definition\n    return bodyNode;\n  }\n\n  const statements: Array<t.Statement> = [];\n\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node as t.Expression));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node as t.Expression));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath) as NodePath;\n  setup.call(\n    body,\n    parentPath,\n    listKey\n      ? // @ts-expect-error listKey must present in parent path\n        parentPath.node[listKey]\n      : parentPath.node,\n    listKey,\n    key,\n  );\n\n  // @ts-expect-error TS throws because ensureBlock returns the body node path\n  // however, we don't use the return value and treat it as a transform and\n  // assertion utilities. For better type inference we annotate it as an\n  // assertion method\n  // TODO: Unify the implementation with the type definition\n  return this.node;\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /**\n   * Keeping this for backward-compatibility. You should use arrowFunctionToExpression() for >=7.x.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.arrowFunctionToShadowed = function (this: NodePath) {\n    if (!this.isArrowFunctionExpression()) return;\n\n    this.arrowFunctionToExpression();\n  };\n}\n\n/**\n * Given an arbitrary function, process its content as if it were an arrow function, moving references\n * to \"this\", \"arguments\", \"super\", and such into the function's parent scope. This method is useful if\n * you have wrapped some set of items in an IIFE or other function, but want \"this\", \"arguments\", and super\"\n * to continue behaving as expected.\n */\nexport function unwrapFunctionEnvironment(this: NodePath) {\n  if (\n    !this.isArrowFunctionExpression() &&\n    !this.isFunctionExpression() &&\n    !this.isFunctionDeclaration()\n  ) {\n    throw this.buildCodeFrameError(\n      \"Can only unwrap the environment of a function.\",\n    );\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction setType<N extends t.Node, T extends N[\"type\"]>(\n  path: NodePath<N>,\n  type: T,\n): asserts path is NodePath<Extract<N, { type: T }>> {\n  path.node.type = type;\n}\n\n/**\n * Convert a given arrow function into a normal ES5 function expression.\n */\nexport function arrowFunctionToExpression(\n  this: NodePath<t.ArrowFunctionExpression>,\n  {\n    allowInsertArrow = true,\n    allowInsertArrowWithRest = allowInsertArrow,\n    noNewArrows = process.env.BABEL_8_BREAKING\n      ? // TODO(Babel 8): Consider defaulting to `false` for spec compliance\n        true\n      : !arguments[0]?.specCompliant,\n  }: {\n    allowInsertArrow?: boolean | void;\n    allowInsertArrowWithRest?: boolean | void;\n    noNewArrows?: boolean;\n  } = {},\n): NodePath<\n  Exclude<t.Function, t.Method | t.ArrowFunctionExpression> | t.CallExpression\n> {\n  if (!this.isArrowFunctionExpression()) {\n    throw (this as NodePath).buildCodeFrameError(\n      \"Cannot convert non-arrow function to a function expression.\",\n    );\n  }\n\n  let self = this;\n  if (!noNewArrows) {\n    // @ts-expect-error This is technicallynot valid on arrow functions\n    // because it adds an .id property, but we are going to convert it\n    // to a function expression anyway\n    self = self.ensureFunctionName(false) ?? self;\n  }\n\n  const { thisBinding, fnPath: fn } = hoistFunctionEnvironment(\n    self,\n    noNewArrows,\n    allowInsertArrow,\n    allowInsertArrowWithRest,\n  );\n\n  fn.ensureBlock();\n  setType(fn, \"FunctionExpression\");\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding\n      ? null\n      : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([]),\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\n      \"body\",\n      expressionStatement(\n        callExpression(this.hub.addHelper(\"newArrowCheck\"), [\n          thisExpression(),\n          checkBinding\n            ? identifier(checkBinding.name)\n            : identifier(thisBinding),\n        ]),\n      ),\n    );\n\n    fn.replaceWith(\n      callExpression(memberExpression(fn.node, identifier(\"bind\")), [\n        checkBinding ? identifier(checkBinding.name) : thisExpression(),\n      ]),\n    );\n\n    return fn.get(\"callee.object\");\n  }\n\n  return fn;\n}\n\nconst getSuperCallsVisitor = environmentVisitor<{\n  allSuperCalls: NodePath<t.CallExpression>[];\n}>({\n  CallExpression(child, { allSuperCalls }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  },\n});\n\n/**\n * Given a function, traverse its contents, and if there are references to \"this\", \"arguments\", \"super\",\n * or \"new.target\", ensure that these references reference the parent environment around this function.\n *\n * @returns `thisBinding`: the name of the injected reference to `this`; for example \"_this\"\n * @returns `fnPath`: the new path to the function node. This is different from the fnPath\n *                    parameter when the function node is wrapped in another node.\n */\nfunction hoistFunctionEnvironment(\n  fnPath: NodePath<t.Function>,\n  // TODO(Babel 8): Consider defaulting to `false` for spec compliance\n  noNewArrows: boolean | void = true,\n  allowInsertArrow: boolean | void = true,\n  allowInsertArrowWithRest: boolean | void = true,\n): { thisBinding: string; fnPath: NodePath<t.Function> } {\n  let arrowParent;\n  let thisEnvFn: NodePath<t.Function> = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      arrowParent ??= p;\n      return false;\n    }\n    return (\n      p.isFunction() ||\n      p.isProgram() ||\n      p.isClassProperty({ static: false }) ||\n      p.isClassPrivateProperty({ static: false })\n    );\n  }) as NodePath<t.Function>;\n  const inConstructor = thisEnvFn.isClassMethod({ kind: \"constructor\" });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      // It's safe to wrap this function in another and not hoist to the\n      // top level because the 'this' binding is constant in class\n      // properties (since 'super()' has already been called), so we don't\n      // need to capture/reassign it at the top level.\n      fnPath.replaceWith(\n        callExpression(\n          arrowFunctionExpression([], toExpression(fnPath.node)),\n          [],\n        ),\n      );\n      thisEnvFn = fnPath.get(\"callee\") as NodePath<t.ArrowFunctionExpression>;\n      fnPath = thisEnvFn.get(\"body\") as NodePath<t.FunctionExpression>;\n    } else {\n      throw fnPath.buildCodeFrameError(\n        \"Unable to transform arrow inside class property\",\n      );\n    }\n  }\n\n  const { thisPaths, argumentsPaths, newTargetPaths, superProps, superCalls } =\n    getScopeInformation(fnPath);\n\n  // Convert all super() calls in the constructor, if super is used in an arrow.\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\n        \"When using '@babel/plugin-transform-arrow-functions', \" +\n          \"it's not possible to compile `super()` in an arrow function without compiling classes.\\n\" +\n          \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n      );\n    }\n    if (!allowInsertArrowWithRest) {\n      // preset-env with target `since 2017` enables `transform-parameters` without `transform-classes`.\n      throw superCalls[0].buildCodeFrameError(\n        \"When using '@babel/plugin-transform-parameters', \" +\n          \"it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\\n\" +\n          \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n      );\n    }\n    const allSuperCalls: NodePath<t.CallExpression>[] = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, { allSuperCalls });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  // Convert all \"arguments\" references in the arrow to point at the alias.\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(\n          binaryExpression(\n            \"===\",\n            unaryExpression(\"typeof\", args()),\n            stringLiteral(\"undefined\"),\n          ),\n          thisEnvFn.scope.buildUndefinedNode(),\n          args(),\n        );\n      } else {\n        return args();\n      }\n    });\n\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  // Convert all \"new.target\" references in the arrow to point at the alias.\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () =>\n      metaProperty(identifier(\"new\"), identifier(\"target\")),\n    );\n\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  // Convert all \"super.prop\" references to point at aliases.\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\n        \"When using '@babel/plugin-transform-arrow-functions', \" +\n          \"it's not possible to compile `super.prop` in an arrow function without compiling classes.\\n\" +\n          \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n      );\n    }\n\n    const flatSuperProps: NodePath<t.MemberExpression>[] = superProps.reduce(\n      (acc, superProp) => acc.concat(standardizeSuperProperty(superProp)),\n      [],\n    );\n\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed\n        ? \"\"\n        : // @ts-expect-error super property must not contain private name\n          superProp.get(\"property\").node.name;\n\n      const superParentPath = superProp.parentPath;\n\n      const isAssignment = superParentPath.isAssignmentExpression({\n        left: superProp.node,\n      });\n      const isCall = superParentPath.isCallExpression({\n        callee: superProp.node,\n      });\n      const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({\n        tag: superProp.node,\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n\n      const args: t.Expression[] = [];\n      if (superProp.node.computed) {\n        // SuperProperty must not be a private name\n        args.push(superProp.get(\"property\").node as t.Expression);\n      }\n\n      if (isAssignment) {\n        const value = superParentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superParentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n\n        thisPaths.push(\n          superParentPath.get(\"arguments.0\") as NodePath<t.ThisExpression>,\n        );\n      } else if (isAssignment) {\n        // Replace not only the super.prop, but the whole assignment\n        superParentPath.replaceWith(call);\n      } else if (isTaggedTemplate) {\n        superProp.replaceWith(\n          callExpression(memberExpression(call, identifier(\"bind\"), false), [\n            thisExpression(),\n          ]),\n        );\n\n        thisPaths.push(\n          superProp.get(\"arguments.0\") as NodePath<t.ThisExpression>,\n        );\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  // Convert all \"this\" references in the arrow to point at the alias.\n  let thisBinding: string | null;\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (\n      noNewArrows ||\n      // In subclass constructors, still need to rewrite because \"this\" can't be bound in spec mode\n      // because it might not have been initialized yet.\n      (inConstructor && hasSuperClass(thisEnvFn))\n    ) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX()\n          ? jsxIdentifier(thisBinding)\n          : identifier(thisBinding);\n\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return { thisBinding, fnPath };\n}\n\ntype LogicalOp = Parameters<typeof logicalExpression>[0];\ntype BinaryOp = Parameters<typeof binaryExpression>[0];\n\nfunction isLogicalOp(op: string): op is LogicalOp {\n  return LOGICAL_OPERATORS.includes(op);\n}\n\nfunction standardizeSuperProperty(\n  superProp: NodePath<t.MemberExpression>,\n):\n  | [NodePath<t.MemberExpression>]\n  | [NodePath<t.MemberExpression>, NodePath<t.MemberExpression>] {\n  if (\n    superProp.parentPath.isAssignmentExpression() &&\n    superProp.parentPath.node.operator !== \"=\"\n  ) {\n    const assignmentPath = superProp.parentPath;\n\n    const op = assignmentPath.node.operator.slice(0, -1) as\n      | LogicalOp\n      | BinaryOp;\n\n    const value = assignmentPath.node.right;\n\n    const isLogicalAssignment = isLogicalOp(op);\n\n    if (superProp.node.computed) {\n      // from: super[foo] **= 4;\n      // to:   super[tmp = foo] = super[tmp] ** 4;\n\n      // from: super[foo] ??= 4;\n      // to:   super[tmp = foo] ?? super[tmp] = 4;\n\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n\n      const object = superProp.node.object;\n      const property = superProp.node.property as t.Expression;\n\n      assignmentPath\n        .get(\"left\")\n        .replaceWith(\n          memberExpression(\n            object,\n            assignmentExpression(\"=\", tmp, property),\n            true /* computed */,\n          ),\n        );\n\n      assignmentPath\n        .get(\"right\")\n        .replaceWith(\n          rightExpression(\n            isLogicalAssignment ? \"=\" : op,\n            memberExpression(object, identifier(tmp.name), true /* computed */),\n            value,\n          ),\n        );\n    } else {\n      // from: super.foo **= 4;\n      // to:   super.foo = super.foo ** 4;\n\n      // from: super.foo ??= 4;\n      // to:   super.foo ?? super.foo = 4;\n\n      const object = superProp.node.object;\n      const property = superProp.node.property as t.Identifier;\n\n      assignmentPath\n        .get(\"left\")\n        .replaceWith(memberExpression(object, property));\n\n      assignmentPath\n        .get(\"right\")\n        .replaceWith(\n          rightExpression(\n            isLogicalAssignment ? \"=\" : op,\n            memberExpression(object, identifier(property.name)),\n            value,\n          ),\n        );\n    }\n\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(\n        logicalExpression(\n          op,\n          assignmentPath.node.left as t.MemberExpression,\n          assignmentPath.node.right,\n        ),\n      );\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n\n    return [\n      assignmentPath.get(\"left\") as NodePath<t.MemberExpression>,\n      assignmentPath.get(\"right\").get(\"left\") as NodePath<t.MemberExpression>,\n    ];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed\n      ? superProp.scope.generateDeclaredUidIdentifier(\"prop\")\n      : null;\n\n    const parts: t.Expression[] = [\n      assignmentExpression(\n        \"=\",\n        tmp,\n        memberExpression(\n          superProp.node.object,\n          computedKey\n            ? assignmentExpression(\n                \"=\",\n                computedKey,\n                superProp.node.property as t.Expression,\n              )\n            : superProp.node.property,\n          superProp.node.computed,\n        ),\n      ),\n      assignmentExpression(\n        \"=\",\n        memberExpression(\n          superProp.node.object,\n          computedKey ? identifier(computedKey.name) : superProp.node.property,\n          superProp.node.computed,\n        ),\n        binaryExpression(\n          // map `++` to `+`, and `--` to `-`\n          superProp.parentPath.node.operator[0] as \"+\" | \"-\",\n          identifier(tmp.name),\n          numericLiteral(1),\n        ),\n      ),\n    ];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n\n    const left = updateExpr.get(\n      \"expressions.0.right\",\n    ) as NodePath<t.MemberExpression>;\n    const right = updateExpr.get(\n      \"expressions.1.left\",\n    ) as NodePath<t.MemberExpression>;\n    return [left, right];\n  }\n\n  return [superProp];\n\n  function rightExpression(\n    op: BinaryOp | \"=\",\n    left: t.MemberExpression,\n    right: t.Expression,\n  ) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\n\nfunction hasSuperClass(thisEnvFn: NodePath<t.Function>) {\n  return (\n    thisEnvFn.isClassMethod() &&\n    !!(thisEnvFn.parentPath.parentPath.node as t.Class).superClass\n  );\n}\n\nconst assignSuperThisVisitor = environmentVisitor<{\n  supers: WeakSet<t.CallExpression>;\n  thisBinding: string;\n}>({\n  CallExpression(child, { supers, thisBinding }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n\n    child.replaceWithMultiple([\n      child.node,\n      assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\")),\n    ]);\n  },\n});\n\n// Create a binding that evaluates to the \"this\" of the given function.\nfunction getThisBinding(\n  thisEnvFn: NodePath<t.Function>,\n  inConstructor: boolean,\n) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding,\n    });\n  });\n}\n\n// Create a binding for a function that will call \"super()\" with arguments passed through.\nfunction getSuperBinding(thisEnvFn: NodePath<t.Function>) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression(\n      [restElement(argsBinding)],\n      callExpression(_super(), [spreadElement(identifier(argsBinding.name))]),\n    );\n  });\n}\n\n// Create a binding for a function that will call \"super.foo\" or \"super[foo]\".\nfunction getSuperPropBinding(\n  thisEnvFn: NodePath<t.Function>,\n  isAssignment: boolean,\n  propName: string,\n) {\n  const op = isAssignment ? \"set\" : \"get\";\n\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n\n    let fnBody;\n    if (propName) {\n      // () => super.foo\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      // (method) => super[method]\n      argsList.unshift(method);\n      fnBody = memberExpression(\n        _super(),\n        identifier(method.name),\n        true /* computed */,\n      );\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(\n  thisEnvFn: NodePath,\n  key: string,\n  init: (name: string) => t.Expression,\n) {\n  const cacheKey = \"binding:\" + key;\n  let data: string | undefined = thisEnvFn.getData(cacheKey);\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data),\n    });\n  }\n\n  return data;\n}\n\ntype ScopeInfo = {\n  thisPaths: NodePath<t.ThisExpression | t.JSXIdentifier>[];\n  superCalls: NodePath<t.CallExpression>[];\n  superProps: NodePath<t.MemberExpression>[];\n  argumentsPaths: NodePath<t.Identifier | t.JSXIdentifier>[];\n  newTargetPaths: NodePath<t.MetaProperty>[];\n};\n\nconst getScopeInformationVisitor = environmentVisitor<ScopeInfo>({\n  ThisExpression(child, { thisPaths }) {\n    thisPaths.push(child);\n  },\n  JSXIdentifier(child, { thisPaths }) {\n    if (child.node.name !== \"this\") return;\n    if (\n      !child.parentPath.isJSXMemberExpression({ object: child.node }) &&\n      !child.parentPath.isJSXOpeningElement({ name: child.node })\n    ) {\n      return;\n    }\n\n    thisPaths.push(child);\n  },\n  CallExpression(child, { superCalls }) {\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n  MemberExpression(child, { superProps }) {\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n  Identifier(child, { argumentsPaths }) {\n    if (!child.isReferencedIdentifier({ name: \"arguments\" })) return;\n\n    let curr = child.scope;\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while ((curr = curr.parent));\n\n    argumentsPaths.push(child);\n  },\n  MetaProperty(child, { newTargetPaths }) {\n    if (!child.get(\"meta\").isIdentifier({ name: \"new\" })) return;\n    if (!child.get(\"property\").isIdentifier({ name: \"target\" })) return;\n\n    newTargetPaths.push(child);\n  },\n});\n\nfunction getScopeInformation(fnPath: NodePath) {\n  const thisPaths: ScopeInfo[\"thisPaths\"] = [];\n  const argumentsPaths: ScopeInfo[\"argumentsPaths\"] = [];\n  const newTargetPaths: ScopeInfo[\"newTargetPaths\"] = [];\n  const superProps: ScopeInfo[\"superProps\"] = [];\n  const superCalls: ScopeInfo[\"superCalls\"] = [];\n\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls,\n  });\n\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls,\n  };\n}\n\nexport function splitExportDeclaration(\n  this: NodePath<t.ExportDefaultDeclaration | t.ExportNamedDeclaration>,\n): NodePath<t.Declaration> {\n  if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {\n    throw new Error(\"Only default and named export declarations can be split.\");\n  }\n  if (this.isExportNamedDeclaration() && this.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const declaration = this.get(\"declaration\");\n\n  if (this.isExportDefaultDeclaration()) {\n    const standaloneDeclaration =\n      declaration.isFunctionDeclaration() || declaration.isClassDeclaration();\n    const exportExpr =\n      declaration.isFunctionExpression() || declaration.isClassExpression();\n\n    const scope = declaration.isScope()\n      ? declaration.scope.parent\n      : declaration.scope;\n\n    // @ts-expect-error id is not defined in expressions other than function/class\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n\n    if (!id) {\n      needBindingRegistration = true;\n\n      id = scope.generateUidIdentifier(\"default\");\n\n      if (standaloneDeclaration || exportExpr) {\n        declaration.node.id = cloneNode(id);\n      }\n    } else if (exportExpr && scope.hasBinding(id.name)) {\n      needBindingRegistration = true;\n\n      id = scope.generateUidIdentifier(id.name);\n    }\n\n    const updatedDeclaration = standaloneDeclaration\n      ? declaration.node\n      : variableDeclaration(\"var\", [\n          variableDeclarator(\n            cloneNode(id),\n            // @ts-expect-error When `standaloneDeclaration` is false, declaration must not be a Function/ClassDeclaration\n            declaration.node,\n          ),\n        ]);\n\n    const updatedExportDeclaration = exportNamedDeclaration(null, [\n      exportSpecifier(cloneNode(id), identifier(\"default\")),\n    ]);\n\n    this.insertAfter(updatedExportDeclaration);\n    this.replaceWith(updatedDeclaration);\n\n    if (needBindingRegistration) {\n      scope.registerDeclaration(this);\n    }\n\n    return this;\n  } else if (this.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return exportSpecifier(identifier(name), identifier(name));\n  });\n\n  const aliasDeclar = exportNamedDeclaration(null, specifiers);\n\n  this.insertAfter(aliasDeclar);\n  this.replaceWith(declaration.node);\n  return this;\n}\n\nconst refersOuterBindingVisitor: Visitor<{\n  needsRename: boolean;\n  name: string;\n}> = {\n  \"ReferencedIdentifier|BindingIdentifier\"(\n    path: NodePath<t.Identifier>,\n    state,\n  ) {\n    // check if this node matches our function id\n    if (path.node.name !== state.name) return;\n    state.needsRename = true;\n    path.stop();\n  },\n  Scope(path, state) {\n    if (path.scope.hasOwnBinding(state.name)) {\n      path.skip();\n    }\n  },\n};\n\nexport function ensureFunctionName<\n  N extends t.FunctionExpression | t.ClassExpression,\n>(this: NodePath<N>, supportUnicodeId: boolean): null | NodePath<N> {\n  if (this.node.id) return this;\n\n  const res = getFunctionName(this.node, this.parent);\n  if (res == null) return this;\n  let { name } = res;\n\n  if (!supportUnicodeId && /[\\uD800-\\uDFFF]/.test(name)) {\n    return null;\n  }\n\n  if (name.startsWith(\"get \") || name.startsWith(\"set \")) {\n    // TODO: Remove this to support naming getters and setters\n    return null;\n  }\n\n  name = toBindingIdentifierName(name.replace(/[/ ]/g, \"_\"));\n  const id = identifier(name);\n  inherits(id, res.originalNode);\n\n  const state = { needsRename: false, name };\n\n  // check to see if we have a local binding of the id we're setting inside of\n  // the function, this is important as there are caveats associated\n\n  const { scope } = this;\n  const binding = scope.getOwnBinding(name);\n  if (binding) {\n    if (binding.kind === \"param\") {\n      // safari will blow up in strict mode with code like:\n      //\n      //   let t = function t(t) {};\n      //\n      // with the error:\n      //\n      //   Cannot declare a parameter named 't' as it shadows the name of a\n      //   strict mode function.\n      //\n      // this isn't to the spec and they've invented this behaviour which is\n      // **extremely** annoying so we avoid setting the name if it has a param\n      // with the same id\n      state.needsRename = true;\n    } else {\n      // otherwise it's defined somewhere in scope like:\n      //\n      //   let t = function () {\n      //     let t = 2;\n      //   };\n      //\n      // so we can safely just set the id and move along as it shadows the\n      // bound function id\n    }\n  } else if (scope.parent.hasBinding(name) || scope.hasGlobal(name)) {\n    this.traverse(refersOuterBindingVisitor, state);\n  }\n\n  if (!state.needsRename) {\n    this.node.id = id;\n    if (process.env.BABEL_8_BREAKING) {\n      scope.getProgramParent().referencesSet.add(id.name);\n    } else {\n      // @ts-expect-error Babel 7\n      scope.getProgramParent().references[id.name] = true;\n    }\n    return this;\n  }\n\n  if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n    // we can just munge the local binding\n    scope.rename(id.name);\n    this.node.id = id;\n    if (process.env.BABEL_8_BREAKING) {\n      scope.getProgramParent().referencesSet.add(id.name);\n    } else {\n      // @ts-expect-error Babel 7\n      scope.getProgramParent().references[id.name] = true;\n    }\n    return this;\n  }\n\n  // TODO: we don't currently support wrapping class expressions\n  if (!isFunction(this.node)) return null;\n\n  // need to add a wrapper since we can't change the references\n\n  const key = scope.generateUidIdentifier(id.name);\n  // shim in dummy params to retain function arity, if you try to read the\n  // source then you'll get the original since it's proxied so it's all good\n  const params = [];\n  for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {\n    params.push(scope.generateUidIdentifier(\"x\"));\n  }\n  const call = template.expression.ast`\n    (function (${key}) {\n      function ${id}(${params}) {\n        return ${cloneNode(key)}.apply(this, arguments);\n      }\n\n      ${cloneNode(id)}.toString = function () {\n        return ${cloneNode(key)}.toString();\n      }\n\n      return ${cloneNode(id)};\n    })(${toExpression(this.node)})\n  ` as t.CallExpression;\n\n  return this.replaceWith(call)[0].get(\"arguments.0\") as NodePath<N>;\n}\n\nfunction getFunctionArity(node: t.Function): number {\n  const count = node.params.findIndex(\n    param => isAssignmentPattern(param) || isRestElement(param),\n  );\n  return count === -1 ? node.params.length : count;\n}\n", "// This file contains methods responsible for introspecting the current path for certain values.\n\nimport type NodePath from \"./index.ts\";\nimport {\n  STATEMENT_OR_BLOCK_KEYS,\n  VISITOR_KEYS,\n  isBlockStatement,\n  isExpression,\n  isIdentifier,\n  isLiteral,\n  isStringLiteral,\n  isType,\n  matchesPattern as _matchesPattern,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n/**\n * Match the current node if it matches the provided `pattern`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\n\nexport function matchesPattern(\n  this: NodePath,\n  pattern: string,\n  allowPartial?: boolean,\n): boolean {\n  return _matchesPattern(this.node, pattern, allowPartial);\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /**\n   * Check whether we have the input `key`. If the `key` references an array then we check\n   * if the array has any items, otherwise we just check if it's falsy.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.has = function has<N extends t.Node>(\n    this: NodePath<N>,\n    key: keyof N,\n  ): boolean {\n    const val = (this.node as N)?.[key];\n    if (val && Array.isArray(val)) {\n      return !!val.length;\n    } else {\n      return !!val;\n    }\n  };\n}\n\nexport function isStatic(this: NodePath): boolean {\n  return this.scope.isStatic(this.node);\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /**\n   * Alias of `has`.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.is = exports.has;\n\n  /**\n   * Opposite of `has`.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.isnt = function isnt<N extends t.Node>(\n    this: NodePath<N>,\n    key: keyof N,\n  ): boolean {\n    // @ts-expect-error Babel 7\n    return !this.has(key);\n  };\n\n  /**\n   * Check whether the path node `key` strict equals `value`.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.equals = function equals<N extends t.Node>(\n    this: NodePath<N>,\n    key: keyof N,\n    value: any,\n  ): boolean {\n    return (this.node as N)[key] === value;\n  };\n}\n\n/**\n * Check the type against our stored internal type of the node. This is handy when a node has\n * been removed yet we still internally know the type and need it to calculate node replacement.\n */\n\nexport function isNodeType(this: NodePath, type: string): boolean {\n  return isType(this.type, type);\n}\n\n/**\n * This checks whether or not we're in one of the following positions:\n *\n *   for (KEY in right);\n *   for (KEY;;);\n *\n * This is because these spots allow VariableDeclarations AND normal expressions so we need\n * to tell the path replacement that it's ok to replace this with an expression.\n */\n\nexport function canHaveVariableDeclarationOrExpression(this: NodePath) {\n  return (\n    (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor()\n  );\n}\n\n/**\n * This checks whether we are swapping an arrow function's body between an\n * expression and a block statement (or vice versa).\n *\n * This is because arrow functions may implicitly return an expression, which\n * is the same as containing a block statement.\n */\n\nexport function canSwapBetweenExpressionAndStatement(\n  this: NodePath,\n  replacement: t.Node,\n): boolean {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return isExpression(replacement);\n  }\n\n  return false;\n}\n\n/**\n * Check whether the current path references a completion record\n */\n\nexport function isCompletionRecord(\n  this: NodePath,\n  allowInsideFunction?: boolean,\n): boolean {\n  let path = this;\n  let first = true;\n\n  do {\n    const { type, container } = path;\n\n    // we're in a function so can't be a completion record\n    if (!first && (path.isFunction() || type === \"StaticBlock\")) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    // check to see if we're the last item in the container and if we are\n    // we're a completion record!\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while (\n    (path = path.parentPath) &&\n    !path.isProgram() &&\n    !path.isDoExpression()\n  );\n\n  return true;\n}\n\n/**\n * Check whether or not the current `key` allows either a single statement or block statement\n * so we can explode it if necessary.\n */\n\nexport function isStatementOrBlock(this: NodePath): boolean {\n  if (\n    this.parentPath.isLabeledStatement() ||\n    isBlockStatement(this.container as t.Node)\n  ) {\n    return false;\n  } else {\n    return STATEMENT_OR_BLOCK_KEYS.includes(this.key as string);\n  }\n}\n\n/**\n * Check if the currently assigned path references the `importName` of `moduleSource`.\n */\n\nexport function referencesImport(\n  this: NodePath,\n  moduleSource: string,\n  importName: string,\n): boolean {\n  if (!this.isReferencedIdentifier()) {\n    if (\n      (this.isJSXMemberExpression() &&\n        this.node.property.name === importName) ||\n      ((this.isMemberExpression() || this.isOptionalMemberExpression()) &&\n        (this.node.computed\n          ? isStringLiteral(this.node.property, { value: importName })\n          : (this.node.property as t.Identifier).name === importName))\n    ) {\n      const object = (\n        this as NodePath<t.MemberExpression | t.OptionalMemberExpression>\n      ).get(\"object\");\n      return (\n        object.isReferencedIdentifier() &&\n        object.referencesImport(moduleSource, \"*\")\n      );\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding((this.node as t.Identifier).name);\n  if (!binding || binding.kind !== \"module\") return false;\n\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  // check moduleSource\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (\n    path.isImportSpecifier() &&\n    isIdentifier(path.node.imported, { name: importName })\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Get the source code associated with this node.\n */\n\nexport function getSource(this: NodePath): string {\n  const node = this.node;\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n  return \"\";\n}\n\nexport function willIMaybeExecuteBefore(\n  this: NodePath,\n  target: NodePath,\n): boolean {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path: NodePath) {\n  return path.isProgram()\n    ? path\n    : (\n        path.parentPath.scope.getFunctionParent() ||\n        path.parentPath.scope.getProgramParent()\n      ).path;\n}\n\nfunction isExecutionUncertain(type: t.Node[\"type\"], key: string) {\n  switch (type) {\n    // a && FOO\n    // a || FOO\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    // a ? FOO : FOO\n    // if (a) FOO; else FOO;\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    // while (a) FOO;\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    // for (a; b; FOO) FOO;\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    // switch (a) { FOO }\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    // try { a } catch FOO finally { b }\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    // var [ x = FOO ]\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    // a?.[FOO]\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    // a?.(FOO)\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths: NodePath[], maxIndex: number) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// TODO(Babel 8)\n// This can be { before: boolean, after: boolean, unknown: boolean }.\n// This allows transforms like the tdz one to treat cases when the status\n// is both before and unknown/after like if it were before.\ntype RelativeExecutionStatus = \"before\" | \"after\" | \"unknown\";\n\n// Used to avoid infinite recursion in cases like\n//   function f() { if (false) f(); }\n//   f();\n// It also works with indirect recursion.\nconst SYMBOL_CHECKING = Symbol();\n\ntype ExecutionStatusCache = Map<\n  t.Node,\n  Map<t.Node, RelativeExecutionStatus | typeof SYMBOL_CHECKING>\n>;\n\n/**\n * Given a `target` check the execution status of it relative to the current path.\n *\n * \"Execution status\" simply refers to where or not we **think** this will execute\n * before or after the input `target` element.\n */\n\nexport function _guessExecutionStatusRelativeTo(\n  this: NodePath,\n  target: NodePath,\n): RelativeExecutionStatus {\n  return _guessExecutionStatusRelativeToCached(this, target, new Map());\n}\n\nfunction _guessExecutionStatusRelativeToCached(\n  base: NodePath,\n  target: NodePath,\n  cache: ExecutionStatusCache,\n): RelativeExecutionStatus {\n  // check if the two paths are in different functions, we can't track execution of these\n  const funcParent = {\n    this: getOuterFunction(base),\n    target: getOuterFunction(target),\n  };\n\n  // here we check the `node` equality as sometimes we may have different paths for the\n  // same node due to path thrashing\n  if (funcParent.target.node !== funcParent.this.node) {\n    return _guessExecutionStatusRelativeToDifferentFunctionsCached(\n      base,\n      funcParent.target,\n      cache,\n    );\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: base.getAncestry(),\n  };\n\n  // If this is an ancestor of the target path,\n  // e.g. f(g); where this is f and target is g.\n  if (paths.target.includes(base)) return \"after\";\n  if (paths.this.includes(target)) return \"before\";\n\n  // get ancestor where the branches intersect\n  let commonPath;\n  const commonIndex = { target: 0, this: 0 };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\n      \"Internal Babel error - The two compared nodes\" +\n        \" don't appear to belong to the same program.\",\n    );\n  }\n\n  if (\n    isExecutionUncertainInList(paths.this, commonIndex.this - 1) ||\n    isExecutionUncertainInList(paths.target, commonIndex.target - 1)\n  ) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1],\n  };\n\n  // container list so let's see which one is after the other\n  // e.g. [ THIS, TARGET ]\n  if (\n    divergence.target.listKey &&\n    divergence.this.listKey &&\n    divergence.target.container === divergence.this.container\n  ) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  // otherwise we're associated by a parent node, check which key comes before the other\n  const keys = VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey),\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nfunction _guessExecutionStatusRelativeToDifferentFunctionsInternal(\n  base: NodePath,\n  target: NodePath,\n  cache: ExecutionStatusCache,\n): RelativeExecutionStatus {\n  if (!target.isFunctionDeclaration()) {\n    if (\n      _guessExecutionStatusRelativeToCached(base, target, cache) === \"before\"\n    ) {\n      return \"before\";\n    }\n    return \"unknown\";\n  } else if (target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  // so we're in a completely different function, if this is a function declaration\n  // then we can be a bit smarter and handle cases where the function is either\n  // a. not called at all (part of an export)\n  // b. called directly\n  const binding = target.scope.getBinding(target.node.id.name);\n\n  // no references!\n  if (!binding.references) return \"before\";\n\n  const referencePaths: Array<NodePath> = binding.referencePaths;\n\n  let allStatus;\n\n  // verify that all the calls have the same execution status\n  for (const path of referencePaths) {\n    // if a reference is a child of the function we're checking against then we can\n    // safely ignore it\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      // This function is passed as a reference, so we don't\n      // know when it will be called.\n      return \"unknown\";\n    }\n\n    const status = _guessExecutionStatusRelativeToCached(base, path, cache);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction _guessExecutionStatusRelativeToDifferentFunctionsCached(\n  base: NodePath,\n  target: NodePath,\n  cache: ExecutionStatusCache,\n): RelativeExecutionStatus {\n  let nodeMap = cache.get(base.node);\n  let cached;\n\n  if (!nodeMap) {\n    cache.set(base.node, (nodeMap = new Map()));\n  } else if ((cached = nodeMap.get(target.node))) {\n    if (cached === SYMBOL_CHECKING) {\n      return \"unknown\";\n    }\n    return cached;\n  }\n\n  nodeMap.set(target.node, SYMBOL_CHECKING);\n\n  const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(\n    base,\n    target,\n    cache,\n  );\n\n  nodeMap.set(target.node, result);\n  return result;\n}\n\n/**\n * Resolve the value pointed to by a NodePath\n * e.g.\n * ```\n *  var a = 1;\n *  var b = a;\n *  b;\n * ```\n * `b.resolve()` will return `1`\n */\nexport function resolve(\n  this: NodePath,\n  dangerous?: boolean,\n  resolved?: NodePath[],\n) {\n  return _resolve.call(this, dangerous, resolved) || this;\n}\n\nexport function _resolve(\n  this: NodePath,\n  dangerous?: boolean,\n  resolved?: NodePath[],\n): NodePath | undefined | null {\n  // detect infinite recursion\n  // todo: possibly have a max length on this just to be safe\n  if (resolved?.includes(this)) return;\n\n  // we store all the paths we've \"resolved\" in this array to prevent infinite recursion\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {\n      // otherwise it's a request for a pattern and that's a bit more tricky\n    }\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n\n    // reassigned so we can't really resolve it\n    if (!binding.constant) return;\n\n    // todo - lookup module in dependency graph\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      // If the identifier resolves to parent node then we can't really resolve it.\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    // @ ts-ignore todo: babel-types\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    // this is dangerous, as non-direct target assignments will mutate it's state\n    // making this resolution inaccurate\n\n    const targetKey = this.toComputedKey();\n    if (!isLiteral(targetKey)) return;\n\n    // @ts-expect-error todo(flow->ts): NullLiteral\n    const targetName = targetKey.value;\n\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n      for (const prop of props as any[]) {\n        if (!prop.isProperty()) continue;\n\n        const key = prop.get(\"key\");\n\n        // { foo: obj }\n        let match =\n          prop.isnt(\"computed\") && key.isIdentifier({ name: targetName });\n\n        // { \"foo\": \"obj\" } or { [\"foo\"]: \"obj\" }\n        match = match || key.isLiteral({ value: targetName });\n\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nexport function isConstantExpression(this: NodePath): boolean {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression =>\n        expression.isConstantExpression(),\n      );\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    const { operator } = this.node;\n    return (\n      operator !== \"in\" &&\n      operator !== \"instanceof\" &&\n      this.get(\"left\").isConstantExpression() &&\n      this.get(\"right\").isConstantExpression()\n    );\n  }\n\n  if (this.isMemberExpression()) {\n    return (\n      !this.node.computed &&\n      this.get(\"object\").isIdentifier({ name: \"Symbol\" }) &&\n      !this.scope.hasBinding(\"Symbol\", { noGlobals: true })\n    );\n  }\n\n  if (this.isCallExpression()) {\n    return (\n      this.node.arguments.length === 1 &&\n      this.get(\"callee\").matchesPattern(\"Symbol.for\") &&\n      !this.scope.hasBinding(\"Symbol\", { noGlobals: true }) &&\n      this.get(\"arguments\")[0].isStringLiteral()\n    );\n  }\n\n  return false;\n}\n\nexport function isInStrictMode(this: NodePath) {\n  const start = this.isProgram() ? this : this.parentPath;\n\n  const strictParent = start.find(path => {\n    if (path.isProgram({ sourceType: \"module\" })) return true;\n\n    if (path.isClass()) return true;\n\n    if (\n      path.isArrowFunctionExpression() &&\n      !path.get(\"body\").isBlockStatement()\n    ) {\n      return false;\n    }\n\n    let body: t.BlockStatement | t.Program;\n    if (path.isFunction()) {\n      body = path.node.body as t.BlockStatement;\n    } else if (path.isProgram()) {\n      // @ts-expect-error TODO: TS thinks that `path` here cannot be\n      // Program due to the `isProgram()` check at the beginning of\n      // the function\n      body = path.node;\n    } else {\n      return false;\n    }\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n\n  return !!strictParent;\n}\n", "// This file contains methods responsible for dealing with/retrieving children or siblings.\n\nimport type TraversalContext from \"../context.ts\";\nimport NodePath from \"./index.ts\";\nimport {\n  getAssignmentIdentifiers as _getAssignmentIdentifiers,\n  getBindingIdentifiers as _getBindingIdentifiers,\n  getOuterBindingIdentifiers as _getOuterBindingIdentifiers,\n  numericLiteral,\n  unaryExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\ntype Completion = {\n  path: NodePath;\n  type: 0 | 1;\n};\n\ntype CompletionContext = {\n  // whether the current context allows `break` statement. When it allows, we have\n  // to search all the statements for potential `break`\n  canHaveBreak: boolean;\n  // whether the statement is an immediate descendant of a switch case clause\n  inCaseClause: boolean;\n  // whether the `break` statement record should be populated to upper level\n  // when a `break` statement is an immediate descendant of a block statement, e.g.\n  // `{ break }`, it can influence the control flow in the upper levels.\n  shouldPopulateBreak: boolean;\n  // Whether the `break` statement should be preserved.\n  shouldPreserveBreak: boolean;\n};\n\nfunction NormalCompletion(path: NodePath): Completion {\n  return { type: NORMAL_COMPLETION, path };\n}\n\nfunction BreakCompletion(path: NodePath): Completion {\n  return { type: BREAK_COMPLETION, path };\n}\n\nexport function getOpposite(this: NodePath): NodePath | null {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n  return null;\n}\n\nfunction addCompletionRecords(\n  path: NodePath | null | undefined,\n  records: Completion[],\n  context: CompletionContext,\n): Completion[] {\n  if (path) {\n    records.push(..._getCompletionRecords(path, context));\n  }\n  return records;\n}\n\nfunction completionRecordForSwitch(\n  cases: NodePath<t.SwitchCase>[],\n  records: Completion[],\n  context: CompletionContext,\n): Completion[] {\n  // https://tc39.es/ecma262/#sec-runtime-semantics-caseblockevaluation\n  let lastNormalCompletions: Completion[] = [];\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n    const caseCompletions = _getCompletionRecords(casePath, context);\n    const normalCompletions = [];\n    const breakCompletions = [];\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n    records.push(...breakCompletions);\n  }\n  records.push(...lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions: Completion[]) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\n/**\n * Determine how we should handle the break statement for break completions\n *\n * @param {Completion[]} completions\n * @param {boolean} reachable Whether the break statement is reachable after\n   we mark the normal completions _before_ the given break completions as the final\n   completions. For example,\n   `{ 0 }; break;` is transformed to `{ return 0 }; break;`, the `break` here is unreachable\n   and thus can be removed without consequences. We may in the future reserve them instead since\n   we do not consistently remove unreachable statements _after_ break\n   `{ var x = 0 }; break;` is transformed to `{ var x = 0 }; return void 0;`, the `break` is reachable\n   because we can not wrap variable declaration under a return statement\n */\nfunction replaceBreakStatementInBreakCompletion(\n  completions: Completion[],\n  reachable: boolean,\n) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({ label: null })) {\n      if (reachable) {\n        c.path.replaceWith(unaryExpression(\"void\", numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(\n  paths: NodePath[],\n  context: CompletionContext,\n): Completion[] {\n  const completions = [];\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = { ...context, inCaseClause: false };\n      if (\n        path.isBlockStatement() &&\n        (context.inCaseClause || // case test: { break }\n          context.shouldPopulateBreak) // case test: { { break } }\n      ) {\n        newContext.shouldPopulateBreak = true;\n      } else {\n        newContext.shouldPopulateBreak = false;\n      }\n      const statementCompletions = _getCompletionRecords(path, newContext);\n      if (\n        statementCompletions.length > 0 &&\n        // we can stop search `paths` when we have seen a `path` that is\n        // effectively a `break` statement. Examples are\n        // - `break`\n        // - `if (true) { 1; break } else { 2; break }`\n        // - `{ break }```\n        // In other words, the paths after this `path` are unreachable\n        statementCompletions.every(c => c.type === BREAK_COMPLETION)\n      ) {\n        if (\n          lastNormalCompletions.length > 0 &&\n          statementCompletions.every(c =>\n            c.path.isBreakStatement({ label: null }),\n          )\n        ) {\n          // when a break completion has a path as BreakStatement, it must be `{ break }`\n          // whose completion value we can not determine, otherwise it would have been\n          // replaced by `replaceBreakStatementInBreakCompletion`\n          // When we have seen normal completions from the last statement\n          // it is safe to stop populating break and mark normal completions as break\n          normalCompletionToBreak(lastNormalCompletions);\n          completions.push(...lastNormalCompletions);\n          // Declarations have empty completion record, however they can not be nested\n          // directly in return statement, i.e. `return (var a = 1)` is invalid.\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions.push(...statementCompletions);\n            if (!context.shouldPreserveBreak) {\n              replaceBreakStatementInBreakCompletion(\n                statementCompletions,\n                /* reachable */ true,\n              );\n            }\n          }\n          if (!context.shouldPreserveBreak) {\n            replaceBreakStatementInBreakCompletion(\n              statementCompletions,\n              /* reachable */ false,\n            );\n          }\n        } else {\n          completions.push(...statementCompletions);\n          if (!context.shouldPopulateBreak && !context.shouldPreserveBreak) {\n            replaceBreakStatementInBreakCompletion(\n              statementCompletions,\n              /* reachable */ true,\n            );\n          }\n        }\n        break;\n      }\n      if (i === paths.length - 1) {\n        completions.push(...statementCompletions);\n      } else {\n        lastNormalCompletions = [];\n        for (let i = 0; i < statementCompletions.length; i++) {\n          const c = statementCompletions[i];\n          if (c.type === BREAK_COMPLETION) {\n            completions.push(c);\n          }\n          if (c.type === NORMAL_COMPLETION) {\n            lastNormalCompletions.push(c);\n          }\n        }\n      }\n    }\n  } else if (paths.length) {\n    // When we are in a context where `break` must not exist, we can skip linear\n    // search on statement lists and assume that the last\n    // non-variable-declaration statement determines the completion.\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n      if (\n        pathCompletions.length > 1 ||\n        (pathCompletions.length === 1 &&\n          !pathCompletions[0].path.isVariableDeclaration() &&\n          !pathCompletions[0].path.isEmptyStatement())\n      ) {\n        completions.push(...pathCompletions);\n        break;\n      }\n    }\n  }\n  return completions;\n}\n\nfunction _getCompletionRecords(\n  path: NodePath,\n  context: CompletionContext,\n): Completion[] {\n  let records: Completion[] = [];\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (\n    path.isDoExpression() ||\n    path.isFor() ||\n    path.isWhile() ||\n    path.isLabeledStatement()\n  ) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    return getStatementListCompletion(path.get(\"body\"), context);\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    return completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    return getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true,\n      shouldPreserveBreak: context.shouldPreserveBreak,\n    });\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\n/**\n * Retrieve the completion records of a given path.\n * Note: to ensure proper support on `break` statement, this method\n * will manipulate the AST around the break statement. Do not call the method\n * twice for the same path.\n *\n * @export\n * @param {NodePath} this\n * @param {boolean} [shouldPreserveBreak=false] Whether the `break` statement should be preserved.\n * @returns {NodePath[]} Completion records\n */\nexport function getCompletionRecords(\n  this: NodePath,\n  shouldPreserveBreak = false,\n): NodePath[] {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false,\n    shouldPreserveBreak,\n  });\n  return records.map(r => r.path);\n}\n\nexport function getSibling(this: NodePath, key: string | number): NodePath {\n  return NodePath.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key,\n  }).setContext(this.context);\n}\n\nexport function getPrevSibling(this: NodePath): NodePath {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  return this.getSibling(this.key - 1);\n}\n\nexport function getNextSibling(this: NodePath): NodePath {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  return this.getSibling(this.key + 1);\n}\n\nexport function getAllNextSiblings(this: NodePath): NodePath[] {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  let _key: number = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n  return siblings;\n}\n\nexport function getAllPrevSiblings(this: NodePath): NodePath[] {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  let _key: number = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n  return siblings;\n}\n\n// convert \"1\" to 1 (string index to number index)\ntype MaybeToIndex<T extends string> = T extends `${bigint}` ? number : T;\n\ntype Pattern<Obj extends string, Prop extends string> = `${Obj}.${Prop}`;\n\n// split \"body.body.1\" to [\"body\", \"body\", 1]\ntype Split<P extends string> =\n  P extends Pattern<infer O, infer U>\n    ? [MaybeToIndex<O>, ...Split<U>]\n    : [MaybeToIndex<P>];\n\n// traverse the Node with tuple path [\"body\", \"body\", 1]\n// Path should be created with Split\ntype Trav<\n  Node extends t.Node | t.Node[],\n  Path extends unknown[],\n> = Path extends [infer K, ...infer R]\n  ? K extends keyof Node\n    ? Node[K] extends t.Node | t.Node[]\n      ? R extends []\n        ? Node[K]\n        : Trav<Node[K], R>\n      : never\n    : never\n  : never;\n\ntype ToNodePath<T> =\n  T extends Array<(infer U extends t.Node) | null | undefined>\n    ? Array<NodePath<U> | null | undefined>\n    : T extends (infer U extends t.Node) | null | undefined\n      ? NodePath<U> | null | undefined\n      : never;\n\nfunction get<T extends NodePath, K extends keyof T[\"node\"]>(\n  this: T,\n  key: K,\n  context?: boolean | TraversalContext,\n): T extends any\n  ? T[\"node\"][K] extends Array<(infer U extends t.Node) | null | undefined>\n    ? Array<NodePath<U> | null | undefined>\n    : T[\"node\"][K] extends (infer U extends t.Node) | null | undefined\n      ? NodePath<U> | null | undefined\n      : never\n  : never;\n\nfunction get<T extends NodePath, K extends string>(\n  this: T,\n  key: K,\n  context?: boolean | TraversalContext,\n): T extends any ? ToNodePath<Trav<T[\"node\"], Split<K>>> : never;\n\nfunction get(\n  this: NodePath,\n  key: string,\n  context?: true | TraversalContext,\n): NodePath | NodePath[];\n\nfunction get(\n  this: NodePath,\n  key: string,\n  context: true | TraversalContext = true,\n): NodePath | NodePath[] {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n  if (parts.length === 1) {\n    // \"foo\"\n    // @ts-expect-error key may not index T\n    return _getKey.call(this, key, context);\n  } else {\n    // \"foo.bar\"\n    return _getPattern.call(this, parts, context);\n  }\n}\n\nexport { get };\n\nexport function _getKey<T extends t.Node>(\n  this: NodePath<T>,\n  key: keyof T & string,\n  context?: TraversalContext,\n): NodePath | NodePath[] {\n  const node = this.node as T;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    // requested a container so give them all the paths\n    return container.map((_, i) => {\n      return NodePath.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i,\n      }).setContext(context);\n    });\n  } else {\n    return NodePath.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key,\n    }).setContext(context);\n  }\n}\n\nexport function _getPattern(\n  this: NodePath,\n  parts: string[],\n  context?: TraversalContext,\n): NodePath | NodePath[] {\n  let path: NodePath | NodePath[] = this;\n  for (const part of parts) {\n    if (part === \".\") {\n      // @ts-expect-error todo(flow-ts): Can path be an array here?\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        // @ts-expect-error part may not index path\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n  return path;\n}\n\nexport function getAssignmentIdentifiers(this: NodePath) {\n  return _getAssignmentIdentifiers(this.node);\n}\n\nfunction getBindingIdentifiers(\n  duplicates: true,\n): Record<string, t.Identifier[]>;\nfunction getBindingIdentifiers(\n  duplicates?: false,\n): Record<string, t.Identifier>;\nfunction getBindingIdentifiers(\n  duplicates: boolean,\n): Record<string, t.Identifier[] | t.Identifier>;\n\nfunction getBindingIdentifiers(\n  this: NodePath,\n  duplicates?: boolean,\n): Record<string, t.Identifier[] | t.Identifier> {\n  return _getBindingIdentifiers(this.node, duplicates);\n}\n\nexport { getBindingIdentifiers };\n\nfunction getOuterBindingIdentifiers(\n  duplicates: true,\n): Record<string, t.Identifier[]>;\nfunction getOuterBindingIdentifiers(\n  duplicates?: false,\n): Record<string, t.Identifier>;\nfunction getOuterBindingIdentifiers(\n  duplicates: boolean,\n): Record<string, t.Identifier[] | t.Identifier>;\n\nfunction getOuterBindingIdentifiers(\n  this: NodePath,\n  duplicates?: boolean,\n): Record<string, t.Identifier[] | t.Identifier> {\n  return _getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nexport { getOuterBindingIdentifiers };\n\nfunction getBindingIdentifierPaths(\n  duplicates: true,\n  outerOnly?: boolean,\n): Record<string, NodePath<t.Identifier>[]>;\nfunction getBindingIdentifierPaths(\n  duplicates: false,\n  outerOnly?: boolean,\n): Record<string, NodePath<t.Identifier>>;\nfunction getBindingIdentifierPaths(\n  duplicates?: boolean,\n  outerOnly?: boolean,\n): Record<string, NodePath<t.Identifier> | NodePath<t.Identifier>[]>;\n\n// original source - https://github.com/babel/babel/blob/main/packages/babel-types/src/retrievers/getBindingIdentifiers.js\n// path.getBindingIdentifiers returns nodes where the following re-implementation returns paths\nfunction getBindingIdentifierPaths(\n  this: NodePath,\n  duplicates: boolean = false,\n  outerOnly: boolean = false,\n): Record<string, NodePath<t.Identifier> | NodePath<t.Identifier>[]> {\n  const path = this;\n  const search = [path];\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n\n    const keys = _getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = (ids[id.node.name] = ids[id.node.name] || []);\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n        if (Array.isArray(child)) {\n          search.push(...child);\n        } else if (child.node) {\n          search.push(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nexport { getBindingIdentifierPaths };\n\nfunction getOuterBindingIdentifierPaths(\n  duplicates: true,\n): Record<string, NodePath<t.Identifier>[]>;\nfunction getOuterBindingIdentifierPaths(\n  duplicates?: false,\n): Record<string, NodePath<t.Identifier>>;\nfunction getOuterBindingIdentifierPaths(\n  duplicates?: boolean,\n): Record<string, NodePath<t.Identifier> | NodePath<t.Identifier>[]>;\n\nfunction getOuterBindingIdentifierPaths(\n  this: NodePath,\n  duplicates: boolean = false,\n) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}\n\nexport { getOuterBindingIdentifierPaths };\n", "// This file contains methods responsible for dealing with comments.\nimport type * as t from \"@babel/types\";\nimport type NodePath from \"./index.ts\";\nimport {\n  addComment as _addComment,\n  addComments as _addComments,\n} from \"@babel/types\";\n\n/**\n * Share comments amongst siblings.\n */\n\nexport function shareCommentsWithSiblings(this: NodePath) {\n  // NOTE: this assumes numbered keys\n  if (typeof this.key === \"string\") return;\n\n  const node = this.node;\n  if (!node) return;\n\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev) {\n    if (leading) {\n      prev.addComments(\n        \"trailing\",\n        removeIfExisting(leading, prev.node.trailingComments),\n      );\n    }\n    if (trailing && !hasNext) prev.addComments(\"trailing\", trailing);\n  }\n  if (hasNext) {\n    if (trailing) {\n      next.addComments(\n        \"leading\",\n        removeIfExisting(trailing, next.node.leadingComments),\n      );\n    }\n    if (leading && !hasPrev) next.addComments(\"leading\", leading);\n  }\n}\n\nfunction removeIfExisting<T>(list: T[], toRemove?: T[]): T[] {\n  if (!toRemove?.length) return list;\n  const set = new Set(toRemove);\n  return list.filter(el => {\n    return !set.has(el);\n  });\n}\n\nexport function addComment(\n  this: NodePath,\n  type: t.CommentTypeShorthand,\n  content: string,\n  line?: boolean,\n) {\n  _addComment(this.node, type, content, line);\n}\n\n/**\n * Give node `comments` of the specified `type`.\n */\n\nexport function addComments(\n  this: NodePath,\n  type: t.CommentTypeShorthand,\n  comments: t.Comment[],\n) {\n  _addComments(this.node, type, comments);\n}\n", "import type { HubInterface } from \"../hub.ts\";\nimport type TraversalContext from \"../context.ts\";\nimport type { ExplodedTraverseOptions } from \"../index.ts\";\nimport * as virtualTypes from \"./lib/virtual-types.ts\";\nimport buildDebug from \"debug\";\nimport traverse from \"../index.ts\";\nimport type { Visitor } from \"../types.ts\";\nimport Scope from \"../scope/index.ts\";\nimport { validate } from \"@babel/types\";\nimport * as t from \"@babel/types\";\nimport * as cache from \"../cache.ts\";\nimport generator from \"@babel/generator\";\n\n// NodePath is split across many files.\nimport * as NodePath_ancestry from \"./ancestry.ts\";\nimport * as NodePath_inference from \"./inference/index.ts\";\nimport * as NodePath_replacement from \"./replacement.ts\";\nimport * as NodePath_evaluation from \"./evaluation.ts\";\nimport * as NodePath_conversion from \"./conversion.ts\";\nimport * as NodePath_introspection from \"./introspection.ts\";\nimport * as NodePath_context from \"./context.ts\";\nimport * as NodePath_removal from \"./removal.ts\";\nimport * as NodePath_modification from \"./modification.ts\";\nimport * as NodePath_family from \"./family.ts\";\nimport * as NodePath_comments from \"./comments.ts\";\nimport * as NodePath_virtual_types_validator from \"./lib/virtual-types-validator.ts\";\nimport type { NodePathAssertions } from \"./generated/asserts.ts\";\nimport type { NodePathValidators } from \"./generated/validators.ts\";\nimport { setup } from \"./context.ts\";\n\nconst debug = buildDebug(\"babel\");\n\nexport const REMOVED = 1 << 0;\nexport const SHOULD_STOP = 1 << 1;\nexport const SHOULD_SKIP = 1 << 2;\n\ndeclare const bit: import(\"../../../../scripts/babel-plugin-bit-decorator/types.d.ts\").BitDecorator<any>;\n\nconst NodePath_Final = class NodePath {\n  constructor(hub: HubInterface, parent: t.Node | null) {\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n\n    this.context = null;\n    this.scope = null;\n  }\n\n  declare parent: t.Node;\n  declare hub: HubInterface;\n  declare data: Record<string | symbol, unknown>;\n  // TraversalContext is configured by setContext\n  declare context: TraversalContext;\n  declare scope: Scope;\n\n  contexts: Array<TraversalContext> = [];\n  state: any = null;\n  opts: ExplodedTraverseOptions | null = null;\n\n  @bit.storage _traverseFlags: number;\n  @bit(REMOVED) accessor removed = false;\n  @bit(SHOULD_STOP) accessor shouldStop = false;\n  @bit(SHOULD_SKIP) accessor shouldSkip = false;\n\n  skipKeys: Record<string, boolean> | null = null;\n  parentPath: NodePath_Final = null;\n  container: t.Node | Array<t.Node> | null = null;\n  listKey: string | null = null;\n  key: string | number | null = null;\n  node: t.Node | null = null;\n  type: t.Node[\"type\"] | null = null;\n  _store: Map<t.Node, NodePath_Final> | null = null;\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key,\n  }: {\n    hub?: HubInterface;\n    parentPath: NodePath_Final | null;\n    parent: t.Node;\n    container: t.Node | t.Node[];\n    listKey?: string;\n    key: string | number;\n  }): NodePath_Final {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode =\n      // @ts-expect-error key must present in container\n      container[key];\n\n    const paths = cache.getOrCreateCachedPaths(parent, parentPath);\n\n    let path = paths.get(targetNode);\n    if (!path) {\n      path = new NodePath(hub, parent) as NodePath_Final;\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    setup.call(path, parentPath, container, listKey, key);\n\n    return path;\n  }\n\n  getScope(this: NodePath_Final, scope: Scope): Scope {\n    return this.isScope() ? new Scope(this) : scope;\n  }\n\n  setData(key: string | symbol, val: any): any {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n    return (this.data[key] = val);\n  }\n\n  getData(key: string | symbol, def?: any): any {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  hasNode(): boolean {\n    return this.node != null;\n  }\n\n  buildCodeFrameError(\n    msg: string,\n    Error: new () => Error = SyntaxError,\n  ): Error {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse<T>(this: NodePath_Final, visitor: Visitor<T>, state: T): void;\n  traverse(this: NodePath_Final, visitor: Visitor): void;\n  traverse(this: NodePath_Final, visitor: any, state?: any) {\n    traverse(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key: string, node: any) {\n    validate(this.node, key, node);\n    // @ts-expect-error key must present in this.node\n    this.node[key] = node;\n  }\n\n  getPathLocation(this: NodePath_Final): string {\n    const parts = [];\n    let path: NodePath_Final = this;\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while ((path = path.parentPath));\n    return parts.join(\".\");\n  }\n\n  debug(this: NodePath_Final, message: string) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return generator(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n    // ignore inList = true as it should depend on `listKey`\n  }\n\n  get parentKey(): string {\n    return (this.listKey || this.key) as string;\n  }\n};\n\nconst methods = {\n  // NodePath_ancestry\n  findParent: NodePath_ancestry.findParent,\n  find: NodePath_ancestry.find,\n  getFunctionParent: NodePath_ancestry.getFunctionParent,\n  getStatementParent: NodePath_ancestry.getStatementParent,\n  getEarliestCommonAncestorFrom:\n    NodePath_ancestry.getEarliestCommonAncestorFrom,\n  getDeepestCommonAncestorFrom: NodePath_ancestry.getDeepestCommonAncestorFrom,\n  getAncestry: NodePath_ancestry.getAncestry,\n  isAncestor: NodePath_ancestry.isAncestor,\n  isDescendant: NodePath_ancestry.isDescendant,\n  inType: NodePath_ancestry.inType,\n\n  // NodePath_inference\n  getTypeAnnotation: NodePath_inference.getTypeAnnotation,\n  isBaseType: NodePath_inference.isBaseType,\n  couldBeBaseType: NodePath_inference.couldBeBaseType,\n  baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,\n  isGenericType: NodePath_inference.isGenericType,\n\n  // NodePath_replacement\n  replaceWithMultiple: NodePath_replacement.replaceWithMultiple,\n  replaceWithSourceString: NodePath_replacement.replaceWithSourceString,\n  replaceWith: NodePath_replacement.replaceWith,\n  replaceExpressionWithStatements:\n    NodePath_replacement.replaceExpressionWithStatements,\n  replaceInline: NodePath_replacement.replaceInline,\n\n  // NodePath_evaluation\n  evaluateTruthy: NodePath_evaluation.evaluateTruthy,\n  evaluate: NodePath_evaluation.evaluate,\n\n  // NodePath_conversion\n  toComputedKey: NodePath_conversion.toComputedKey,\n  ensureBlock: NodePath_conversion.ensureBlock,\n  unwrapFunctionEnvironment: NodePath_conversion.unwrapFunctionEnvironment,\n  arrowFunctionToExpression: NodePath_conversion.arrowFunctionToExpression,\n  splitExportDeclaration: NodePath_conversion.splitExportDeclaration,\n  ensureFunctionName: NodePath_conversion.ensureFunctionName,\n\n  // NodePath_introspection\n  matchesPattern: NodePath_introspection.matchesPattern,\n  isStatic: NodePath_introspection.isStatic,\n  isNodeType: NodePath_introspection.isNodeType,\n  canHaveVariableDeclarationOrExpression:\n    NodePath_introspection.canHaveVariableDeclarationOrExpression,\n  canSwapBetweenExpressionAndStatement:\n    NodePath_introspection.canSwapBetweenExpressionAndStatement,\n  isCompletionRecord: NodePath_introspection.isCompletionRecord,\n  isStatementOrBlock: NodePath_introspection.isStatementOrBlock,\n  referencesImport: NodePath_introspection.referencesImport,\n  getSource: NodePath_introspection.getSource,\n  willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,\n  _guessExecutionStatusRelativeTo:\n    NodePath_introspection._guessExecutionStatusRelativeTo,\n  resolve: NodePath_introspection.resolve,\n  isConstantExpression: NodePath_introspection.isConstantExpression,\n  isInStrictMode: NodePath_introspection.isInStrictMode,\n\n  // NodePath_context\n  isDenylisted: NodePath_context.isDenylisted,\n  visit: NodePath_context.visit,\n  skip: NodePath_context.skip,\n  skipKey: NodePath_context.skipKey,\n  stop: NodePath_context.stop,\n  setContext: NodePath_context.setContext,\n  requeue: NodePath_context.requeue,\n  requeueComputedKeyAndDecorators:\n    NodePath_context.requeueComputedKeyAndDecorators,\n\n  // NodePath_removal\n  remove: NodePath_removal.remove,\n\n  // NodePath_modification\n  insertBefore: NodePath_modification.insertBefore,\n  insertAfter: NodePath_modification.insertAfter,\n  unshiftContainer: NodePath_modification.unshiftContainer,\n  pushContainer: NodePath_modification.pushContainer,\n\n  // NodePath_family\n  getOpposite: NodePath_family.getOpposite,\n  getCompletionRecords: NodePath_family.getCompletionRecords,\n  getSibling: NodePath_family.getSibling,\n  getPrevSibling: NodePath_family.getPrevSibling,\n  getNextSibling: NodePath_family.getNextSibling,\n  getAllNextSiblings: NodePath_family.getAllNextSiblings,\n  getAllPrevSiblings: NodePath_family.getAllPrevSiblings,\n  get: NodePath_family.get,\n  getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,\n  getBindingIdentifiers: NodePath_family.getBindingIdentifiers,\n  getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,\n  getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,\n  getOuterBindingIdentifierPaths:\n    NodePath_family.getOuterBindingIdentifierPaths,\n\n  // NodePath_comments\n  shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,\n  addComment: NodePath_comments.addComment,\n  addComments: NodePath_comments.addComments,\n};\n\nObject.assign(NodePath_Final.prototype, methods);\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  // String(x) is workaround for rollup\n\n  // @ts-expect-error babel 7 only\n  NodePath_Final.prototype.arrowFunctionToShadowed =\n    // @ts-expect-error babel 7 only\n    NodePath_conversion[String(\"arrowFunctionToShadowed\")];\n\n  Object.assign(NodePath_Final.prototype, {\n    // @ts-expect-error Babel 7 only\n    has: NodePath_introspection[String(\"has\")],\n    // @ts-expect-error Babel 7 only\n    is: NodePath_introspection[String(\"is\")],\n    // @ts-expect-error Babel 7 only\n    isnt: NodePath_introspection[String(\"isnt\")],\n    // @ts-expect-error Babel 7 only\n    equals: NodePath_introspection[String(\"equals\")],\n    // @ts-expect-error Babel 7 only\n    hoist: NodePath_modification[String(\"hoist\")],\n    updateSiblingKeys: NodePath_modification.updateSiblingKeys,\n    call: NodePath_context.call,\n    // @ts-expect-error Babel 7 only\n    isBlacklisted: NodePath_context[String(\"isBlacklisted\")],\n    setScope: NodePath_context.setScope,\n    resync: NodePath_context.resync,\n    popContext: NodePath_context.popContext,\n    pushContext: NodePath_context.pushContext,\n    setup: NodePath_context.setup,\n    setKey: NodePath_context.setKey,\n  });\n}\n\nif (!process.env.BABEL_8_BREAKING) {\n  // @ts-expect-error The original _guessExecutionStatusRelativeToDifferentFunctions only worked for paths in\n  // different functions, but _guessExecutionStatusRelativeTo works as a replacement in those cases.\n  NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions =\n    NodePath_introspection._guessExecutionStatusRelativeTo;\n\n  // @ts-expect-error The original _guessExecutionStatusRelativeToDifferentFunctions only worked for paths in\n  // different functions, but _guessExecutionStatusRelativeTo works as a replacement in those cases.\n  NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions =\n    NodePath_introspection._guessExecutionStatusRelativeTo;\n\n  Object.assign(NodePath_Final.prototype, {\n    // NodePath_inference\n    _getTypeAnnotation: NodePath_inference._getTypeAnnotation,\n\n    // NodePath_replacement\n    _replaceWith: NodePath_replacement._replaceWith,\n\n    // NodePath_introspection\n    _resolve: NodePath_introspection._resolve,\n\n    // NodePath_context\n    _call: NodePath_context._call,\n    _resyncParent: NodePath_context._resyncParent,\n    _resyncKey: NodePath_context._resyncKey,\n    _resyncList: NodePath_context._resyncList,\n    _resyncRemoved: NodePath_context._resyncRemoved,\n    _getQueueContexts: NodePath_context._getQueueContexts,\n\n    // NodePath_removal\n    _removeFromScope: NodePath_removal._removeFromScope,\n    _callRemovalHooks: NodePath_removal._callRemovalHooks,\n    _remove: NodePath_removal._remove,\n    _markRemoved: NodePath_removal._markRemoved,\n    _assertUnremoved: NodePath_removal._assertUnremoved,\n\n    // NodePath_modification\n    _containerInsert: NodePath_modification._containerInsert,\n    _containerInsertBefore: NodePath_modification._containerInsertBefore,\n    _containerInsertAfter: NodePath_modification._containerInsertAfter,\n    _verifyNodeList: NodePath_modification._verifyNodeList,\n\n    // NodePath_family\n    _getKey: NodePath_family._getKey,\n    _getPattern: NodePath_family._getPattern,\n  });\n}\n\n// we can not use `import { TYPES } from \"@babel/types\"` here\n// because the transformNamedBabelTypesImportToDestructuring plugin in babel.config.js\n// does not offer live bindings for `TYPES`\n// we can change to `import { TYPES }` when we are publishing ES modules only\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  // @ts-expect-error typeKey must present in t\n  const fn = t[typeKey];\n  // @ts-expect-error augmenting NodePath prototype\n  NodePath_Final.prototype[typeKey] = function (opts: any) {\n    return fn(this.node, opts);\n  };\n\n  // @ts-expect-error augmenting NodePath prototype\n  NodePath_Final.prototype[`assert${type}`] = function (opts: any) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\n// Register virtual types validators after base types validators\nObject.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);\n\nfor (const type of Object.keys(virtualTypes) as (keyof typeof virtualTypes)[]) {\n  if (type[0] === \"_\") continue;\n  if (!t.TYPES.includes(type)) t.TYPES.push(type);\n}\n\ninterface NodePathOverwrites {\n  // We need to re-define these predicate and assertion\n  // methods here, because we cannot refine `this` in\n  // a function declaration.\n  // See https://github.com/microsoft/TypeScript/issues/38150\n\n  /**\n   * NOTE: This assertion doesn't narrow the type on unions of\n   * NodePaths, due to https://github.com/microsoft/TypeScript/issues/44212\n   *\n   * @see ./conversion.ts for implementation.\n   */\n  ensureBlock(\n    this: NodePath_Final,\n  ): asserts this is NodePath_Final<\n    (\n      | t.Loop\n      | t.WithStatement\n      | t.Function\n      | t.LabeledStatement\n      | t.CatchClause\n    ) & { body: t.BlockStatement }\n  >;\n  /**\n   * @see ./introspection.ts for implementation.\n   */\n  isStatementOrBlock(\n    this: NodePath_Final,\n  ): this is NodePath_Final<t.Statement | t.Block>;\n}\n\ntype NodePathMixins = Omit<typeof methods, keyof NodePathOverwrites>;\n\ninterface NodePath<T extends t.Node>\n  extends InstanceType<typeof NodePath_Final>,\n    NodePathAssertions,\n    NodePathValidators,\n    NodePathMixins,\n    NodePathOverwrites {\n  type: T[\"type\"] | null;\n  node: T;\n  // .parent is only null for File nodes, which are not traversed by @babel/traverse\n  // You can technically create a path that contains one, but it's so rare that\n  // we can ignore it to avoid having non-null assertions everywhere.\n  parent: NonNullable<t.ParentMaps[T[\"type\"]]>;\n  parentPath: NodePath_Final<NonNullable<t.ParentMaps[T[\"type\"]]>>;\n}\n\n// This trick is necessary so that\n// NodePath_Final<A | B> is the same as NodePath_Final<A> | NodePath_Final<B>\ntype NodePath_Final<T extends t.Node = t.Node> = T extends any\n  ? NodePath<T>\n  : never;\n\nexport { NodePath_Final as default, type NodePath as NodePath_Internal };\n", "import NodePath from \"./path/index.ts\";\nimport { VISITOR_KEYS } from \"@babel/types\";\nimport type Scope from \"./scope/index.ts\";\nimport type { ExplodedTraverseOptions } from \"./index.ts\";\nimport type * as t from \"@babel/types\";\nimport type { Visitor } from \"./types.ts\";\nimport { popContext, pushContext, resync } from \"./path/context.ts\";\n\nexport default class TraversalContext<S = unknown> {\n  constructor(\n    scope: Scope,\n    opts: ExplodedTraverseOptions<S>,\n    state: S,\n    parentPath: NodePath,\n  ) {\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  declare parentPath: NodePath;\n  declare scope: Scope;\n  declare state: S;\n  declare opts: ExplodedTraverseOptions<S>;\n  queue: Array<NodePath> | null = null;\n  priorityQueue: Array<NodePath> | null = null;\n\n  /**\n   * This method does a simple check to determine whether or not we really need to attempt\n   * visit a node. This will prevent us from constructing a NodePath.\n   */\n\n  shouldVisit(node: t.Node): boolean {\n    const opts = this.opts as Visitor;\n    if (opts.enter || opts.exit) return true;\n\n    // check if we have a visitor for this node\n    if (opts[node.type]) return true;\n\n    // check if we're going to traverse into this node\n    const keys: Array<string> | undefined = VISITOR_KEYS[node.type];\n    if (!keys?.length) return false;\n\n    // we need to traverse into this node so ensure that it has children to traverse into!\n    for (const key of keys) {\n      if (\n        // @ts-expect-error key is from visitor keys\n        node[key]\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  create(\n    node: t.Node,\n    container: t.Node | t.Node[],\n    key: string | number,\n    listKey?: string,\n  ): NodePath {\n    // We don't need to `.setContext()` here, since `.visitQueue()` already\n    // calls `.pushContext`.\n    return NodePath.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container,\n      key: key,\n      listKey,\n    });\n  }\n\n  maybeQueue(path: NodePath, notPriority?: boolean) {\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container: t.Node[], parent: t.Node, listKey: string) {\n    // nothing to traverse!\n    if (container.length === 0) return false;\n\n    const queue = [];\n\n    // build up initial queue\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node: t.Node, key: string): boolean {\n    if (\n      this.shouldVisit(\n        // @ts-expect-error key may not index node\n        node[key],\n      )\n    ) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue: Array<NodePath>): boolean {\n    // set queue\n    this.queue = queue;\n    this.priorityQueue = [];\n\n    const visited = new WeakSet();\n    let stop = false;\n    let visitIndex = 0;\n\n    // visit the queue\n    for (; visitIndex < queue.length; ) {\n      const path = queue[visitIndex];\n      visitIndex++;\n      resync.call(path);\n\n      if (\n        path.contexts.length === 0 ||\n        path.contexts[path.contexts.length - 1] !== this\n      ) {\n        // The context might already have been pushed when this path was inserted and queued.\n        // If we always re-pushed here, we could get duplicates and risk leaving contexts\n        // on the stack after the traversal has completed, which could break things.\n        pushContext.call(path, this);\n      }\n\n      // this path no longer belongs to the tree\n      if (path.key === null) continue;\n\n      // ensure we don't visit the same node twice\n      const { node } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    // pop contexts\n    for (let i = 0; i < visitIndex; i++) {\n      popContext.call(queue[i]);\n    }\n\n    // clear queue\n    this.queue = null;\n\n    return stop;\n  }\n\n  visit(node: t.Node, key: string) {\n    // @ts-expect-error key may not index node\n    const nodes = node[key] as t.Node | t.Node[] | null;\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n}\n", "import TraversalContext from \"./context.ts\";\nimport type { ExplodedTraverseOptions } from \"./index.ts\";\nimport NodePath from \"./path/index.ts\";\nimport type Scope from \"./scope/index.ts\";\nimport type * as t from \"@babel/types\";\nimport { VISITOR_KEYS } from \"@babel/types\";\nimport { _call, popContext, pushContext, resync } from \"./path/context.ts\";\n\nfunction _visitPaths(ctx: TraversalContext, paths: NodePath[]): boolean {\n  // set queue\n  ctx.queue = paths;\n  ctx.priorityQueue = [];\n\n  const visited = new Set();\n  let stop = false;\n  let visitIndex = 0;\n\n  for (; visitIndex < paths.length; ) {\n    const path = paths[visitIndex];\n    visitIndex++;\n\n    resync.call(path);\n\n    if (\n      path.contexts.length === 0 ||\n      path.contexts[path.contexts.length - 1] !== ctx\n    ) {\n      // The context might already have been pushed when this path was inserted and queued.\n      // If we always re-pushed here, we could get duplicates and risk leaving contexts\n      // on the stack after the traversal has completed, which could break things.\n      pushContext.call(path, ctx);\n    }\n\n    // this path no longer belongs to the tree\n    if (path.key === null) continue;\n\n    // ensure we don't visit the same node twice\n    const { node } = path;\n    if (visited.has(node)) continue;\n    if (node) visited.add(node);\n\n    if (_visit(ctx, path)) {\n      stop = true;\n      break;\n    }\n\n    if (ctx.priorityQueue.length) {\n      stop = _visitPaths(ctx, ctx.priorityQueue);\n      ctx.priorityQueue = [];\n      ctx.queue = paths;\n      if (stop) break;\n    }\n  }\n\n  // pop contexts\n  for (let i = 0; i < visitIndex; i++) {\n    popContext.call(paths[i]);\n  }\n\n  // clear queue\n  ctx.queue = null;\n\n  return stop;\n}\n\nfunction _visit(ctx: TraversalContext, path: NodePath) {\n  const node = path.node;\n  if (!node) {\n    return false;\n  }\n  const opts = ctx.opts;\n\n  // @ts-expect-error TODO(Babel 8): Remove blacklist\n  const denylist = opts.denylist ?? opts.blacklist;\n  if (denylist?.includes(node.type)) {\n    return false;\n  }\n\n  if (opts.shouldSkip?.(path)) {\n    return false;\n  }\n\n  // Note: We need to check \"this.shouldSkip\" first because\n  // another visitor can set it to true. Usually .shouldSkip is false\n  // before calling the enter visitor, but it can be true in case of\n  // a requeued node (e.g. by .replaceWith()) that is then marked\n  // with .skip().\n  if (path.shouldSkip) return path.shouldStop;\n\n  if (_call.call(path, opts.enter)) return path.shouldStop;\n  if (path.node) {\n    if (_call.call(path, opts[node.type]?.enter)) return path.shouldStop;\n  }\n\n  path.shouldStop = _traverse(\n    path.node,\n    opts,\n    path.scope,\n    ctx.state,\n    path,\n    path.skipKeys,\n  );\n\n  if (path.node) {\n    if (_call.call(path, opts.exit)) return true;\n  }\n  if (path.node) {\n    _call.call(path, opts[node.type]?.exit);\n  }\n\n  return path.shouldStop;\n}\n\nfunction _traverse<S>(\n  node: t.Node,\n  opts: ExplodedTraverseOptions<S>,\n  scope?: Scope,\n  state?: S,\n  path?: NodePath,\n  skipKeys?: Record<string, boolean>,\n  visitSelf?: boolean,\n) {\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys?.length) return false;\n\n  const ctx = new TraversalContext(scope, opts, state, path);\n  if (visitSelf) {\n    if (skipKeys?.[path.parentKey]) return false;\n    return _visitPaths(ctx, [path]);\n  }\n\n  for (const key of keys) {\n    if (skipKeys?.[key]) continue;\n    // @ts-expect-error key must present in node\n    const prop = node[key];\n    if (!prop) continue;\n\n    if (Array.isArray(prop)) {\n      if (!prop.length) continue;\n      const paths = [];\n      for (let i = 0; i < prop.length; i++) {\n        const childPath = NodePath.get({\n          parentPath: path,\n          parent: node,\n          container: prop,\n          key: i,\n          listKey: key,\n        });\n        paths.push(childPath);\n      }\n      if (_visitPaths(ctx, paths)) return true;\n    } else {\n      if (\n        _visitPaths(ctx, [\n          NodePath.get({\n            parentPath: path,\n            parent: node,\n            container: node,\n            key,\n            listKey: null,\n          }),\n        ])\n      ) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Traverse the children of given node\n * @param {Node} node\n * @param {TraverseOptions} opts The traverse options used to create a new traversal context\n * @param {scope} scope A traversal scope used to create a new traversal context. When opts.noScope is true, scope should not be provided\n * @param {any} state A user data storage provided as the second callback argument for traversal visitors\n * @param {NodePath} path A NodePath of given node\n * @param {Record<string, boolean>} skipKeys A map from key names to whether that should be skipped during traversal. The skipKeys are applied to every descendants\n * @returns {boolean} Whether the traversal stops early\n\n * @note This function does not visit the given `node`.\n */\nexport function traverseNode<S = unknown>(\n  node: t.Node,\n  opts: ExplodedTraverseOptions<S>,\n  scope?: Scope,\n  state?: S,\n  path?: NodePath,\n  skipKeys?: Record<string, boolean>,\n  visitSelf?: boolean,\n): boolean {\n  if (process.env.BABEL_8_BREAKING) {\n    return _traverse(node, opts, scope, state, path, skipKeys, visitSelf);\n  }\n\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return false;\n\n  const context = new TraversalContext<S>(scope, opts, state, path);\n  if (visitSelf) {\n    if (skipKeys?.[path.parentKey]) return false;\n    return context.visitQueue([path]);\n  }\n\n  for (const key of keys) {\n    if (skipKeys?.[key]) continue;\n    if (context.visit(node, key)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n", "// This file contains methods responsible for maintaining a TraversalContext.\n\nimport { traverseNode } from \"../traverse-node.ts\";\nimport { SHOULD_SKIP, SHOULD_STOP } from \"./index.ts\";\nimport { _markRemoved } from \"./removal.ts\";\nimport type TraversalContext from \"../context.ts\";\nimport type { VisitPhase } from \"../types.ts\";\nimport type NodePath from \"./index.ts\";\nimport * as t from \"@babel/types\";\n\nexport function call(this: NodePath, key: VisitPhase): boolean {\n  const opts = this.opts;\n\n  this.debug(key);\n\n  if (this.node) {\n    if (_call.call(this, opts[key])) return true;\n  }\n\n  if (this.node) {\n    return _call.call(this, opts[this.node.type]?.[key]);\n  }\n\n  return false;\n}\n\nexport function _call(this: NodePath, fns?: Array<Function>): boolean {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n\n    const node = this.node;\n    if (!node) return true;\n\n    const ret = fn.call(this.state, this, this.state);\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(\n        `You appear to be using a plugin with an async traversal visitor, ` +\n          `which your current version of Babel does not support. ` +\n          `If you're using a published plugin, you may need to upgrade ` +\n          `your @babel/core version.`,\n      );\n    }\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    // node has been replaced, it will have been requeued\n    if (this.node !== node) return true;\n\n    // this.shouldSkip || this.shouldStop || this.removed\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nexport function isDenylisted(this: NodePath): boolean {\n  // @ts-expect-error TODO(Babel 8): Remove blacklist\n  const denylist = this.opts.denylist ?? this.opts.blacklist;\n  return denylist?.includes(this.node.type);\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.isBlacklisted = isDenylisted;\n}\n\nfunction restoreContext(path: NodePath, context: TraversalContext) {\n  if (path.context !== context) {\n    path.context = context;\n    path.state = context.state;\n    path.opts = context.opts;\n  }\n}\n\nexport function visit(this: NodePath): boolean {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip?.(this)) {\n    return false;\n  }\n\n  const currentContext = this.context;\n  // Note: We need to check \"this.shouldSkip\" first because\n  // another visitor can set it to true. Usually .shouldSkip is false\n  // before calling the enter visitor, but it can be true in case of\n  // a requeued node (e.g. by .replaceWith()) that is then marked\n  // with .skip().\n  if (this.shouldSkip || call.call(this, \"enter\")) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n  restoreContext(this, currentContext);\n\n  this.debug(\"Recursing into...\");\n  this.shouldStop = traverseNode(\n    this.node,\n    this.opts,\n    this.scope,\n    this.state,\n    this,\n    this.skipKeys,\n  );\n\n  restoreContext(this, currentContext);\n\n  call.call(this, \"exit\");\n\n  return this.shouldStop;\n}\n\nexport function skip(this: NodePath) {\n  this.shouldSkip = true;\n}\n\nexport function skipKey(this: NodePath, key: string) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n  this.skipKeys[key] = true;\n}\n\nexport function stop(this: NodePath) {\n  // this.shouldSkip = true; this.shouldStop = true;\n  this._traverseFlags |= SHOULD_SKIP | SHOULD_STOP;\n}\n\nexport function setScope(this: NodePath) {\n  if (this.opts?.noScope) return;\n\n  let path = this.parentPath;\n\n  if (\n    // Skip method scope if is computed method key or decorator expression\n    ((this.key === \"key\" || this.listKey === \"decorators\") &&\n      path.isMethod()) ||\n    // Skip switch scope if for discriminant (`x` in `switch (x) {}`).\n    (this.key === \"discriminant\" && path.isSwitchStatement())\n  ) {\n    path = path.parentPath;\n  }\n\n  let target;\n  while (path && !target) {\n    if (path.opts?.noScope) return;\n\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  this.scope?.init();\n}\n\nexport function setContext<S = unknown>(\n  this: NodePath,\n  context?: TraversalContext<S>,\n) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n  // this.shouldSkip = false; this.shouldStop = false; this.removed = false;\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    // Discard the S type parameter from context.opts\n    this.opts = context.opts as typeof this.opts;\n  }\n\n  setScope.call(this);\n\n  return this;\n}\n\n/**\n * Here we resync the node paths `key` and `container`. If they've changed according\n * to what we have stored internally then we attempt to resync by crawling and looking\n * for the new values.\n */\n\nexport function resync(this: NodePath) {\n  if (this.removed) return;\n\n  _resyncParent.call(this);\n  _resyncList.call(this);\n  _resyncKey.call(this);\n  //this._resyncRemoved();\n}\n\nexport function _resyncParent(this: NodePath) {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nexport function _resyncKey(this: NodePath) {\n  if (!this.container) return;\n\n  if (\n    this.node ===\n    // @ts-expect-error this.key should present in this.container\n    this.container[this.key]\n  ) {\n    return;\n  }\n\n  // grrr, path key is out of sync. this is likely due to a modification to the AST\n  // not done through our path APIs\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        setKey.call(this, i);\n        return;\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      // @ts-expect-error this.key should present in this.container\n      if (this.container[key] === this.node) {\n        setKey.call(this, key);\n        return;\n      }\n    }\n  }\n\n  // ¯\\_(ツ)_/¯ who knows where it's gone lol\n  this.key = null;\n}\n\nexport function _resyncList(this: NodePath) {\n  if (!this.parent || !this.inList) return;\n\n  const newContainer =\n    // @ts-expect-error this.listKey should present in this.parent\n    this.parent[this.listKey];\n  if (this.container === newContainer) return;\n\n  // container is out of sync. this is likely the result of it being reassigned\n  this.container = newContainer || null;\n}\n\nexport function _resyncRemoved(this: NodePath) {\n  if (\n    this.key == null ||\n    !this.container ||\n    // @ts-expect-error this.key should present in this.container\n    this.container[this.key] !== this.node\n  ) {\n    _markRemoved.call(this);\n  }\n}\n\nexport function popContext(this: NodePath) {\n  this.contexts.pop();\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nexport function pushContext(this: NodePath, context: TraversalContext) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nexport function setup(\n  this: NodePath,\n  parentPath: NodePath | undefined,\n  container: t.Node | t.Node[],\n  listKey: string,\n  key: string | number,\n) {\n  this.listKey = listKey;\n  this.container = container;\n\n  this.parentPath = parentPath || this.parentPath;\n  setKey.call(this, key);\n}\n\nexport function setKey(this: NodePath, key: string | number) {\n  this.key = key;\n  this.node =\n    // @ts-expect-error this.key must present in this.container\n    this.container[this.key];\n  this.type = this.node?.type;\n}\n\nexport function requeue(this: NodePath, pathToQueue = this) {\n  if (pathToQueue.removed) return;\n\n  // If a path is skipped, and then replaced with a\n  // new one, the new one shouldn't probably be skipped.\n  if (process.env.BABEL_8_BREAKING) {\n    pathToQueue.shouldSkip = false;\n  }\n\n  // TODO(loganfsmyth): This should be switched back to queue in parent contexts\n  // automatically once #2892 and #4135 have been resolved. See #4140.\n  // let contexts = this._getQueueContexts();\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nexport function requeueComputedKeyAndDecorators(\n  this: NodePath<t.Method | t.Property>,\n) {\n  const { context, node } = this;\n  if (!t.isPrivate(node) && node.computed) {\n    context.maybeQueue(this.get(\"key\"));\n  }\n  if (node.decorators) {\n    for (const decorator of this.get(\"decorators\")) {\n      context.maybeQueue(decorator);\n    }\n  }\n}\n\nexport function _getQueueContexts(this: NodePath) {\n  let path = this;\n  let contexts = this.contexts;\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n  return contexts;\n}\n", "import type Scope from \"./scope/index.ts\";\nimport type { Node } from \"@babel/types\";\n\nexport interface HubInterface {\n  getCode(): string | void;\n  getScope(): Scope | void;\n  addHelper(name: string): any;\n  buildError(node: Node, msg: string, Error: new (msg: string) => Error): Error;\n}\n\nexport default class Hub implements HubInterface {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(\n    node: Node,\n    msg: string,\n    Error: new (msg: string) => Error = TypeError,\n  ): Error {\n    return new Error(msg);\n  }\n}\n", "import \"./path/context.ts\"; // We have some cycles, this ensures correct order to avoid TDZ\nimport * as visitors from \"./visitors.ts\";\nimport {\n  VISITOR_KEYS,\n  removeProperties,\n  type RemovePropertiesOptions,\n  traverseFast,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport * as cache from \"./cache.ts\";\nimport type NodePath from \"./path/index.ts\";\nimport type { default as Scope, Binding } from \"./scope/index.ts\";\nimport type { ExplodedVisitor, Visitor, VisitorBase } from \"./types.ts\";\nimport { traverseNode } from \"./traverse-node.ts\";\n\nexport type { ExplodedVisitor, Visitor, VisitorBase, Binding };\nexport { default as NodePath } from \"./path/index.ts\";\nexport { default as Scope } from \"./scope/index.ts\";\nexport { default as Hub } from \"./hub.ts\";\nexport type { HubInterface } from \"./hub.ts\";\n\nexport { visitors };\n\nexport type TraverseOptions<S = t.Node> = {\n  scope?: Scope;\n  noScope?: boolean;\n  denylist?: string[];\n  shouldSkip?: (node: NodePath) => boolean;\n} & Visitor<S>;\n\nexport type ExplodedTraverseOptions<S = t.Node> = TraverseOptions<S> &\n  ExplodedVisitor<S>;\n\nfunction traverse<S>(\n  parent: t.Node,\n  opts: TraverseOptions<S>,\n  scope: Scope | undefined,\n  state: S,\n  parentPath?: NodePath,\n  visitSelf?: boolean,\n): void;\n\nfunction traverse(\n  parent: t.Node,\n  opts: TraverseOptions,\n  scope?: Scope,\n  state?: any,\n  parentPath?: NodePath,\n  visitSelf?: boolean,\n): void;\n\nfunction traverse<Options extends TraverseOptions>(\n  parent: t.Node,\n  // @ts-expect-error provide {} as default value for Options\n  opts: Options = {},\n  scope?: Scope,\n  state?: any,\n  parentPath?: NodePath,\n  visitSelf?: boolean,\n) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\n        \"You must pass a scope and parentPath unless traversing a Program/File. \" +\n          `Instead of that you tried to traverse a ${parent.type} node without ` +\n          \"passing scope and parentPath.\",\n      );\n    }\n  }\n\n  if (!parentPath && visitSelf) {\n    throw new Error(\"visitSelf can only be used when providing a NodePath.\");\n  }\n\n  if (!VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts as Visitor);\n\n  traverseNode(\n    parent,\n    opts as ExplodedVisitor,\n    scope,\n    state,\n    parentPath,\n    /* skipKeys */ null,\n    visitSelf,\n  );\n}\n\nexport default traverse;\n\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node: t.Node, enter: (node: t.Node) => void) {\n  traverseFast(node, enter);\n  return;\n};\n\ntraverse.node = function (\n  node: t.Node,\n  opts: ExplodedTraverseOptions,\n  scope?: Scope,\n  state?: any,\n  path?: NodePath,\n  skipKeys?: Record<string, boolean>,\n) {\n  traverseNode(node, opts, scope, state, path, skipKeys);\n  // traverse.node always returns undefined\n};\n\ntraverse.clearNode = function (node: t.Node, opts?: RemovePropertiesOptions) {\n  removeProperties(node, opts);\n};\n\ntraverse.removeProperties = function (\n  tree: t.Node,\n  opts?: RemovePropertiesOptions,\n) {\n  traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\ntraverse.hasType = function (\n  tree: t.Node,\n  type: t.Node[\"type\"],\n  denylistTypes?: Array<string>,\n): boolean {\n  // the node we're searching in is denylisted\n  if (denylistTypes?.includes(tree.type)) return false;\n\n  // the type we're looking for is the same as the passed node\n  if (tree.type === type) return true;\n\n  return traverseFast(tree, function (node) {\n    if (denylistTypes?.includes(node.type)) {\n      return traverseFast.skip;\n    }\n    if (node.type === type) {\n      return traverseFast.stop;\n    }\n  });\n};\n\ntraverse.cache = cache;\n"],
  "mappings": "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",
  "names": ["ReferencedIdentifier", "exports", "ReferencedMemberExpression", "BindingIdentifier", "Statement", "Expression", "Scope", "Referenced", "BlockScoped", "Var", "User", "Generated", "Pure", "Flow", "RestProperty", "SpreadProperty", "ExistentialTypeParam", "NumericLiteralTypeAnnotation", "ForAwaitStatement", "self", "_t", "require", "isBinding", "isBlockScoped", "nodeIsBlockScoped", "isExportDeclaration", "isExpression", "nodeIsExpression", "isFlow", "nodeIsFlow", "isForStatement", "isForXStatement", "isIdentifier", "isImportDeclaration", "isImportSpecifier", "isJSXIdentifier", "isJSXMemberExpression", "isMemberExpression", "isRestElement", "nodeIsRestElement", "isReferenced", "nodeIsReferenced", "isScope", "nodeIsScope", "isStatement", "nodeIsStatement", "isVar", "nodeIsVar", "isVariableDeclaration", "react", "isForOfStatement", "isCompatTag", "isReferencedIdentifier", "opts", "node", "parent", "name", "parentPath", "isReferencedMemberExpression", "isBindingIdentifier", "grandparent", "left", "init", "isUser", "loc", "isGenerated", "isPure", "constantsOnly", "scope", "importKind", "exportKind", "isRestProperty", "_this$parentPath", "isObjectPattern", "isSpreadProperty", "_this$parentPath2", "isObjectExpression", "isForAwaitStatement", "await", "exports", "isExistentialTypeParam", "Error", "isNumericLiteralTypeAnnotation", "virtualTypes", "require", "virtualTypesValidators", "_t", "_context", "DEPRECATED_KEYS", "DEPRECATED_ALIASES", "FLIPPED_ALIAS_KEYS", "TYPES", "__internal__deprecationWarning", "deprecationWarning", "isVirtualType", "type", "isExplodedVisitor", "visitor", "_exploded", "explode$1", "nodeType", "Object", "keys", "shouldIgnoreKey", "parts", "split", "length", "fns", "part", "verify$1", "__esModule", "ensureEntranceObjects", "ensureCallbackArrays", "wrapCheck", "types", "mergePair", "aliases", "deprecatedKey", "deprecatedAlias", "alias", "existing", "assign", "_verified", "Error", "validateVisitorMethods", "includes", "visitors", "visitorKey", "path", "val", "concat", "fn", "TypeError", "merge", "states", "wrapper", "mergedVisitor", "defineProperty", "enumerable", "i", "state", "topVisitor", "wrapWithStateOrWrapper", "key", "typeVisitor", "nodeVisitor", "oldVisitor", "newVisitor", "phase", "Array", "isArray", "map", "newFn", "call", "toString", "obj", "enter", "exit", "fnKey", "validator", "apply", "arguments", "dest", "src", "_environmentVisitor", "FunctionParent", "isArrowFunctionExpression", "skip", "isMethod", "requeueComputedKeyAndDecorators", "Property", "isObjectProperty", "environmentVisitor", "t", "require", "_t", "_traverseNode", "_visitors", "_context", "getAssignmentIdentifiers", "renameVisitor", "ReferencedIdentifier", "node", "state", "name", "oldName", "newName", "Scope", "path", "scope", "bindingIdentifierEquals", "binding", "identifier", "skip", "isMethod", "requeueComputedKeyAndDecorators", "call", "ObjectProperty", "key", "shorthand", "getBindingIdentifier", "_node$extra", "extra", "isVariableDeclaration", "ids", "isAssignmentExpression", "getOuterBindingIdentifiers", "Renamer", "constructor", "maybeConvertFromExportDeclaration", "parentDeclar", "maybeExportDeclar", "parentPath", "isExportDeclaration", "isExportDefaultDeclaration", "declaration", "isDeclaration", "id", "isExportAllDeclaration", "splitExportDeclaration", "maybeConvertFromClassFunctionDeclaration", "maybeConvertFromClassFunctionExpression", "rename", "find", "isFunctionExpression", "isClassExpression", "bindingIds", "blockToTraverse", "arguments", "block", "skipKeys", "discriminant", "computed", "isObjectMethod", "decorators", "traverseNode", "explode", "removeOwnBinding", "bindings", "exports", "default", "Binding", "constructor", "identifier", "scope", "path", "kind", "constantViolations", "constant", "referencePaths", "referenced", "references", "isInitInLoop", "reassign", "clearValue", "deoptValue", "hasDeoptedValue", "setValue", "value", "hasValue", "includes", "push", "reference", "dereference", "exports", "default", "isFunctionDeclarationOrHasInit", "isVariableDeclarator", "node", "init", "parentPath", "key", "isFunctionParent", "isForXStatement", "isLoop", "pathsCache", "exports", "path", "WeakMap", "scope", "clear", "clearPath", "clearScope", "getCachedPaths", "parent", "parentPath", "get", "getOrCreateCachedPaths", "node", "paths", "set", "Map", "_renamer", "require", "_index", "_binding", "_t", "t", "_cache", "globalsBuiltinLower", "globalsBuiltinUpper", "assignmentExpression", "callExpression", "cloneNode", "getBindingIdentifiers", "identifier", "isArrayExpression", "isBinary", "isCallExpression", "isClass", "isClassBody", "isClassDeclaration", "isExportAllDeclaration", "isExportDefaultDeclaration", "isExportNamedDeclaration", "isFunctionDeclaration", "isIdentifier", "isImportDeclaration", "isLiteral", "isMemberExpression", "isMethod", "isModuleSpecifier", "isNullLiteral", "isObjectExpression", "isProperty", "isPureish", "isRegExpLiteral", "isSuper", "isTaggedTemplateExpression", "isTemplateLiteral", "isThisExpression", "isUnaryExpression", "isVariableDeclaration", "expressionStatement", "matchesPattern", "memberExpression", "numericLiteral", "toIdentifier", "variableDeclaration", "variableDeclarator", "isRecordExpression", "isTupleExpression", "isObjectProperty", "isTopicReference", "isMetaProperty", "isPrivateName", "isExportDeclaration", "buildUndefinedNode", "sequenceExpression", "gatherNodeParts", "node", "parts", "type", "_node$specifiers", "source", "specifiers", "length", "e", "declaration", "local", "push", "value", "object", "property", "name", "callee", "properties", "argument", "key", "left", "id", "expression", "meta", "openingElement", "openingFragment", "namespace", "resetScope", "scope", "references", "Object", "create", "uids", "bindings", "globals", "NOT_LOCAL_BINDING", "Symbol", "for", "collectorVisitor", "ForStatement", "path", "declar", "get", "isVar", "parentScope", "getFunctionParent", "getProgramParent", "registerBinding", "Declaration", "isBlockScoped", "parent", "registerDeclaration", "ImportDeclaration", "getBlockParent", "TSImportEqualsDeclaration", "ReferencedIdentifier", "state", "isTSQualifiedName", "right", "parentPath", "isTSImportEqualsDeclaration", "ForXStatement", "isPattern", "constantViolations", "ExportDeclaration", "exit", "binding", "getBinding", "reference", "decl", "declarations", "keys", "LabeledStatement", "AssignmentExpression", "assignments", "UpdateExpression", "UnaryExpression", "operator", "BlockScoped", "CatchClause", "Function", "params", "param", "isFunctionExpression", "ClassExpression", "TSTypeAnnotation", "skip", "scopeVisitor", "uid", "Scope", "constructor", "block", "inited", "labels", "referencesSet", "uidsSet", "data", "crawling", "cached", "scopeCache", "set", "Map", "defineProperties", "enumerable", "configurable", "writable", "_parent", "_path", "shouldSkip", "listKey", "isScope", "Error", "generateDeclaredUidIdentifier", "generateUidIdentifier", "generateUid", "replace", "i", "hasLabel", "hasBinding", "hasGlobal", "hasReference", "program", "generateUidBasedOnNode", "defaultName", "join", "slice", "generateUidIdentifierBasedOnNode", "isStatic", "constant", "maybeGenerateMemoised", "dontPush", "checkBlockScopedCollisions", "kind", "duplicate", "hub", "buildError", "TypeError", "rename", "oldName", "newName", "renamer", "Renamer", "arguments", "dump", "sep", "repeat", "console", "log", "violations", "getLabel", "registerLabel", "label", "isLabeledStatement", "declare", "isTypeDeclaration", "importKind", "specifier", "isTypeSpecifier", "isImportSpecifier", "registerConstantViolation", "ids", "getAssignmentIdentifiers", "_this$getBinding", "reassign", "bindingPath", "ReferenceError", "declarators", "getOuterBindingIdentifiers", "getOwnBinding", "Binding", "addGlobal", "hasUid", "isPure", "constantsOnly", "_node$decorators", "superClass", "decorators", "body", "method", "elem", "elements", "prop", "_node$decorators2", "computed", "_node$decorators3", "static", "expressions", "tag", "noGlobals", "quasi", "isStringLiteral", "setData", "val", "getData", "removeData", "init", "crawl", "isProgram", "programParent", "traverse", "visitors", "merge", "visit", "enter", "call", "typeVisitors", "ref", "opts", "getPatternParent", "isBlockStatement", "isSwitchStatement", "unique", "isFunction", "pushContainer", "isLoop", "isCatchClause", "ensureBlock", "blockHoist", "_blockHoist", "dataKey", "declarPath", "unshiftContainer", "declarator", "len", "isFunctionParent", "isBlockParent", "getAllBindings", "bindingIdentifierEquals", "getBindingIdentifier", "previousPath", "_previousPath", "isArrowFunctionExpression", "_this$getBinding2", "getOwnBindingIdentifier", "hasOwnBinding", "noUids", "upToScope", "includes", "contextVariables", "parentHasBinding", "_this$parent", "moveBindingTo", "info", "removeOwnBinding", "removeBinding", "_this$getBinding3", "hoistVariables", "emit", "seen", "Set", "isVariableDeclarator", "has", "add", "firstId", "isFor", "replaceWith", "remove", "expr", "isForStatement", "exports", "default", "prototype", "_renameFromMap", "map", "_generateUid", "toArray", "arrayLikeIsIterable", "isGenericType", "helperName", "args", "unshift", "addHelper", "getAllBindingsOfKind", "kinds", "parentBlock", "module", "url", "__commonJS", "exports", "module", "resolveUri", "sourceIndex", "__commonJS", "exports", "module", "cast", "_genMapping", "require", "_traceMapping", "SourceMap", "constructor", "opts", "code", "_opts$sourceFileName", "_map", "_rawMappings", "_sourceFileName", "_lastGenLine", "_lastSourceLine", "_lastSourceColumn", "_inputMap", "map", "GenMapping", "sourceRoot", "sourceFileName", "replace", "undefined", "inputSourceMap", "TraceMap", "resolvedSources", "length", "i", "_this$_inputMap$sourc", "setSourceContent", "sourcesContent", "Object", "keys", "get", "toEncodedMap", "getDecoded", "toDecodedMap", "getRawMappings", "allMappings", "mark", "generated", "line", "column", "identifierName", "identifierNamePos", "filename", "_originalMapping", "originalMapping", "originalPositionFor", "name", "originalIdentifierMapping", "source", "maybeAddMapping", "original", "exports", "default", "Buffer", "constructor", "map", "indentChar", "_map", "_buf", "_str", "_appendCount", "_last", "_queue", "_queueCursor", "_canMarkIdName", "_indentChar", "_fastIndentations", "_position", "line", "column", "_sourcePosition", "identifierName", "undefined", "identifierNamePos", "filename", "i", "push", "repeat", "_allocQueue", "queue", "char", "_pushQueue", "cursor", "length", "item", "_popQueue", "Error", "get", "_flush", "result", "code", "trimRight", "decodedMap", "getDecoded", "__mergedMap", "resultMap", "value", "Object", "defineProperty", "writable", "rawMappings", "mappings", "getRawMappings", "append", "str", "maybeNewline", "_append", "appendChar", "_appendChar", "sourcePosition", "queueIndentation", "queueCursor", "sourcePos", "fastIndentation", "String", "fromCharCode", "_mark", "len", "position", "charCodeAt", "indexOf", "last", "_this$_map", "mark", "removeTrailingNewline", "removeLastSemicolon", "getLastChar", "getNewlineCount", "count", "endsWithCharAndNewline", "lastCp", "hasContent", "exactSource", "loc", "cb", "source", "prop", "_normalizePosition", "sourceWithOffset", "columnOffset", "pos", "target", "Math", "max", "getCurrentColumn", "lastIndex", "getCurrentLine", "exports", "default", "_t", "require", "FLIPPED_ALIAS_KEYS", "isArrayExpression", "isAssignmentExpression", "isBinary", "isBlockStatement", "isCallExpression", "isFunction", "isIdentifier", "isLiteral", "isMemberExpression", "isObjectExpression", "isOptionalCallExpression", "isOptionalMemberExpression", "isStringLiteral", "crawlInternal", "node", "state", "object", "computed", "property", "left", "right", "hasCall", "callee", "hasFunction", "hasHelper", "isHelper", "crawl", "name", "charCodeAt", "isType", "nodes", "exports", "AssignmentExpression", "SwitchCase", "parent", "consequent", "length", "cases", "LogicalExpression", "Literal", "value", "CallExpression", "OptionalCallExpression", "VariableDeclaration", "i", "declarations", "declar", "enabled", "id", "init", "IfStatement", "ObjectProperty", "ObjectTypeProperty", "ObjectMethod", "properties", "ObjectTypeCallProperty", "_parent$properties", "callProperties", "ObjectTypeIndexer", "_parent$properties2", "_parent$callPropertie", "indexers", "ObjectTypeInternalSlot", "_parent$properties3", "_parent$callPropertie2", "_parent$indexers", "internalSlots", "forEach", "type", "amounts", "concat", "ret", "_t", "require", "_index", "isArrayTypeAnnotation", "isBinaryExpression", "isCallExpression", "isForOfStatement", "isIndexedAccessType", "isMemberExpression", "isObjectPattern", "isOptionalMemberExpression", "isYieldExpression", "isStatement", "PRECEDENCE", "Map", "getBinaryPrecedence", "node", "nodeType", "get", "operator", "isTSTypeExpression", "isClassExtendsClause", "parent", "parentType", "type", "superClass", "hasPostfixPart", "object", "callee", "tag", "NullableTypeAnnotation", "FunctionTypeAnnotation", "tokenContext", "Boolean", "TokenContext", "arrowFlowReturnType", "UpdateExpression", "needsParenBeforeExpressionBrace", "expressionStatement", "arrowBody", "ObjectExpression", "DoExpression", "async", "Binary", "left", "parentPos", "nodePos", "right", "undefined", "UnionTypeAnnotation", "OptionalIndexedAccessType", "objectType", "TSAsExpression", "TSConditionalType", "types", "checkType", "extendsType", "TSUnionType", "TSIntersectionType", "TSInferType", "typeParameter", "constraint", "TSTypeOperator", "TSInstantiationExpression", "typeParameters", "TSFunctionType", "BinaryExpression", "forInOrInitHeadAccumulate", "SequenceExpression", "property", "YieldExpression", "test", "ClassExpression", "exportDefault", "UnaryLike", "FunctionExpression", "ConditionalExpression", "OptionalMemberExpression", "AssignmentExpression", "LogicalExpression", "Identifier", "getRawIdentifier", "_node$extra", "extra", "parenthesized", "rightType", "id", "name", "isFollowedByBracket", "computed", "optional", "forInitHead", "forInHead", "forOfHead", "await", "whitespace", "require", "parens", "_t", "FLIPPED_ALIAS_KEYS", "VISITOR_KEYS", "isCallExpression", "isDecorator", "isExpressionStatement", "isMemberExpression", "isNewExpression", "isParenthesizedExpression", "TokenContext", "exports", "normal", "expressionStatement", "arrowBody", "exportDefault", "arrowFlowReturnType", "forInitHead", "forInHead", "forOfHead", "forInOrInitHeadAccumulate", "forInOrInitHeadAccumulatePassThroughMask", "expandAliases", "obj", "map", "Map", "add", "type", "func", "fn", "get", "set", "node", "parent", "stack", "getRawIdentifier", "_fn", "Object", "keys", "aliases", "alias", "expandedParens", "expandedWhitespaceNodes", "nodes", "isOrHasCallExpression", "object", "needsWhitespace", "_expandedWhitespaceNo", "expression", "flag", "needsWhitespaceBefore", "needsWhitespaceAfter", "needsParens", "tokenContext", "_expandedParens$get", "callee", "isDecoratorMemberExpression", "computed", "property", "isLastChild", "child", "visitorKeys", "i", "length", "val", "Array", "isArray", "j", "_t", "require", "traverseFast", "VISITOR_KEYS", "TokenMap", "constructor", "ast", "tokens", "source", "_tokens", "_source", "_nodesToTokenIndexes", "Map", "_nodesOccurrencesCountCache", "_tokensCache", "node", "indexes", "_getTokensIndexesOfNode", "length", "set", "has", "getIndexes", "get", "find", "condition", "k", "index", "tok", "findLastIndex", "findMatching", "test", "occurrenceCount", "i", "count", "cache", "matchesOriginal", "token", "end", "start", "value", "startsWith", "startMatches", "endMatches", "first", "last", "_findTokensOfNode", "low", "children", "childrenIterator", "type", "declaration", "next", "child", "childTok", "high", "push", "cached", "_findFirstTokenOfNode", "_findLastTokenOfNode", "mid", "exports", "quasis", "expressions", "keys", "key", "Array", "isArray", "TaggedTemplateExpression", "node", "print", "tag", "typeParameters", "quasi", "TemplateElement", "Error", "_printTemplate", "substitutions", "quasis", "partRaw", "i", "length", "value", "raw", "token", "tokenMap", "findMatching", "_catchUpTo", "loc", "start", "TemplateLiteral", "expressions", "_t", "require", "_index", "isCallExpression", "isLiteral", "isMemberExpression", "isNewExpression", "isPattern", "UnaryExpression", "node", "operator", "word", "space", "token", "print", "argument", "DoExpression", "async", "body", "ParenthesizedExpression", "exit", "enterDelimited", "expression", "rightParens", "UpdateExpression", "prefix", "ConditionalExpression", "test", "consequent", "alternate", "NewExpression", "parent", "callee", "format", "minified", "arguments", "length", "optional", "typeArguments", "typeParameters", "tokenMap", "endMatches", "printList", "shouldPrintTrailingComma", "SequenceExpression", "expressions", "ThisExpression", "Super", "_shouldPrintDecoratorsBeforeExport", "decoratorsBeforeExport", "start", "declaration", "Decorator", "newline", "OptionalMemberExpression", "computed", "property", "object", "TypeError", "value", "OptionalCallExpression", "CallExpression", "Import", "AwaitExpression", "YieldExpression", "delegate", "EmptyStatement", "semicolon", "ExpressionStatement", "tokenContext", "TokenContext", "expressionStatement", "AssignmentPattern", "left", "type", "typeAnnotation", "right", "AssignmentExpression", "_endsWithDiv", "BindExpression", "MemberExpression", "MetaProperty", "meta", "PrivateName", "id", "V8IntrinsicIdentifier", "name", "ModuleExpression", "indent", "directives", "dedent", "rightBrace", "_t", "require", "isFor", "isForStatement", "isIfStatement", "isStatement", "WithStatement", "node", "word", "space", "token", "print", "object", "printBlock", "IfStatement", "test", "needsBlock", "alternate", "getLastStatement", "consequent", "newline", "indent", "printAndIndentOnComments", "dedent", "endsWith", "statement", "body", "ForStatement", "exit", "enterForStatementInit", "init", "update", "WhileStatement", "ForXStatement", "isForOf", "type", "await", "noIndentInnerCommentsHere", "enterForXStatementInit", "left", "right", "ForInStatement", "exports", "ForOfStatement", "DoWhileStatement", "semicolon", "printStatementAfterKeyword", "printer", "printTerminatorless", "BreakStatement", "label", "ContinueStatement", "ReturnStatement", "argument", "ThrowStatement", "LabeledStatement", "TryStatement", "block", "handlers", "handler", "finalizer", "CatchClause", "param", "typeAnnotation", "SwitchStatement", "discriminant", "printSequence", "cases", "undefined", "addNewlines", "leading", "cas", "length", "rightBrace", "SwitchCase", "DebuggerStatement", "VariableDeclaration", "parent", "declare", "kind", "hasInits", "declar", "declarations", "printList", "occurrenceCount", "VariableDeclarator", "id", "definite", "_t", "require", "isExportDefaultDeclaration", "isExportNamedDeclaration", "ClassDeclaration", "node", "parent", "inExport", "_shouldPrintDecoratorsBeforeExport", "printJoin", "decorators", "declare", "word", "space", "abstract", "id", "print", "typeParameters", "superClass", "superTypeParameters", "implements", "printList", "body", "ClassBody", "token", "length", "newline", "separator", "classBodyEmptySemicolonsPrinter", "exit", "enterDelimited", "endsWith", "rightBrace", "printer", "tokenMap", "start", "end", "indexes", "getIndexes", "k", "occurrenceCount", "nextLocIndex", "advanceNextLocIndex", "i", "tok", "matchesOriginal", "_tokens", "undefined", "ClassProperty", "static", "format", "preserveFormat", "_node$key$loc", "endLine", "key", "loc", "line", "catchUp", "tsPrintClassMemberModifiers", "computed", "_variance", "optional", "definite", "typeAnnotation", "value", "semicolon", "ClassAccessorProperty", "_node$key$loc2", "ClassPrivateProperty", "ClassMethod", "_classMethodHead", "ClassPrivateMethod", "_node$key$loc3", "_methodHead", "StaticBlock", "printSequence", "_t", "require", "_index", "isIdentifier", "_params", "node", "idNode", "parentNode", "print", "typeParameters", "nameInfo", "_getFuncIdName", "call", "sourceIdentifierName", "name", "pos", "token", "_parameters", "params", "noLineTerminator", "type", "returnType", "_noLineTerminator", "parameters", "endToken", "exit", "enterDelimited", "trailingComma", "shouldPrintTrailingComma", "paramLength", "length", "i", "_param", "space", "parameter", "printJoin", "decorators", "optional", "typeAnnotation", "_methodHead", "kind", "key", "word", "async", "generator", "computed", "undefined", "_predicate", "noLineTerminatorAfter", "predicate", "_functionHead", "parent", "format", "preserveFormat", "_endsWithInnerRaw", "id", "FunctionExpression", "body", "ArrowFunctionExpression", "_shouldPrintArrowParamsParens", "printInnerComments", "tokenContext", "TokenContext", "arrowBody", "_firstParam$leadingCo", "_firstParam$trailingC", "firstParam", "leadingComments", "trailingComments", "tokenMap", "loc", "findMatching", "arrowToken", "start", "line", "retainLines", "parentType", "left", "_id$loc", "_id$loc2", "identifierName", "_id$loc3", "_id$loc4", "value", "_t", "require", "_index", "isClassDeclaration", "isExportDefaultSpecifier", "isExportNamespaceSpecifier", "isImportDefaultSpecifier", "isImportNamespaceSpecifier", "isStatement", "ImportSpecifier", "node", "importKind", "word", "space", "print", "imported", "local", "name", "ImportDefaultSpecifier", "ExportDefaultSpecifier", "exported", "ExportSpecifier", "exportKind", "ExportNamespaceSpecifier", "token", "warningShown", "_printAttributes", "hasPreviousBrace", "_node$extra", "importAttributesKeyword", "format", "attributes", "assertions", "extra", "deprecatedAssertSyntax", "deprecatedWithLegacySyntax", "console", "warn", "useAssertKeyword", "printList", "occurrenceCount", "shouldPrintTrailingComma", "ExportAllDeclaration", "_node$attributes", "_node$assertions", "length", "source", "semicolon", "maybePrintDecoratorsBeforeExport", "printer", "declaration", "_shouldPrintDecoratorsBeforeExport", "printJoin", "decorators", "ExportNamedDeclaration", "declar", "specifiers", "slice", "hasSpecial", "first", "shift", "hasBrace", "_node$attributes2", "_node$assertions2", "ExportDefaultDeclaration", "noIndentInnerCommentsHere", "tokenContext", "TokenContext", "exportDefault", "ImportDeclaration", "_node$attributes3", "_node$assertions3", "isTypeKind", "module", "phase", "hasSpecifiers", "ImportAttribute", "key", "value", "ImportNamespaceSpecifier", "ImportExpression", "options", "rightParens", "hasOwnProperty", "object", "hexadecimal", "result", "hex", "_t", "require", "_jsesc", "isAssignmentPattern", "isIdentifier", "lastRawIdentNode", "lastRawIdentResult", "_getRawIdentifier", "node", "name", "token", "tokenMap", "find", "tok", "value", "_originalCode", "slice", "start", "end", "Identifier", "_node$loc", "sourceIdentifierName", "loc", "identifierName", "word", "ArgumentPlaceholder", "RestElement", "print", "argument", "ObjectExpression", "props", "properties", "length", "exit", "enterDelimited", "space", "printList", "shouldPrintTrailingComma", "sourceWithOffset", "ObjectMethod", "printJoin", "decorators", "_methodHead", "body", "ObjectProperty", "computed", "key", "left", "shorthand", "ArrayExpression", "elems", "elements", "len", "i", "elem", "RecordExpression", "startToken", "endToken", "format", "recordAndTupleSyntaxType", "Error", "JSON", "stringify", "TupleExpression", "RegExpLiteral", "pattern", "flags", "BooleanLiteral", "NullLiteral", "NumericLiteral", "raw", "getPossibleRaw", "opts", "jsescOption", "str", "numbers", "number", "jsesc", "minified", "StringLiteral", "undefined", "val", "BigIntLiteral", "validTopicTokenSet", "Set", "TopicReference", "topicToken", "has", "givenTopicTokenJSON", "validTopics", "Array", "from", "v", "join", "PipelineTopicExpression", "expression", "PipelineBareFunction", "callee", "PipelinePrimaryTopicReference", "VoidPattern", "_t", "require", "_modules", "_index", "_types2", "isDeclareExportDeclaration", "isStatement", "AnyTypeAnnotation", "word", "ArrayTypeAnnotation", "node", "print", "elementType", "token", "BooleanTypeAnnotation", "BooleanLiteralTypeAnnotation", "value", "NullLiteralTypeAnnotation", "DeclareClass", "parent", "space", "_interfaceish", "DeclareFunction", "id", "typeAnnotation", "predicate", "semicolon", "InferredPredicate", "DeclaredPredicate", "DeclareInterface", "InterfaceDeclaration", "DeclareModule", "body", "DeclareModuleExports", "DeclareTypeAlias", "TypeAlias", "DeclareOpaqueType", "OpaqueType", "DeclareVariable", "DeclareExportDeclaration", "default", "FlowExportDeclaration", "call", "DeclareExportAllDeclaration", "ExportAllDeclaration", "EnumDeclaration", "enumExplicitType", "context", "name", "hasExplicitType", "enumBody", "members", "indent", "newline", "member", "hasUnknownMembers", "dedent", "EnumBooleanBody", "explicitType", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody", "EnumDefaultedMember", "enumInitializedMember", "init", "EnumBooleanMember", "EnumNumberMember", "EnumStringMember", "declaration", "declar", "specifiers", "length", "printList", "source", "ExistsTypeAnnotation", "FunctionTypeAnnotation", "typeParameters", "this", "params", "rest", "type", "method", "returnType", "FunctionTypeParam", "optional", "InterfaceExtends", "_node$extends", "extends", "_node$mixins", "_node$implements", "mixins", "implements", "_variance", "_node$variance", "kind", "variance", "andSeparator", "occurrenceCount", "InterfaceTypeAnnotation", "_node$extends2", "IntersectionTypeAnnotation", "printJoin", "types", "undefined", "MixedTypeAnnotation", "EmptyTypeAnnotation", "NullableTypeAnnotation", "NumberTypeAnnotation", "StringTypeAnnotation", "ThisTypeAnnotation", "TupleTypeAnnotation", "TypeofTypeAnnotation", "argument", "right", "TypeAnnotation", "tokenContext", "TokenContext", "arrowFlowReturnType", "TypeParameterInstantiation", "TypeParameter", "bound", "supertype", "impltype", "ObjectTypeAnnotation", "exact", "props", "properties", "callProperties", "indexers", "internalSlots", "addNewlines", "leading", "inexact", "ObjectTypeInternalSlot", "static", "ObjectTypeCallProperty", "ObjectTypeIndexer", "key", "ObjectTypeProperty", "proto", "ObjectTypeSpreadProperty", "QualifiedTypeIdentifier", "qualification", "SymbolTypeAnnotation", "orSeparator", "UnionTypeAnnotation", "TypeCastExpression", "expression", "Variance", "VoidTypeAnnotation", "IndexedAccessType", "objectType", "indexType", "OptionalIndexedAccessType", "File", "node", "program", "print", "interpreter", "Program", "_node$directives", "noIndentInnerCommentsHere", "printInnerComments", "directivesLen", "directives", "length", "_node$directives$trai", "newline", "body", "printSequence", "undefined", "trailingComments", "BlockStatement", "_node$directives2", "token", "exit", "enterDelimited", "_node$directives$trai2", "rightBrace", "Directive", "value", "semicolon", "unescapedSingleQuoteRE", "unescapedDoubleQuoteRE", "DirectiveLiteral", "raw", "getPossibleRaw", "format", "minified", "test", "Error", "InterpreterDirective", "Placeholder", "name", "expectedNode", "JSXAttribute", "node", "print", "name", "value", "token", "JSXIdentifier", "word", "JSXNamespacedName", "namespace", "JSXMemberExpression", "object", "property", "JSXSpreadAttribute", "argument", "rightBrace", "JSXExpressionContainer", "expression", "JSXSpreadChild", "JSXText", "raw", "getPossibleRaw", "undefined", "JSXElement", "open", "openingElement", "selfClosing", "indent", "child", "children", "dedent", "closingElement", "spaceSeparator", "space", "JSXOpeningElement", "typeArguments", "typeParameters", "attributes", "length", "printJoin", "JSXClosingElement", "JSXEmptyExpression", "printInnerComments", "JSXFragment", "openingFragment", "closingFragment", "JSXOpeningFragment", "JSXClosingFragment", "TSTypeAnnotation", "node", "parent", "token", "type", "typeAnnotation", "space", "optional", "print", "TSTypeParameterInstantiation", "printTrailingSeparator", "params", "length", "tokenMap", "start", "end", "find", "t", "matchesOriginal", "shouldPrintTrailingComma", "printList", "TSTypeParameter", "const", "word", "in", "out", "name", "constraint", "default", "TSParameterProperty", "accessibility", "readonly", "_param", "parameter", "TSDeclareFunction", "declare", "_functionHead", "semicolon", "TSDeclareMethod", "_classMethodHead", "TSQualifiedName", "left", "right", "TSCallSignatureDeclaration", "tsPrintSignatureDeclarationBase", "maybePrintTrailingCommaOrSemicolon", "printer", "endMatches", "TSConstructSignatureDeclaration", "TSPropertySignature", "tsPrintPropertyOrMethodName", "computed", "key", "TSMethodSignature", "kind", "TSIndexSignature", "static", "isStatic", "_parameters", "parameters", "TSAnyKeyword", "TSBigIntKeyword", "TSUnknownKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSBooleanKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSVoidKeyword", "TSUndefinedKeyword", "TSNullKeyword", "TSNeverKeyword", "TSIntrinsicKeyword", "TSThisType", "TSFunctionType", "tsPrintFunctionOrConstructorType", "TSConstructorType", "abstract", "typeParameters", "returnType", "TSTypeReference", "typeArguments", "typeName", "TSTypePredicate", "asserts", "parameterName", "TSTypeQuery", "exprName", "TSTypeLiteral", "printBraced", "printJoin", "members", "TSArrayType", "elementType", "TSTupleType", "elementTypes", "TSOptionalType", "TSRestType", "TSNamedTupleMember", "label", "TSUnionType", "tsPrintUnionOrIntersectionType", "TSIntersectionType", "sep", "_printer$tokenMap", "hasLeadingToken", "startMatches", "types", "undefined", "i", "TSConditionalType", "checkType", "extendsType", "trueType", "falseType", "TSInferType", "typeParameter", "TSParenthesizedType", "TSTypeOperator", "operator", "TSIndexedAccessType", "objectType", "indexType", "TSMappedType", "nameType", "exit", "enterDelimited", "tokenIfPlusMinus", "self", "tok", "TSTemplateLiteralType", "_printTemplate", "TSLiteralType", "literal", "TSClassImplements", "expression", "TSInterfaceDeclaration", "id", "extends", "extendz", "body", "TSInterfaceBody", "TSTypeAliasDeclaration", "TSTypeExpression", "TSTypeAssertion", "TSInstantiationExpression", "TSEnumDeclaration", "isConst", "TSEnumBody", "call", "_this$shouldPrintTrai", "TSEnumMember", "initializer", "TSModuleDeclaration", "global", "TSModuleBlock", "printSequence", "TSImportType", "argument", "qualifier", "options", "TSImportEqualsDeclaration", "moduleReference", "isExport", "TSExternalModuleReference", "TSNonNullExpression", "TSExportAssignment", "TSNamespaceExportDeclaration", "tsPrintClassMemberModifiers", "isPrivateField", "isPublicField", "printModifiersList", "override", "cb", "rightBrace", "modifiers", "_printer$tokenMap2", "modifiersSet", "Set", "modifier", "add", "has", "value", "delete", "size", "_templateLiterals", "require", "Object", "keys", "forEach", "key", "exports", "defineProperty", "enumerable", "get", "_expressions", "_statements", "_classes", "_methods", "_modules", "_types", "_flow", "_base", "_jsx", "_typescript", "addDeprecatedGenerators", "PrinterClass", "deprecatedBabel7Generators", "Noop", "TSExpressionWithTypeArguments", "node", "print", "expression", "typeParameters", "DecimalLiteral", "raw", "getPossibleRaw", "format", "minified", "undefined", "word", "value", "Object", "assign", "prototype", "_buffer", "require", "_index", "n", "_t", "_tokenMap", "generatorFunctions", "_deprecated", "isExpression", "isFunction", "isStatement", "isClassBody", "isTSInterfaceBody", "isTSEnumMember", "SCIENTIFIC_NOTATION", "ZERO_DECIMAL_INTEGER", "HAS_NEWLINE", "HAS_NEWLINE_OR_BlOCK_COMMENT_END", "commentIsNewline", "c", "type", "test", "value", "needsParens", "Printer", "constructor", "format", "map", "tokens", "originalCode", "tokenContext", "TokenContext", "normal", "_tokens", "_originalCode", "_currentNode", "_indent", "_indentRepeat", "_insideAux", "_noLineTerminator", "_noLineTerminatorAfterNode", "_printAuxAfterOnNextUserNode", "_printedComments", "Set", "_endsWithInteger", "_endsWithWord", "_endsWithDiv", "_lastCommentLine", "_endsWithInnerRaw", "_indentInnerComments", "tokenMap", "_boundGetRawIdentifier", "_getRawIdentifier", "bind", "_printSemicolonBeforeNextNode", "_printSemicolonBeforeNextToken", "indent", "style", "length", "_inputMap", "_buf", "Buffer", "enterForStatementInit", "forInitHead", "forInOrInitHeadAccumulate", "enterForXStatementInit", "isForOf", "forOfHead", "forInHead", "enterDelimited", "oldTokenContext", "oldNoLineTerminatorAfterNode", "generate", "ast", "preserveFormat", "TokenMap", "print", "_maybeAddAuxComment", "get", "compact", "concise", "dedent", "semicolon", "force", "_appendChar", "node", "start", "end", "endMatches", "getCurrentLine", "indexes", "getIndexes", "_catchUpTo", "loc", "_queue", "rightBrace", "minified", "removeLastSemicolon", "sourceWithOffset", "token", "rightParens", "space", "_space", "hasContent", "lastCp", "getLastChar", "word", "str", "noLineTerminatorAfter", "forInOrInitHeadAccumulatePassThroughMask", "_maybePrintInnerComments", "_catchUpToCurrentToken", "charCodeAt", "_append", "number", "isNonDecimalLiteral", "secondChar", "Number", "isInteger", "maybeNewline", "occurrenceCount", "lastChar", "strFirst", "tokenChar", "char", "String", "fromCharCode", "newline", "i", "retainLines", "getNewlineCount", "j", "_newline", "endsWith", "endsWithCharAndNewline", "removeTrailingNewline", "exactSource", "cb", "_catchUp", "source", "prop", "columnOffset", "sourceIdentifierName", "identifierName", "pos", "_canMarkIdName", "sourcePosition", "_sourcePosition", "identifierNamePos", "findMatching", "appendChar", "_maybeIndent", "append", "queue", "firstChar", "queueIndentation", "_getIndent", "_shouldIndent", "catchUp", "line", "count", "column", "index", "spacesCount", "getCurrentColumn", "spaces", "slice", "replace", "repeat", "printTerminatorless", "trailingCommentsLineOffset", "_node$extra", "_node$leadingComments", "_node$leadingComments2", "nodeType", "oldConcise", "_compact", "printMethod", "undefined", "ReferenceError", "JSON", "stringify", "name", "parent", "oldInAux", "parenthesized", "extra", "shouldPrintParens", "retainFunctionParens", "leadingComments", "parentType", "callee", "indentParenthesized", "some", "isLastChild", "_node$trailingComment", "trailingComments", "_printLeadingComments", "_printTrailingComments", "enteredPositionlessNode", "_printAuxBeforeComment", "_printAuxAfterComment", "comment", "auxiliaryCommentBefore", "_printComment", "auxiliaryCommentAfter", "getPossibleRaw", "raw", "rawValue", "printJoin", "nodes", "statement", "separator", "printTrailingSeparator", "addNewlines", "iterator", "_nodes$0$loc", "startLine", "newlineOpts", "nextNodeStartLine", "boundSeparator", "len", "_printNewline", "_node$trailingComment2", "_nextNode$loc", "nextNode", "printAndIndentOnComments", "printBlock", "body", "lineOffset", "innerComments", "_printComments", "comments", "nextTokenStr", "nextTokenOccurrenceCount", "_this$tokenMap", "printInnerComments", "nextToken", "hasSpace", "printedCommentsCount", "size", "noIndentInnerCommentsHere", "printSequence", "printList", "items", "commaSeparator", "shouldPrintTrailingComma", "listEnd", "listEndIndex", "findLastIndex", "matchesOriginal", "newLine", "opts", "lastCommentLine", "offset", "_shouldPrintComment", "ignore", "has", "commentTok", "find", "add", "shouldPrintComment", "skipNewLines", "noLineTerminator", "isBlockComment", "printNewLines", "lastCharCode", "val", "adjustMultilineComment", "_comment$loc", "newlineRegex", "RegExp", "indentSize", "nodeLoc", "hasLoc", "nodeStartLine", "nodeEndLine", "lastLine", "leadingCommentNewline", "shouldPrint", "commentStartLine", "commentEndLine", "Math", "max", "min", "singleLine", "shouldSkipNewline", "properties", "Object", "assign", "prototype", "addDeprecatedGenerators", "_default", "exports", "default", "last", "_sourceMap", "require", "_printer", "normalizeOptions", "code", "opts", "ast", "experimental_preserveFormat", "Error", "retainLines", "compact", "minified", "jsescOption", "Array", "isArray", "tokens", "format", "auxiliaryCommentBefore", "auxiliaryCommentAfter", "shouldPrintComment", "preserveFormat", "retainFunctionParens", "comments", "concise", "indent", "adjustMultilineComment", "style", "Object", "assign", "quotes", "wrap", "minimal", "topicToken", "importAttributesKeyword", "_opts$recordAndTupleS", "decoratorsBeforeExport", "json", "jsonCompatibleStrings", "recordAndTupleSyntaxType", "value", "includes", "length", "console", "error", "filename", "undefined", "exports", "CodeGenerator", "constructor", "_ast", "_format", "_map", "sourceMaps", "SourceMap", "generate", "printer", "Printer", "map", "_default", "default", "_t", "require", "VISITOR_KEYS", "findParent", "callback", "path", "parentPath", "find", "getFunctionParent", "p", "isFunction", "getStatementParent", "Array", "isArray", "container", "isStatement", "isProgram", "isFile", "Error", "getEarliestCommonAncestorFrom", "paths", "getDeepestCommonAncestorFrom", "deepest", "i", "ancestries", "earliest", "keys", "type", "ancestry", "listKey", "key", "earliestKeyIndex", "indexOf", "parentKey", "currentKeyIndex", "filter", "length", "minDepth", "Infinity", "lastCommonIndex", "lastCommon", "map", "unshift", "first", "depthLoop", "shouldMatch", "getAncestry", "push", "isAncestor", "maybeDescendant", "isDescendant", "maybeAncestor", "parent", "inType", "candidateTypes", "includes", "node", "_t", "require", "createFlowUnionType", "createTSUnionType", "createUnionTypeAnnotation", "isFlowType", "isTSType", "createUnionType", "types", "every", "v", "_t", "require", "_util", "BOOLEAN_NUMBER_BINARY_OPERATORS", "createTypeAnnotationBasedOnTypeof", "numberTypeAnnotation", "voidTypeAnnotation", "_default", "node", "isReferenced", "binding", "scope", "getBinding", "name", "identifier", "typeAnnotation", "getTypeAnnotationBindingConstantViolations", "path", "types", "functionConstantViolations", "constantViolations", "getConstantViolationsBefore", "testType", "getConditionalAnnotation", "testConstantViolations", "ifStatement", "filter", "includes", "push", "length", "violation", "getTypeAnnotation", "createUnionType", "functions", "violations", "slice", "unshift", "resolve", "status", "_guessExecutionStatusRelativeTo", "inferAnnotationFromBinaryExpression", "operator", "right", "get", "left", "target", "isIdentifier", "typeofPath", "typePath", "isUnaryExpression", "isLiteral", "typeValue", "value", "getParentConditionalPath", "parentPath", "isIfStatement", "isConditionalExpression", "key", "isFunction", "test", "paths", "i", "isLogicalExpression", "isBinaryExpression", "type", "_t", "require", "_infererReference", "_util", "BOOLEAN_BINARY_OPERATORS", "BOOLEAN_UNARY_OPERATORS", "NUMBER_BINARY_OPERATORS", "NUMBER_UNARY_OPERATORS", "STRING_UNARY_OPERATORS", "anyTypeAnnotation", "arrayTypeAnnotation", "booleanTypeAnnotation", "buildMatchMemberExpression", "genericTypeAnnotation", "identifier", "nullLiteralTypeAnnotation", "numberTypeAnnotation", "stringTypeAnnotation", "tupleTypeAnnotation", "unionTypeAnnotation", "voidTypeAnnotation", "isIdentifier", "VariableDeclarator", "get", "getTypeAnnotation", "TypeCastExpression", "node", "typeAnnotation", "validParent", "TSAsExpression", "TSNonNullExpression", "NewExpression", "callee", "type", "TemplateLiteral", "UnaryExpression", "operator", "includes", "BinaryExpression", "right", "left", "isBaseType", "LogicalExpression", "argumentTypes", "createUnionType", "ConditionalExpression", "SequenceExpression", "pop", "ParenthesizedExpression", "AssignmentExpression", "UpdateExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "RegExpLiteral", "ObjectExpression", "ArrayExpression", "RestElement", "Func", "isArrayFrom", "isObjectKeys", "isObjectValues", "isObjectEntries", "CallExpression", "name", "resolveCall", "TaggedTemplateExpression", "resolve", "isFunction", "async", "generator", "returnType", "inferers", "require", "_t", "anyTypeAnnotation", "isAnyTypeAnnotation", "isArrayTypeAnnotation", "isBooleanTypeAnnotation", "isEmptyTypeAnnotation", "isFlowBaseAnnotation", "isGenericTypeAnnotation", "isIdentifier", "isMixedTypeAnnotation", "isNumberTypeAnnotation", "isStringTypeAnnotation", "isTSArrayType", "isTSTypeAnnotation", "isTSTypeReference", "isTupleTypeAnnotation", "isTypeAnnotation", "isUnionTypeAnnotation", "isVoidTypeAnnotation", "stringTypeAnnotation", "voidTypeAnnotation", "getTypeAnnotation", "type", "getData", "_getTypeAnnotation", "call", "typeAnnotation", "setData", "typeAnnotationInferringNodes", "WeakSet", "node", "key", "parentPath", "isVariableDeclarator", "declar", "declarParent", "isForInStatement", "isForOfStatement", "has", "add", "_inferer", "inferer", "validParent", "delete", "isBaseType", "baseName", "soft", "_isBaseType", "Error", "couldBeBaseType", "name", "type2", "types", "baseTypeStrictlyMatches", "rightArg", "left", "right", "isGenericType", "genericName", "id", "typeName", "isColorSupported", "process", "env", "FORCE_COLOR", "picocolors", "compose", "f", "g", "v", "buildDefs", "colors", "keyword", "cyan", "capitalized", "yellow", "jsxIdentifier", "punctuator", "number", "magenta", "string", "green", "regex", "comment", "gray", "invalid", "white", "bgRed", "bold", "gutter", "marker", "red", "message", "reset", "defsOn", "createColors", "defsOff", "getDefs", "enabled", "sometimesKeywords", "Set", "NEWLINE", "BRACKET", "tokenize", "JSX_TAG", "getTokenType", "token", "offset", "text", "type", "isKeyword", "value", "isStrictReservedWord", "has", "test", "slice", "toLowerCase", "match", "jsTokens", "default", "exec", "matchToToken", "index", "highlight", "defs", "highlighted", "split", "map", "str", "join", "deprecationWarningShown", "getMarkerLines", "loc", "source", "opts", "startLoc", "Object", "assign", "column", "line", "start", "endLoc", "end", "linesAbove", "linesBelow", "startLine", "startColumn", "endLine", "endColumn", "Math", "max", "min", "length", "lineDiff", "markerLines", "i", "lineNumber", "sourceLength", "codeFrameColumns", "rawLines", "shouldHighlight", "forceColor", "highlightCode", "lines", "hasColumns", "numberMaxWidth", "String", "highlightedLines", "frame", "paddedNumber", "hasMarker", "lastMarkerLine", "markerLine", "Array", "isArray", "markerSpacing", "replace", "numberOfMarkers", "repeat", "colNumber", "emitWarning", "deprecationError", "Error", "name", "console", "warn", "location", "hooks", "exports", "self", "parent", "removeParent", "key", "isWhile", "isSwitchCase", "isExportDeclaration", "isLabeledStatement", "listKey", "isVariableDeclaration", "node", "declarations", "length", "isExpressionStatement", "remove", "isSequenceExpression", "expressions", "replaceWith", "isBinary", "right", "left", "isIfStatement", "isLoop", "isArrowFunctionExpression", "type", "body", "_removalHooks", "require", "_cache", "_replacement", "_index", "_t", "_modification", "_context", "getBindingIdentifiers", "remove", "_this$opts", "_assertUnremoved", "call", "resync", "_callRemovalHooks", "_markRemoved", "opts", "noScope", "_removeFromScope", "shareCommentsWithSiblings", "_remove", "bindings", "node", "Object", "keys", "forEach", "name", "scope", "removeBinding", "parentPath", "fn", "hooks", "Array", "isArray", "container", "splice", "key", "updateSiblingKeys", "_replaceWith", "_traverseFlags", "SHOULD_SKIP", "REMOVED", "parent", "_getCachedPaths", "getCachedPaths", "delete", "removed", "buildCodeFrameError", "_t", "require", "_t2", "react", "cloneNode", "jsxExpressionContainer", "variableDeclaration", "variableDeclarator", "referenceVisitor", "ReferencedIdentifier", "path", "state", "isJSXIdentifier", "isCompatTag", "node", "name", "parentPath", "isJSXMemberExpression", "scope", "isFunction", "isArrowFunctionExpression", "parent", "breakOnScopePaths", "push", "binding", "getBinding", "violation", "constantViolations", "mutableBinding", "stop", "bindings", "PathHoister", "constructor", "scopes", "attachAfter", "isCompatibleScope", "key", "Object", "keys", "bindingIdentifierEquals", "identifier", "getCompatibleScopes", "includes", "getAttachmentPath", "_getAttachmentPath", "targetScope", "isProgram", "hasOwnBinding", "kind", "parentKey", "bindingParentPath", "getAttachmentParentForPath", "violationPath", "pop", "hasOwnParamBindings", "bodies", "get", "i", "length", "_blockHoist", "getNextScopeAttachmentParent", "Array", "isArray", "container", "isStatement", "constant", "run", "traverse", "attachTo", "getFunctionParent", "uid", "generateUidIdentifier", "declarator", "insertFn", "attached", "isVariableDeclarator", "isJSXElement", "children", "replaceWith", "exports", "default", "_cache", "require", "_index", "_context", "_removal", "_t", "_hoister", "arrowFunctionExpression", "assertExpression", "assignmentExpression", "blockStatement", "callExpression", "cloneNode", "expressionStatement", "isAssignmentExpression", "isCallExpression", "isExportNamedDeclaration", "isExpression", "isIdentifier", "isSequenceExpression", "isSuper", "thisExpression", "insertBefore", "nodes_", "_assertUnremoved", "call", "nodes", "_verifyNodeList", "parentPath", "parent", "isExpressionStatement", "isLabeledStatement", "isExportDefaultDeclaration", "isDeclaration", "isNodeType", "isJSXElement", "isForStatement", "key", "node", "push", "replaceExpressionWithStatements", "Array", "isArray", "container", "_containerInsertBefore", "isStatementOrBlock", "shouldInsertCurrentNode", "expression", "replaceWith", "unshiftContainer", "Error", "_containerInsert", "from", "updateSiblingKeys", "length", "paths", "splice", "i", "_this$context", "to", "path", "getSibling", "context", "queue", "pushContext", "contexts", "_getQueueContexts", "setScope", "debug", "maybeQueue", "_containerInsertAfter", "last", "arr", "isHiddenInSequenceExpression", "expressions", "isAlmostConstantAssignment", "scope", "left", "blockScope", "getBlockParent", "hasOwnBinding", "name", "getOwnBinding", "constantViolations", "insertAfter", "get", "map", "self", "isPattern", "unshift", "callee", "isPure", "isMethod", "computed", "temp", "generateDeclaredUidIdentifier", "pushContainer", "fromIndex", "incrementBy", "getCachedPaths", "msg", "type", "NodePath", "listKey", "setContext", "verifiedNodes", "replaceWithMultiple", "exports", "hoist", "hoister", "PathHoister", "run", "_codeFrame", "require", "_index", "_index2", "_cache", "_modification", "_parser", "_t", "_context", "FUNCTION_TYPES", "arrowFunctionExpression", "assignmentExpression", "awaitExpression", "blockStatement", "buildUndefinedNode", "callExpression", "cloneNode", "conditionalExpression", "expressionStatement", "getBindingIdentifiers", "identifier", "inheritLeadingComments", "inheritTrailingComments", "inheritsComments", "isBlockStatement", "isEmptyStatement", "isExpression", "isExpressionStatement", "isIfStatement", "isProgram", "isStatement", "isVariableDeclaration", "removeComments", "returnStatement", "sequenceExpression", "validate", "yieldExpression", "replaceWithMultiple", "nodes", "_getCachedPaths", "resync", "call", "_verifyNodeList", "node", "length", "getCachedPaths", "delete", "container", "key", "paths", "insertAfter", "requeue", "remove", "replaceWithSourceString", "replacement", "ast", "parse", "err", "loc", "message", "codeFrameColumns", "start", "line", "column", "code", "expressionAST", "program", "body", "expression", "traverse", "removeProperties", "replaceWith", "replacementPath", "removed", "Error", "NodePath", "Array", "isArray", "nodePath", "isNodeType", "canHaveVariableDeclarationOrExpression", "canSwapBetweenExpressionAndStatement", "parentPath", "isExportDefaultDeclaration", "replaceExpressionWithStatements", "oldNode", "_replaceWith", "type", "setScope", "get", "_getCachedPaths2", "ReferenceError", "inList", "parent", "debug", "set", "declars", "nodesAsSingleExpression", "gatherSequenceExpressions", "id", "scope", "push", "functionParent", "getFunctionParent", "isParentAsync", "async", "isParentGenerator", "generator", "callee", "hoistVariables", "completionRecords", "getCompletionRecords", "path", "loop", "findParent", "isLoop", "uid", "getData", "generateDeclaredUidIdentifier", "pushContainer", "setData", "name", "arrowFunctionToExpression", "newCallee", "needToAwaitFunction", "hasType", "needToYieldFunction", "exprs", "ensureLastUndefined", "kind", "declar", "declarations", "bindings", "Object", "keys", "init", "consequent", "alternate", "test", "indexOf", "replaceInline", "_containerInsertAfter", "VALID_OBJECT_CALLEES", "VALID_IDENTIFIER_CALLEES", "INVALID_METHODS", "isValidObjectCallee", "val", "includes", "isValidIdentifierCallee", "isInvalidMethod", "evaluateTruthy", "res", "evaluate", "confident", "value", "deopt", "path", "state", "deoptPath", "Globals", "Map", "undefined", "Infinity", "NaN", "evaluateCached", "node", "seen", "has", "existing", "get", "resolved", "item", "set", "_evaluate", "isSequenceExpression", "exprs", "length", "isStringLiteral", "isNumericLiteral", "isBooleanLiteral", "isNullLiteral", "isTemplateLiteral", "evaluateQuasis", "quasis", "isTaggedTemplateExpression", "isMemberExpression", "object", "name", "property", "isIdentifier", "scope", "getBinding", "quasi", "isConditionalExpression", "testResult", "isExpressionWrapper", "parentPath", "isCallExpression", "callee", "isLiteral", "type", "key", "computed", "isReferencedIdentifier", "binding", "constantViolations", "start", "end", "bindingPathScope", "kind", "hasUnsafeBlock", "isBlockStatement", "parent", "_scope$path$parentPat", "hasValue", "resolve", "references", "isUnaryExpression", "prefix", "operator", "argument", "isFunction", "isClass", "arg", "isArrayExpression", "arr", "elems", "elem", "elemValue", "push", "isObjectExpression", "obj", "props", "prop", "isObjectMethod", "isSpreadElement", "keyPath", "valuePath", "isLogicalExpression", "wasConfident", "left", "leftConfident", "right", "rightConfident", "isBinaryExpression", "Math", "pow", "context", "func", "global", "hasOwnProperty", "call", "args", "map", "apply", "raw", "str", "i", "cooked", "expr", "String", "_t", "require", "assertExpressionStatement", "makeStatementFormatter", "fn", "code", "str", "validate", "unwrap", "ast", "program", "body", "slice", "smart", "exports", "length", "statements", "statement", "Error", "expression", "start", "stmt", "merge", "a", "b", "placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders", "parser", "Object", "assign", "validate", "opts", "Error", "_ref", "_objectWithoutPropertiesLoose", "_excluded", "Set", "RegExp", "undefined", "normalizeReplacements", "replacements", "Array", "isArray", "reduce", "acc", "replacement", "i", "_t", "require", "_parser", "_codeFrame", "isCallExpression", "isExpressionStatement", "isFunction", "isIdentifier", "isJSXIdentifier", "isNewExpression", "isPlaceholder", "isStatement", "isStringLiteral", "removePropertiesDeep", "traverse", "PATTERN", "parseAndBuildMetadata", "formatter", "code", "opts", "placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders", "ast", "parseWithCodeFrame", "parser", "validate", "state", "syntactic", "placeholders", "placeholderNames", "Set", "legacy", "placeholderVisitorHandler", "Object", "assign", "length", "node", "ancestors", "_state$placeholderWhi", "name", "hasSyntacticPlaceholders", "Error", "value", "test", "has", "slice", "parent", "key", "type", "expectedNode", "push", "resolve", "resolveAncestors", "isDuplicate", "add", "i", "index", "undefined", "parserOpts", "plugins", "allowAwaitOutsideFunction", "allowReturnOutsideFunction", "allowNewTargetOutsideFunction", "allowSuperOutsideMethod", "allowYieldOutsideFunction", "sourceType", "parse", "err", "loc", "message", "codeFrameColumns", "start", "_t", "require", "blockStatement", "cloneNode", "emptyStatement", "expressionStatement", "identifier", "isStatement", "isStringLiteral", "stringLiteral", "validate", "populatePlaceholders", "metadata", "replacements", "ast", "placeholders", "forEach", "placeholder", "hasOwnProperty", "call", "name", "placeholderName", "Error", "Object", "keys", "key", "placeholderNames", "has", "slice", "reverse", "_ref", "applyReplacement", "e", "message", "replacement", "isDuplicate", "Array", "isArray", "map", "node", "parent", "index", "resolve", "type", "undefined", "set", "value", "typeAnnotation", "optional", "decorators", "items", "splice", "_options", "require", "_parse", "_populate", "stringTemplate", "formatter", "code", "opts", "metadata", "arg", "replacements", "normalizeReplacements", "parseAndBuildMetadata", "unwrap", "populatePlaceholders", "_options", "require", "_parse", "_populate", "literalTemplate", "formatter", "tpl", "opts", "metadata", "names", "buildLiteralData", "arg", "defaultReplacements", "forEach", "replacement", "i", "replacements", "normalizeReplacements", "Object", "keys", "key", "hasOwnProperty", "call", "Error", "unwrap", "populatePlaceholders", "assign", "prefix", "raw", "join", "includes", "code", "buildTemplateCode", "parseAndBuildMetadata", "parser", "placeholderWhitelist", "Set", "concat", "Array", "from", "placeholderPattern", "preserveComments", "syntacticPlaceholders", "length", "value", "push", "_options", "require", "_string", "_literal", "NO_PLACEHOLDER", "validate", "placeholderPattern", "createTemplateBuilder", "formatter", "defaultOpts", "templateFnCache", "WeakMap", "templateAstCache", "cachedOpts", "Object", "assign", "tpl", "args", "length", "Error", "extendedTrace", "stringTemplate", "merge", "Array", "isArray", "builder", "get", "literalTemplate", "set", "ast", "fn", "rootStack", "error", "stack", "split", "slice", "join", "arg", "err", "formatters", "require", "_builder", "smart", "exports", "createTemplateBuilder", "statement", "statements", "expression", "program", "_default", "default", "Object", "assign", "bind", "undefined", "ast", "_t", "require", "_template", "_visitors", "_context", "arrowFunctionExpression", "assignmentExpression", "binaryExpression", "blockStatement", "callExpression", "conditionalExpression", "expressionStatement", "identifier", "isIdentifier", "jsxIdentifier", "logicalExpression", "LOGICAL_OPERATORS", "memberExpression", "metaProperty", "numericLiteral", "objectExpression", "restElement", "returnStatement", "sequenceExpression", "spreadElement", "stringLiteral", "super", "_super", "thisExpression", "toExpression", "unaryExpression", "toBindingIdentifierName", "isFunction", "isAssignmentPattern", "isRestElement", "getFunctionName", "cloneNode", "variableDeclaration", "variableDeclarator", "exportNamedDeclaration", "exportSpecifier", "inherits", "toComputedKey", "key", "isMemberExpression", "node", "property", "isProperty", "isMethod", "ReferenceError", "computed", "name", "ensureBlock", "body", "get", "bodyNode", "Array", "isArray", "Error", "isBlockStatement", "statements", "stringPath", "listKey", "isStatement", "push", "parentPath", "setup", "call", "exports", "arrowFunctionToShadowed", "isArrowFunctionExpression", "arrowFunctionToExpression", "unwrapFunctionEnvironment", "isFunctionExpression", "isFunctionDeclaration", "buildCodeFrameError", "hoistFunctionEnvironment", "setType", "path", "type", "allowInsertArrow", "allowInsertArrowWithRest", "noNewArrows", "_arguments$", "arguments", "specCompliant", "self", "_self$ensureFunctionN", "ensureFunctionName", "thisBinding", "fnPath", "fn", "checkBinding", "scope", "generateUidIdentifier", "id", "init", "unshiftContainer", "hub", "addHelper", "replaceWith", "getSuperCallsVisitor", "environmentVisitor", "CallExpression", "child", "allSuperCalls", "isSuper", "arrowParent", "thisEnvFn", "findParent", "p", "isProgram", "isClassProperty", "static", "isClassPrivateProperty", "inConstructor", "isClassMethod", "kind", "thisPaths", "argumentsPaths", "newTargetPaths", "superProps", "superCalls", "getScopeInformation", "length", "traverse", "superBinding", "getSuperBinding", "forEach", "superCall", "callee", "loc", "argumentsBinding", "getBinding", "args", "buildUndefinedNode", "argumentsChild", "argsRef", "newTargetBinding", "targetChild", "targetRef", "flatSuperProps", "reduce", "acc", "superProp", "concat", "standardizeSuperProperty", "superParentPath", "isAssignment", "isAssignmentExpression", "left", "isCall", "isCallExpression", "isTaggedTemplate", "isTaggedTemplateExpression", "tag", "getSuperPropBinding", "value", "right", "getThisBinding", "hasSuperClass", "thisChild", "thisRef", "isJSX", "isLogicalOp", "op", "includes", "operator", "assignmentPath", "slice", "isLogicalAssignment", "tmp", "generateDeclaredUidIdentifier", "object", "rightExpression", "isUpdateExpression", "updateExpr", "computedKey", "parts", "prefix", "superClass", "assignSuperThisVisitor", "supers", "has", "add", "replaceWithMultiple", "WeakSet", "argsBinding", "propName", "argsList", "fnBody", "method", "unshift", "valueIdent", "cacheKey", "data", "getData", "setData", "getScopeInformationVisitor", "ThisExpression", "JSXIdentifier", "isJSXMemberExpression", "isJSXOpeningElement", "MemberExpression", "Identifier", "isReferencedIdentifier", "curr", "hasOwnBinding", "rename", "parent", "MetaProperty", "splitExportDeclaration", "isExportDeclaration", "isExportAllDeclaration", "isExportNamedDeclaration", "declaration", "isExportDefaultDeclaration", "standaloneDeclaration", "isClassDeclaration", "exportExpr", "isClassExpression", "isScope", "needBindingRegistration", "hasBinding", "updatedDeclaration", "updatedExportDeclaration", "insertAfter", "registerDeclaration", "bindingIdentifiers", "getOuterBindingIdentifiers", "specifiers", "Object", "keys", "map", "aliasDeclar", "refersOuterBindingVisitor", "state", "needsRename", "stop", "Scope", "skip", "supportUnicodeId", "res", "test", "startsWith", "replace", "originalNode", "binding", "getOwnBinding", "hasGlobal", "getProgramParent", "references", "params", "i", "len", "getFunctionArity", "template", "expression", "ast", "count", "findIndex", "param", "_t", "require", "STATEMENT_OR_BLOCK_KEYS", "VISITOR_KEYS", "isBlockStatement", "isExpression", "isIdentifier", "isLiteral", "isStringLiteral", "isType", "matchesPattern", "_matchesPattern", "pattern", "allowPartial", "node", "exports", "has", "key", "_this$node", "val", "Array", "isArray", "length", "isStatic", "scope", "is", "isnt", "equals", "value", "isNodeType", "type", "canHaveVariableDeclarationOrExpression", "parentPath", "isFor", "canSwapBetweenExpressionAndStatement", "replacement", "isArrowFunctionExpression", "isCompletionRecord", "allowInsideFunction", "path", "first", "container", "isFunction", "isProgram", "isDoExpression", "isStatementOrBlock", "isLabeledStatement", "includes", "referencesImport", "moduleSource", "importName", "isReferencedIdentifier", "isJSXMemberExpression", "property", "name", "isMemberExpression", "isOptionalMemberExpression", "computed", "object", "get", "binding", "getBinding", "kind", "parent", "isImportDeclaration", "source", "isImportDefaultSpecifier", "isImportNamespaceSpecifier", "isImportSpecifier", "imported", "getSource", "end", "code", "hub", "getCode", "slice", "start", "willIMaybeExecuteBefore", "target", "_guessExecutionStatusRelativeTo", "getOuterFunction", "getFunctionParent", "getProgramParent", "isExecutionUncertain", "isExecutionUncertainInList", "paths", "maxIndex", "i", "parentKey", "SYMBOL_CHECKING", "Symbol", "_guessExecutionStatusRelativeToCached", "Map", "base", "cache", "funcParent", "this", "_guessExecutionStatusRelativeToDifferentFunctionsCached", "getAncestry", "commonPath", "commonIndex", "indexOf", "Error", "divergence", "listKey", "keys", "keyPosition", "_guessExecutionStatusRelativeToDifferentFunctionsInternal", "isFunctionDeclaration", "isExportDeclaration", "id", "references", "referencePaths", "allStatus", "childOfFunction", "find", "isCallExpression", "status", "nodeMap", "cached", "set", "result", "resolve", "dangerous", "resolved", "_resolve", "call", "_resolved", "push", "isVariableDeclarator", "constant", "ret", "isTypeCastExpression", "targetKey", "toComputedKey", "targetName", "isObjectExpression", "props", "prop", "isProperty", "match", "isArrayExpression", "isNaN", "elems", "elem", "isConstantExpression", "isRegExpLiteral", "isTemplateLiteral", "every", "expression", "isUnaryExpression", "operator", "isBinaryExpression", "hasBinding", "noGlobals", "arguments", "isInStrictMode", "strictParent", "sourceType", "isClass", "body", "directive", "directives", "_index", "require", "_t", "getAssignmentIdentifiers", "_getAssignmentIdentifiers", "getBindingIdentifiers", "_getBindingIdentifiers", "getOuterBindingIdentifiers", "_getOuterBindingIdentifiers", "numericLiteral", "unaryExpression", "NORMAL_COMPLETION", "BREAK_COMPLETION", "NormalCompletion", "path", "type", "BreakCompletion", "getOpposite", "key", "getSibling", "addCompletionRecords", "records", "context", "push", "_getCompletionRecords", "completionRecordForSwitch", "cases", "lastNormalCompletions", "i", "length", "casePath", "caseCompletions", "normalCompletions", "breakCompletions", "c", "normalCompletionToBreak", "completions", "forEach", "replaceBreakStatementInBreakCompletion", "reachable", "isBreakStatement", "label", "replaceWith", "remove", "getStatementListCompletion", "paths", "canHaveBreak", "newContext", "Object", "assign", "inCaseClause", "isBlockStatement", "shouldPopulateBreak", "statementCompletions", "every", "some", "isDeclaration", "shouldPreserveBreak", "pathCompletions", "isVariableDeclaration", "isEmptyStatement", "isIfStatement", "get", "isDoExpression", "isFor", "isWhile", "isLabeledStatement", "isProgram", "isFunction", "isTryStatement", "isCatchClause", "isSwitchStatement", "isSwitchCase", "getCompletionRecords", "map", "r", "NodePath", "parentPath", "parent", "container", "listKey", "setContext", "getPrevSibling", "getNextSibling", "getAllNextSiblings", "_key", "sibling", "siblings", "node", "getAllPrevSiblings", "parts", "split", "_getKey", "call", "_getPattern", "Array", "isArray", "_", "part", "duplicates", "getBindingIdentifierPaths", "outerOnly", "search", "ids", "create", "id", "shift", "keys", "isIdentifier", "_ids", "name", "isExportDeclaration", "declaration", "isFunctionDeclaration", "isFunctionExpression", "child", "getOuterBindingIdentifierPaths", "_t", "require", "addComment", "_addComment", "addComments", "_addComments", "shareCommentsWithSiblings", "key", "node", "trailing", "trailingComments", "leading", "leadingComments", "prev", "getSibling", "next", "hasPrev", "Boolean", "hasNext", "removeIfExisting", "list", "toRemove", "length", "set", "Set", "filter", "el", "has", "type", "content", "line", "comments", "virtualTypes", "require", "_debug", "_index", "_index2", "_t", "t", "cache", "_generator", "NodePath_ancestry", "NodePath_inference", "NodePath_replacement", "NodePath_evaluation", "NodePath_conversion", "NodePath_introspection", "_context", "NodePath_context", "NodePath_removal", "NodePath_modification", "NodePath_family", "NodePath_comments", "NodePath_virtual_types_validator", "validate", "debug", "buildDebug", "REMOVED", "exports", "SHOULD_STOP", "SHOULD_SKIP", "NodePath_Final", "default", "NodePath", "constructor", "hub", "parent", "contexts", "state", "opts", "_traverseFlags", "skipKeys", "parentPath", "container", "listKey", "key", "node", "type", "_store", "data", "context", "scope", "removed", "v", "shouldStop", "shouldSkip", "get", "Error", "targetNode", "paths", "getOrCreateCachedPaths", "path", "set", "setup", "call", "getScope", "isScope", "Scope", "setData", "val", "Object", "create", "getData", "def", "undefined", "hasNode", "buildCodeFrameError", "msg", "SyntaxError", "buildError", "traverse", "visitor", "getPathLocation", "parts", "inList", "unshift", "join", "message", "enabled", "toString", "generator", "code", "parentKey", "methods", "findParent", "find", "getFunctionParent", "getStatementParent", "getEarliestCommonAncestorFrom", "getDeepestCommonAncestorFrom", "getAncestry", "isAncestor", "isDescendant", "inType", "getTypeAnnotation", "isBaseType", "couldBeBaseType", "baseTypeStrictlyMatches", "isGenericType", "replaceWithMultiple", "replaceWithSourceString", "replaceWith", "replaceExpressionWithStatements", "replaceInline", "evaluateTruthy", "evaluate", "toComputedKey", "ensureBlock", "unwrapFunctionEnvironment", "arrowFunctionToExpression", "splitExportDeclaration", "ensureFunctionName", "matchesPattern", "isStatic", "isNodeType", "canHaveVariableDeclarationOrExpression", "canSwapBetweenExpressionAndStatement", "isCompletionRecord", "isStatementOrBlock", "referencesImport", "getSource", "willIMaybeExecuteBefore", "_guessExecutionStatusRelativeTo", "resolve", "isConstantExpression", "isInStrictMode", "isDenylisted", "visit", "skip", "skipKey", "stop", "setContext", "requeue", "requeueComputedKeyAndDecorators", "remove", "insertBefore", "insertAfter", "unshiftContainer", "pushContainer", "getOpposite", "getCompletionRecords", "getSibling", "getPrevSibling", "getNextSibling", "getAllNextSiblings", "getAllPrevSiblings", "getAssignmentIdentifiers", "getBindingIdentifiers", "getOuterBindingIdentifiers", "getBindingIdentifierPaths", "getOuterBindingIdentifierPaths", "shareCommentsWithSiblings", "addComment", "addComments", "assign", "prototype", "arrowFunctionToShadowed", "String", "has", "is", "isnt", "equals", "hoist", "updateSiblingKeys", "isBlacklisted", "setScope", "resync", "popContext", "pushContext", "setKey", "_guessExecutionStatusRelativeToDifferentFunctions", "_getTypeAnnotation", "_replaceWith", "_resolve", "_call", "_resyncParent", "_resyncKey", "_resyncList", "_resyncRemoved", "_getQueueContexts", "_removeFromScope", "_callRemovalHooks", "_remove", "_markRemoved", "_assertUnremoved", "_containerInsert", "_containerInsertBefore", "_containerInsertAfter", "_verifyNodeList", "_getKey", "_getPattern", "TYPES", "typeKey", "fn", "TypeError", "keys", "includes", "push", "_index", "require", "_t", "_context", "VISITOR_KEYS", "TraversalContext", "constructor", "scope", "opts", "state", "parentPath", "queue", "priorityQueue", "shouldVisit", "node", "enter", "exit", "type", "keys", "length", "key", "create", "container", "listKey", "NodePath", "get", "parent", "maybeQueue", "path", "notPriority", "push", "visitMultiple", "visitQueue", "visitSingle", "visited", "WeakSet", "stop", "visitIndex", "resync", "call", "contexts", "pushContext", "has", "add", "visit", "i", "popContext", "nodes", "Array", "isArray", "exports", "default", "_context", "require", "_index", "_t", "_context2", "VISITOR_KEYS", "traverseNode", "node", "opts", "scope", "state", "path", "skipKeys", "visitSelf", "keys", "type", "context", "TraversalContext", "parentKey", "visitQueue", "key", "visit", "_traverseNode", "require", "_index", "_removal", "t", "call", "key", "opts", "debug", "node", "_call", "_opts$this$node$type", "type", "fns", "fn", "ret", "state", "then", "Error", "_traverseFlags", "isDenylisted", "_this$opts$denylist", "denylist", "blacklist", "includes", "exports", "isBlacklisted", "restoreContext", "path", "context", "visit", "_this$opts$shouldSkip", "_this$opts", "shouldSkip", "currentContext", "shouldStop", "traverseNode", "scope", "skipKeys", "skip", "skipKey", "stop", "SHOULD_SKIP", "SHOULD_STOP", "setScope", "_this$opts2", "_this$scope", "noScope", "parentPath", "listKey", "isMethod", "isSwitchStatement", "target", "_path$opts", "getScope", "init", "setContext", "resync", "removed", "_resyncParent", "_resyncList", "_resyncKey", "parent", "container", "Array", "isArray", "i", "length", "setKey", "Object", "keys", "inList", "newContainer", "_resyncRemoved", "_markRemoved", "popContext", "contexts", "pop", "undefined", "pushContext", "push", "setup", "_this$node", "requeue", "pathToQueue", "maybeQueue", "requeueComputedKeyAndDecorators", "isPrivate", "computed", "get", "decorators", "decorator", "_getQueueContexts", "Hub", "getCode", "getScope", "addHelper", "Error", "buildError", "node", "msg", "TypeError", "exports", "default", "require", "visitors", "exports", "_t", "cache", "_traverseNode", "_index", "_index2", "_hub", "VISITOR_KEYS", "removeProperties", "traverseFast", "traverse", "parent", "opts", "scope", "state", "parentPath", "visitSelf", "noScope", "type", "Error", "explode", "traverseNode", "_default", "default", "verify", "cheap", "node", "enter", "path", "skipKeys", "clearNode", "tree", "hasType", "denylistTypes", "includes", "skip", "stop"]
}
